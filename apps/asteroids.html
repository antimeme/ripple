<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Asteroids</title>
<style>
 html, body
 { position: absolute; padding: 0; margin: 0; overflow: hidden; }
 canvas { background: #222; color: #eee; }
</style>
<!-- :TODO: make touch controls work -->

<script src="ripple/polyfill.js"></script>
<script src="ripple/ripple.js"></script>
<script src="ripple/fascia.js"></script>
<script src="ripple/multivec.js"></script>
<script>//<![CDATA[
 // Asteroids is a space-themed multidirectional shooter arcade game
 // designed by Lyle Rains, Ed Logg and Dominic Walsh and released
 // by Atari in 1979.  It's a classic.
 // Source: https://en.wikipedia.org/wiki/Asteroids_(video_game)
 //
 // The player controls a space ship in an asteroid field which is
 // periodically traversed by flying saucers.
 //
 // The original game awarded 20 points for destroying each large
 // asteroid, 50 for each medium sized and 100 for each small one.
 // Destroying large flying saucers was worth 200 points and small
 // ones were worth 1,000.  Each time the player gained another
 // 10,000 points an extra life was awarded.
 fascia.ready(function() {
     "use strict";
     var newlife = Math.max(parseInt(
         ripple.param('nasteroids'), 10), 1000) || 10000;
     var nasteroids = Math.max(parseInt(
         ripple.param('nasteroids'), 10), 1) || 8;
     var saucerRespawn = Math.max(
         parseInt(ripple.param('saucer-respawn'), 10) || 8000, 1000);
     var size = 1000;
     var debris = [];
     var asteroids = [];
     var respawn = 1000;
     var reset = 0;

     var checkCollide = function(a, b, ms) {
         return multivec.collideRadiusRadius(
             {x: a.x, y: a.y},
             {x: a.x + a.dx * ms, y: a.y + a.dy * ms}, a.size/2,
             {x: b.x, y: b.y},
             {x: b.x + b.dx * ms, y: b.y + b.dy * ms}, b.size/2);
     };

     var createShot = function(vessel, direction) {
         if (!isNaN(direction))
             direction = {x: Math.cos(direction),
                          y: Math.sin(direction) };

         return { // Shot
             x: vessel.x, y: vessel.y, duration: 0,
                  dx: direction.x + vessel.dx,
                  dy: direction.y + vessel.dy,
                  size: size * 3 / 200,
                  draw: function(ctx) {
                      ctx.moveTo(this.x + this.size/2, this.y);
                      ctx.arc(this.x, this.y, this.size/2, 0, 2 * Math.PI);
                  },
                  update: function(ms, camera) {
                      var result = false;
                      this.duration += ms;
                      if (this.duration < 300) {
                          this.x += this.dx * ms;
                          if (this.x - this.size > camera.width/2)
                              this.x = -camera.width/2 - this.size;
                          else if (this.x + this.size < -camera.width/2)
                              this.x = camera.width/2 + this.size;
                          this.y += this.dy * ms;
                          if (this.y - this.size > camera.height/2)
                              this.y = -camera.height/2 - this.size;
                          else if (this.y + this.size < -camera.height/2)
                              this.y = camera.height/2 + this.size;
                          result = true;
                      }
                      return result;
                  }
         };
     };

     var ship = {
         x: 0, y: 0, dx: 0, dy: 0,
         size: 30, direction: -Math.PI/2,
         left: false, right: false, target: undefined,
         thrust: false, warp: false, warpCooldown: 0,
         shots: [], score: 0, dead: 0, lives: 3,
         resize: function(size) { this.size = size / 20; },
         drawShape: function(ctx) {
             ctx.moveTo(1, 0);
             ctx.lineTo(-1, 2/3);
             ctx.lineTo(-2/3, 0);
             ctx.lineTo(-1, -2/3);
             ctx.lineTo(1, 0);
         },
         draw: function(ctx) {
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(this.direction);
             ctx.scale(this.size/2, this.size/2);
             ctx.beginPath();
             if (this.dead <= 0) {
                 this.drawShape(ctx);
                 if (this.thrust) {
                     var figure = [
                         {x: -1, y: 1/3},
                         {x: -3/2, y: 0},
                         {x: -1, y: -1/3},
                     ];
                     var index = figure.length - 1;
                     ctx.moveTo(figure[index].x, figure[index].y);
                     figure.forEach(function(point) {
                         var factor = 0.33;
                         var rx = (Math.random() - 1/2) * factor;
                         var ry = (Math.random() - 1/2) * factor;
                         ctx.lineTo(point.x + rx, point.y + ry);
                     });
                 }
             }
             ctx.restore();
             this.shots.forEach(function(shot) { shot.draw(ctx); });
             ctx.stroke();
         },
         update: function(ms, camera) {
             var activeShots = [];
             this.shots.forEach(function(shot) {
                 if (shot.update(ms, camera))
                     activeShots.push(shot);
             });
             this.shots = activeShots;

             // A dead ship eventually respawns, but can't interact
             // with anything until then.
             if (this.dead > 0) {
                 if (ms >= this.dead) {
                     ms -= this.dead;
                     this.dead = 0;

                     if (reset > 0)
                         this.dead = 500;
                     else asteroids.forEach(function(asteroid) {
                         // Don't respawn if an asteroid is on the way
                         if (checkCollide(asteroid, this, ms + 2000))
                             this.dead = 500;
                     }, this);

                     if (this.dead <= 0) {
                         this.lives -= 1;
                         this.clear();
                     }
                 } else this.dead -= ms;
             }
             if (this.dead > 0)
                 return;

             // Respond to keyboard events and to touch target.
             if (this.left)
                 this.direction -= ms / 200;
             else if (this.right)
                 this.direction += ms / 200;
             else if (!isNaN(this.target)) {
                 var difference = this.target - this.direction;
                 if (difference > Math.PI) {
                     this.target -= 2 * Math.PI;
                     difference = this.target - this.direction;
                 } else if (difference < -Math.PI) {
                     this.target += 2 * Math.PI;
                     difference = this.target - this.direction;
                 }

                 if (Math.abs(difference) < ms / 200) {
                     this.direction = this.target;
                     this.target = undefined;
                 } else if (difference > 0) {
                     this.direction += ms / 200;
                 } else this.direction -= ms / 200;
             }

             if (this.thrust) {
                 this.dx += Math.cos(this.direction) * ms / 1500;
                 this.dy += Math.sin(this.direction) * ms / 1500;
             }

             if (this.warpCooldown > 0) {
                 this.warpCooldown = Math.max(
                     0, this.warpCooldown - ms);
                 this.warp = false;
             }

             if (this.warp) {
                 // Move the ship to a "safe" location
                 var place = {x: this.x, y: this.y };

                 this.dx = this.dy = 0;
                 for (var ii = 0; ii < 100; ++ii) {
                     var crash = false;
                     place = {
                         x: ((Math.random() - 0.5) *
                             camera.width * 4 / 5),
                         y: ((Math.random() - 0.5) *
                             camera.height * 4 / 5) };

                     asteroids.forEach(function(asteroid) {
                         if (checkCollide(asteroid, this, ms + 1000))
                             crash = true;
                     }, this);
                     if (!crash)
                         break;
                 }
                 this.x = place.x;
                 this.y = place.y;
                 this.warp = false;
                 this.warpCooldown = 2000;
             }

             // Movement with wrap around
             this.x += this.dx * ms;
             if (this.x - this.size > camera.width/2)
                 this.x = -camera.width/2 - this.size;
             else if (this.x + this.size < -camera.width/2)
                 this.x = camera.width /2 + this.size;
             this.y += this.dy * ms;
             if (this.y - this.size > camera.height/2)
                 this.y = -camera.height/2 - this.size;
             else if (this.y + this.size < -camera.height/2)
                 this.y = camera.height/2 + this.size;
         },
         shoot: function() {
             if ((this.dead > 0) || (this.shots.length >= 8))
                 return;
             this.shots.push(createShot(this, this.direction));
         },
         aim: function(point, camera) {
             // This causes the ship to turn to face a specified point.
             var v = { x: (point.x - camera.width / 2) - this.x,
                       y: (point.y - camera.height / 2) - this.y };
             var len = v.x * v.x + v.y * v.y;
             if (len > this.size * this.size / 4) {
                 len = Math.sqrt(len);
                 v.x /= len;
                 v.y /= len;
                 this.target = Math.acos(v.x);
                 if (v.y < 0)
                     this.target = -this.target;
             } else this.shoot();
         },
         award: function(npoints) {
             if (Math.floor((this.score + npoints) / newlife) >
                 Math.floor(this.score / newlife))
                 this.lives += 1;
             this.score += npoints;
         },
         destroy: function() {
             var npieces = Math.floor(4 + 4 * Math.random());
             for (var ii = 0; ii < npieces; ++ii)
                 createDebris(this);
             this.dead = 3000;
             if (this.lives === 0)
                 reset = 5000;
         },
         clear: function() {
             this.direction = -Math.PI/2;
             this.warp = false;
             this.warpCooldown = 0;
             this.x  = this.y  = 0;
             this.dx = this.dy = 0;
         }
     };

     // A flying saucer that shoots at the player ship.  Only one
     // of these can exist at a time and it can be large or small.
     // The large ship fires in a random direction but the small
     // ship aims at the player ship.
     var saucer = {
         x: 0, y: 0, dx: 0, dy: 0,
         size: 30, direction: 0,
         shots: [], dead: -1, score: 0, small: false,
         turnTimer: 0, shootTimer: 0,
         resize: function(size) {
             this.size = size / (this.small ? 20 : 10);
         },
         draw: function(ctx) {
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(this.direction);
             ctx.scale(this.size/2, this.size/2);
             ctx.beginPath();
             if (this.dead <= 0) {
                 // This is the dome
                 ctx.moveTo(1/2, 0);
                 ctx.arc(0, 0, 1/2, 0, Math.PI, 1);
                 ctx.lineTo(1/2, 0);

                 // This is the saucer body
                 ctx.lineTo(3/4, 1/4);
                 ctx.lineTo(1/2, 1/2);
                 ctx.lineTo(-1/2, 1/2);
                 ctx.lineTo(-3/4, 1/4);
                 ctx.lineTo(-1/2, 0);
             }
             ctx.restore();
             this.shots.forEach(function(shot) {
                 ctx.moveTo(shot.x + shot.size/2, shot.y);
                 ctx.arc(shot.x, shot.y, shot.size/2, 0, Math.PI * 2);
             });
             ctx.stroke();
         },
         update: function(ms, camera) {
             var activeShots = [];
             this.shots.forEach(function(shot) {
                 if (shot.update(ms, camera))
                     activeShots.push(shot);
             });
             this.shots = activeShots;

             // A dead saucer eventually respawns, but can't interact
             // with anything or shoot until then.
             if (this.dead < 0) {
                 this.dead = saucerRespawn * (1 + Math.random());
             } else if (this.dead > 0) {
                 if (ms > this.dead) {
                     ms -= this.dead;
                     this.dead = 0;
                     this.x = size;
                     this.y = size;
                     this.turn = 2000;

                     this.small = (Math.random() * 40000 < ship.score);
                     this.resize(size);
                 } else {
                     this.dead -= ms;
                     return;
                 }
             }
             if (this.turnTimer > 0)
                 this.turnTimer -= ms;
             if (this.turnTimer <= 0) {
                 var direction = Math.random() * Math.PI * 2;
                 this.dx = Math.cos(direction) / 10;
                 this.dy = Math.sin(direction) / 10;
                 this.turnTimer = 2000 + 2000 * Math.random();
             }
             if (this.shootTimer > 0)
                 this.shootTimer -= ms;
             if (this.shootTimer <= 0) {
                 this.shoot(ms, camera);
                 this.shootTimer = ((this.small ? 1000 : 2000) *
                     (1 + Math.random()));
             }

             // Movement with wrap around
             this.x += this.dx * ms;
             if (this.x - this.size > camera.width/2)
                 this.x = -camera.width/2 - this.size;
             else if (this.x + this.size < -camera.width/2)
                 this.x = camera.width /2 + this.size;
             this.y += this.dy * ms;
             if (this.y - this.size > camera.height/2)
                 this.y = -camera.height/2 - this.size;
             else if (this.y + this.size < -camera.height/2)
                 this.y = camera.height/2 + this.size;
         },
         shoot: function(ms, camera) {
             if ((this.dead > 0) || (ship.dead > 0) ||
                 (this.shots.length >= 8))
                 return;
             var direction = this.small ? multivec(
                 {x: ship.x - this.x, y: ship.y - this.y}).normalize() :
                             (Math.random() * Math.PI * 2);
             this.shots.push(createShot(this, direction));
         },
         award: function(npoints) { /* No score for saucers, sadly */ },
         destroy: function() {
             var npieces = Math.floor(4 + 4 * Math.random());
             for (var ii = 0; ii < npieces; ++ii)
                 createDebris(this);
             this.x  = this.y  = 1000;
             this.dx = this.dy = 0;
             this.dead = saucerRespawn * (1 + Math.random());
         }
     };

     var drawRock = function(ctx, points, size) {
         if (points && points.length > 0) {
             var index = points.length - 1;
             var point = points[index];
             ctx.moveTo(
                 Math.cos(index * 2 * Math.PI /
                     points.length) * point * size,
                 Math.sin(index * 2 * Math.PI /
                     points.length) * point * size);
             points.forEach(function(point, index) {
                 ctx.lineTo(
                     Math.cos(index * 2 * Math.PI /
                         points.length) * point * size,
                     Math.sin(index * 2 * Math.PI /
                         points.length) * point * size); });
         }
     };

     var createAsteroid = function(config) {
         var points = [];
         var npoints = 8;
         var nsplits = 2;
         var score = 100;
         var direction = Math.random() * Math.PI * 2;
         var place = Math.random() * Math.PI * 2;
         var x = Math.cos(place) * 1000;
         var y = Math.sin(place) * 1000;

         if ((typeof(config) === "object") && config) {
             if (!isNaN(config.nsplits))
                 nsplits = config.nsplits;
             if (!isNaN(config.x))
                 x = config.x;
             if (!isNaN(config.y))
                 y = config.y;
             if (!isNaN(config.direction))
                 direction = config.direction;
             if (!isNaN(config.size))
                 size = config.size;
         }

         var ii;
         for (var ii = 0; ii < nsplits; ++ii) {
             npoints += 4;
             score = Math.floor(score / 20) * 10;
         }
         for (var ii = 0; ii < npoints; ++ii)
             points.push((Math.random() + 1) / 2);

         return { // Asteroid
             x: x, y: y, dx: 0, dy: 0, size: 0, score: score,
                  nsplits: nsplits, direction: direction,
                  angle: Math.random() * Math.PI * 2,
                  points: points,
                  draw: function(ctx) {
                      ctx.save();
                      ctx.translate(this.x, this.y);
                      ctx.rotate(this.angle);
                      ctx.scale(this.size/2, this.size/2);
                      ctx.beginPath();
                      drawRock(ctx, this.points, 1);
                      ctx.restore();
                      ctx.stroke();
                  },
                  update: function(ms, camera) {
                      if (this.size === 0)
                          this.resize(size);

                      this.angle += ms * Math.PI / (this.size * 30);

                      this.x += this.dx * ms;
                      if (this.x - this.size > camera.width/2)
                          this.x = -camera.width/2 - this.size;
                      else if (this.x + this.size < -camera.width/2)
                          this.x = camera.width/2 + this.size;

                      this.y += this.dy * ms;
                      if (this.y - this.size > camera.height/2)
                          this.y = -camera.height/2 - this.size;
                      else if (this.y + this.size < -camera.height/2)
                          this.y = camera.height/2 + this.size;
                  },
                  resize: function(size) {
                      this.size = size / 20;
                      for (var ii = 0; ii < nsplits; ++ii)
                          this.size *= 2;
                      this.dx = (Math.cos(direction) * 20 /
                          (this.size + 50));
                      this.dy = (Math.sin(direction) * 20 /
                          (this.size + 50));
                  },
                  split: function(active) {
                      // Fragments of the asteroid fly off in all
                      // directions.  Dramatic!
                      var npieces = Math.floor(4 + 4 * Math.random());
                      for (var ii = 0; ii < npieces; ++ii)
                          createDebris(this);

                      // Replace the asteroid with two smaller
                      // pieces, unless it's too small.
                      if (this.nsplits > 0) {
                          active.push(createAsteroid({
                              nsplits: this.nsplits - 1,
                              x: this.x, y: this.y}));
                          active.push(createAsteroid({
                              nsplits: this.nsplits - 1,
                              x: this.x, y: this.y}));
                      }
                  }
         };
     };

     var createDebris = function(source) {
         var direction = Math.random() * Math.PI * 2;
         var speed = (Math.random() + 1) / 10;
         var points = [];
         var npoints = Math.floor(Math.random() * 3) +  3;

         for (var ii = 0; ii < npoints; ++ii)
             points.push(1/2 + Math.random() / 2);

         debris.push({
             startx: source.x, starty: source.y,
             x: source.x, y: source.y,
             dx: source.dx + Math.cos(direction) * speed,
             dy: source.dy + Math.sin(direction) * speed,
             size: size / 100, duration: 500, points: points,
             update: function(ms) {
                 this.duration -= ms;
                 if (this.duration <= 0)
                     return false;
                 this.x += this.dx * ms;
                 this.y += this.dy * ms;
                 return true;
             },
             draw: function(ctx) {
                 ctx.save();
                 ctx.translate(this.x, this.y);
                 ctx.scale(this.size, this.size);
                 drawRock(ctx, this.points, 1);
                 ctx.restore();
             }
         });
     };

     return { // Facia App
         resize: function(camera) {
             size = Math.min(camera.width, camera.height);
             ship.resize(size);
             saucer.resize(size);
             asteroids.forEach(function(asteroid) {
                 asteroid.resize(size);
             });
         },
              drawBefore: function(ctx, camera, now, last) {
                  ctx.lineCap = "round";
                  ctx.lineWidth = size / 400;
                  ctx.font = (size / 20) + "px monospace";
                  ctx.fillText(ship.score.toLocaleString(),
                               size / 40, size / 15);

                  for (var ii = 0; ii < ship.lives; ++ii) {
                      ctx.save();
                      ctx.translate(size / 40 + ship.size * (ii + 1),
                                    size / 15 + ship.size);
                      ctx.rotate(-Math.PI / 2);
                      ctx.scale(ship.size / 2, ship.size / 2);
                      ship.drawShape(ctx);
                      ctx.restore();
                  }
                  ctx.stroke();
              },
              draw: function(ctx, camera, now, last) {
                  ctx.lineCap = "round";
                  ctx.lineWidth = size / 400;

                  ship.draw(ctx);
                  saucer.draw(ctx);
                  asteroids.forEach(function(asteroid) {
                      asteroid.draw(ctx); });

                  ctx.beginPath();
                  debris.forEach(function(piece) {
                      piece.draw(ctx); });
                  ctx.stroke();

                  if (reset > 0) {
                      ctx.font = (size / 10) + "px monospace";
                      var text = "GAME OVER";
                      var metrics = ctx.measureText(text);
                      ctx.fillText(text, -metrics.width / 2, -size/20);
                  }
              },

              update: function(ms, camera) {
                  if (ms > 100)
                      ms = 100;

                  var activeDebris = [];
                  debris.forEach(function(piece) {
                      if (piece.update(ms))
                          activeDebris.push(piece);
                  });
                  debris = activeDebris;

                  var activeAsteroids = [];
                  asteroids.forEach(function(asteroid) {
                      var survived = true;

                      var checkAsteroidShots = function(vessel) {
                          var activeShots = [];
                          vessel.shots.forEach(function(shot) {
                              if (checkCollide(shot, asteroid, ms)) {
                                  survived = false;
                                  asteroid.split(activeAsteroids);
                                  vessel.award(asteroid.score);
                              } else activeShots.push(shot);
                          });
                          vessel.shots = activeShots;
                      };
                      checkAsteroidShots(ship);
                      checkAsteroidShots(saucer);

                      if (survived && !ship.dead &&
                          checkCollide(ship, asteroid, ms)) {
                          ship.destroy();
                          asteroid.split(activeAsteroids);
                          survived = false;
                      }

                      if (survived && !saucer.dead &&
                          checkCollide(saucer, asteroid, ms)) {
                          saucer.destroy();
                          asteroid.split(activeAsteroids);
                          survived = false;
                      }

                      if (survived) {
                          asteroid.update(ms, camera);
                          activeAsteroids.push(asteroid);
                      }
                  });
                  asteroids = activeAsteroids;

                  if (reset > 0) {
                      reset -= ms;
                      if (reset <= 0) {
                          reset = 0;
                          respawn = 1000;
                          asteroids = [];
                          ship.score = 0;
                          ship.lives = 3;
                          saucer.dead = -1;
                      }
                  } else if (respawn > 0) {
                      respawn -= ms;
                      if (respawn <= 0) {
                          var count = nasteroids + Math.floor(
                              ship.score / 10000);
                          for (var ii = 0; ii < nasteroids; ++ii)
                              asteroids.push(createAsteroid());
                      }
                  } else if (asteroids.length === 0)
                      respawn = 5000;

                  var checkEnemyShots = function(vessel, enemy) {
                      if (enemy.dead > 0)
                          return;
                      var activeShots = [];
                      vessel.shots.forEach(function(shot) {
                          if (checkCollide(shot, enemy, ms)) {
                              enemy.destroy();
                              vessel.award(enemy.small ? 1000 : 200);
                          } else activeShots.push(shot);
                      }, activeShots);
                      vessel.shots = activeShots;
                  };
                  checkEnemyShots(ship, saucer);
                  checkEnemyShots(saucer, ship);
                  if ((ship.dead <= 0) && (saucer.dead <= 0) &&
                      checkCollide(ship, saucer, ms)) {
                      ship.destroy();
                      saucer.destroy();
                  }

                  ship.update(ms, camera);
                  saucer.update(ms, camera);
              },

              tap: function(event, camera) {
                  ship.aim(event.point, camera); },
              doubleTap: function(event, camera) { ship.shoot(); },
              keydown: function(event, camera) {
                  if (event.keyCode === 37 || event.key === 'a') {
                      ship.left = true; ship.right = false;
                      ship.target = undefined;
	          } else if (event.keyCode === 38 || event.key === 'w') {
                      ship.thrust = true;
	          } else if (event.keyCode === 39 || event.key === 'd') {
                      ship.right = true; ship.left = false;
                      ship.target = undefined;
	          } else if (event.keyCode === 40 || event.key === 's') {
                      ship.warp = true;
                  } else if (event.key === ' ' || event.key === "Enter") {
                      ship.shoot();
                  }
              },
              keyup: function(event, camera) {
                  if (event.keyCode === 37 || event.key === 'a')
                      ship.left = false;
	          else if (event.keyCode === 38 || event.key === 'w')
                      ship.thrust = false;
	          else if (event.keyCode === 39 || event.key === 'd')
                      ship.right = false;
              },
              isActive: true
     };
 }); //]]></script>
