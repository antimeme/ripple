<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<link rel="shortcut icon" data-x="https://yoksel.github.io/url-encoder/"
      href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='128' height='128'%3E%3Cpolygon points='64,8 107,120 64,98 21,120' stroke-width='12' stroke='%23222' fill='none' /%3E%3Cpolygon points='64,8 107,120 64,98 21,120' stroke-width='4' stroke='%23eee' fill='none' /%3E%3C/svg%3E%0A" />
<title>Asteroids</title>
<style>
 html, body
 { position: absolute; padding: 0; margin: 0; overflow: hidden; }
 canvas { background: #222; color: #eee; }
</style>
<!-- :TODO: optional on-screen controls -->

<script src="ripple/polyfill.js"></script>
<script src="ripple/ripple.js"></script>
<script src="ripple/fascia.js"></script>
<script src="ripple/multivec.js"></script>
<script>//<![CDATA[
 // asteroids.html
 // Copyright (C) 2020 by Jeff Gold.
 //
 // This program is free software: you can redistribute it and/or
 // modify it under the terms of the GNU General Public License as
 // published by the Free Software Foundation, either version 3 of the
 // License, or (at your option) any later version.
 //
 // This program is distributed in the hope that it will be useful, but
 // WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // General Public License for more details.
 //
 // You should have received a copy of the GNU General Public License
 // along with this program.  If not, see
 // <http://www.gnu.org/licenses/>.
 //
 // ---------------------------------------------------------------------
 //
 // This file is an independent clone of Asteroids, a space-themed
 // multidirectional shooter arcade game originally designed by Lyle
 // Rains, Ed Logg and Dominic Walsh and released by Atari in 1979.
 // Source: https://en.wikipedia.org/wiki/Asteroids_(video_game)
 //
 // The player controls a space ship in an asteroid field which is
 // periodically traversed by flying saucers.
 //
 // The original game awarded 20 points for destroying each large
 // asteroid, 50 for each medium sized and 100 for each small one.
 // Destroying large flying saucers was worth 200 points and small
 // ones were worth 1,000.  Each time the player gained another
 // 10,000 points an extra life was awarded.
 fascia.ready(function() {
     "use strict";
     var o_newlife = Math.max(ripple.paramInt(
         "newlife"), 1000) || 10000;
     var o_nasteroids     = Math.max(ripple.paramInt("nasteroids"), 0);
     var o_saucer_respawn = Math.max(ripple.paramInt(
         "saucer-respawn") || 8000, 1000);
     var o_small_score    = Math.max(ripple.paramInt(
         "small-score"), 0) || 40000;
     var o_messy   = ripple.paramBoolean("messy");
     var o_rings   = ripple.paramBoolean("rings");
     var o_shields = ripple.paramBoolean("shields");
     var o_repeat  = ripple.paramBoolean("repeat");
     var o_nobuttons = ripple.paramBoolean("nobuttons");

     var score = 0;
     var asteroids = [];
     var debris = [];
     var nextwave = 1000; // Milliseconds until astroids respawn
     var reset = 0;       // Milliseconds until the game resets
     var size = 1000;

     var checkCollide = function(a, b, ms) {
         return (((
             (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)) <=
                 ((a.size + b.size) * (a.size + b.size) / 4)) ?
                 true : multivec.collideRadiusRadius(
                     {x: a.x, y: a.y},
                     {x: a.x + a.dx * ms, y: a.y + a.dy * ms},
                     a.size/2, {x: b.x, y: b.y},
                     {x: b.x + b.dx * ms, y: b.y + b.dy * ms},
                     b.size/2));
     };

     var moveWrap = function(thing, ms, camera) {
         thing.x += thing.dx * ms;
         if (thing.x - thing.size > camera.width/2)
             thing.x = -camera.width/2 - thing.size;
         else if (thing.x + thing.size < -camera.width/2)
             thing.x = camera.width/2 + thing.size;
         thing.y += thing.dy * ms;
         if (thing.y - thing.size > camera.height/2)
             thing.y = -camera.height/2 - thing.size;
         else if (thing.y + thing.size < -camera.height/2)
             thing.y = camera.height/2 + thing.size;
     };

     var drawRing = function(ctx, thing) {
         if (!o_rings || (!isNaN(thing.dead) && thing.dead > 0))
             return;
         ctx.save();
         ctx.beginPath();
         ctx.strokeStyle = "red";
         ctx.arc(thing.x, thing.y, thing.size/2, 0, Math.PI * 2);
         ctx.stroke();
         ctx.restore();
     };

     var createShield = function(enable) {
         return {
             ready: enable, recharge: 0,
             draw: function(ctx, vessel) {
                 if (!this.ready || (vessel.dead > 0))
                     return;
                 ctx.save();
                 ctx.beginPath();
                 ctx.strokeStyle = "blue";
                 ctx.arc(vessel.x, vessel.y, vessel.size * 11 / 20,
                         0, Math.PI * 2);
                 ctx.stroke();
                 ctx.restore();
             },
             update: function(camera, ms) {
                 if (this.recharge > 0) {
                     this.recharge -= ms;
                     if (this.recharge <= 0) {
                         this.recharge = 0;
                         this.ready = true;
                     }
                 }
             },
             absorb: function() {
                 var result = true;
                 if (this.ready) {
                     this.ready = false;
                     this.recharge = 5000;
                 } else result = false;
                 return result;
             },
             reset: function() {
                 this.ready = o_shields;
                 this.recharge = 0;
             }
         }
     };

     var createShot = function(vessel, direction) {
         var speed = size / 650;
         var velocity;
         if (!isNaN(direction)) {
             velocity = { x: speed * Math.cos(direction),
                          y: speed * Math.sin(direction) };
         } else velocity = { x: speed * direction.x,
                             y: speed * direction.y };

         return {
             x: vessel.x, y: vessel.y, duration: 0,
             dx: velocity.x + vessel.dx,
             dy: velocity.y + vessel.dy,
             size: size * 3 / 200, dead: 0,
             draw: function(ctx) {
                 ctx.moveTo(this.x + this.size/2, this.y);
                 ctx.arc(this.x, this.y, this.size/2,
                         0, 2 * Math.PI);
             },
             update: function(camera, ms) {
                 var result = false;
                 this.duration += ms;
                 if (this.duration < 300) {
                     moveWrap(this, ms, camera);
                     result = true;
                 }
                 return result;
             }
         };
     };

     var createDebris = function(source) {
         var direction = Math.random() * Math.PI * 2;
         var speed = size * (Math.random() + 1) / 5000;
         var points = [];
         var npoints = Math.floor(Math.random() * 3) +  3;

         for (var ii = 0; ii < npoints; ++ii)
             points.push(1/2 + Math.random() / 2);

         return {
             x: source.x, y: source.y,
             dx: source.dx + Math.cos(direction) * speed,
             dy: source.dy + Math.sin(direction) * speed,
             size: size / 100, duration: 900, points: points,
             update: function(camera, ms) {
                 if (!o_messy) {
                     this.duration -= ms;
                     if (this.duration <= 0)
                         return false;
                 }
                 this.x += this.dx * ms;
                 this.y += this.dy * ms;
                 return ((this.x <= camera.width) &&
                         (this.x >= -camera.width) &&
                         (this.y <= camera.height) &&
                         (this.y >= -camera.height));
             },
             draw: function(ctx) {
                 ctx.save();
                 ctx.translate(this.x, this.y);
                 ctx.scale(this.size, this.size);
                 drawRock(ctx, this.points, 1);
                 ctx.restore();
             }
         };
     };

     var ship = {
         x: 0, y: 0, dx: 0, dy: 0,
         left: false, right: false,
         target: undefined, down: null,
         thrust: false, warp: false, warpCooldown: 0,
         shots: [], dead: 0, lives: 3,
         size: 0, direction: -Math.PI/2,
         shield: createShield(o_shields),
         resize: function(size) { this.size = size / 20; },
         drawShape: function(ctx) {
             ctx.moveTo(1, 0);
             ctx.lineTo(-1, 2/3);
             ctx.lineTo(-2/3, 0);
             ctx.lineTo(-1, -2/3);
             ctx.lineTo(1, 0);
         },
         draw: function(ctx) {
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(this.direction);
             ctx.scale(this.size/2, this.size/2);
             ctx.beginPath();
             if (this.dead <= 0) {
                 this.drawShape(ctx);
                 if (this.thrust ||
                     (this.down && this.down.duration > 250)) {
                     var figure = [
                         {x: -1, y: 1/3},
                         {x: -3/2, y: 0},
                         {x: -1, y: -1/3},
                     ];
                     var index = figure.length - 1;
                     figure.forEach(function(point) {
                         point.x += (Math.random() - 1/2) * 0.33;
                         point.y += (Math.random() - 1/2) * 0.33;
                     });

                     ctx.moveTo(figure[index].x, figure[index].y);
                     figure.forEach(function(point) {
                         ctx.lineTo(point.x, point.y); });
                 }
             }
             ctx.restore();
             this.shots.forEach(function(shot) {
                 if (shot) shot.draw(ctx); });
             ctx.stroke();
             this.shield.draw(ctx, this);
             drawRing(ctx, this);
         },
         update: function(camera, ms) {
             if (this.size === 0)
                 this.resize(Math.min(camera.width, camera.height));

             var activeShots = [];
             this.shots.forEach(function(shot) {
                 if (!shot) return;
                 if (shot.update(camera, ms))
                     activeShots.push(shot);
             });
             this.shots = activeShots;

             // A dead ship eventually respawns, but can't interact
             // with anything until then.
             if (reset > 0)
                 this.dead = reset;
             else if (this.dead > 0) {
                 this.dead -= ms;
                 if (this.dead <= 0) {
                     ms += this.dead;
                     this.dead = 0;

                     asteroids.forEach(function(asteroid) {
                         // Don't respawn if an asteroid is on the way
                         if (checkCollide(asteroid, this, 1500))
                             this.dead = 500;
                     }, this);

                     if (this.dead === 0) {
                         this.lives -= 1;
                         this.clear();
                     }
                 }
             }
             if (this.dead > 0)
                 return;

             // Respond to user input from keyboard, mouse or touch
             var thrust_ms = ms;
             if (this.left)
                 this.direction -= ms / 200;
             else if (this.right)
                 this.direction += ms / 200;
             else if (this.target) {
                 var desired = this.__desiredDirection(this.target);
                 if (!isNaN(desired)) {
                     var difference = desired - this.direction;
                     if (difference > Math.PI)
                         difference -= 2 * Math.PI;
                     else if (difference < -Math.PI)
                         difference += 2 * Math.PI;
                     this.direction += (
                         (difference < 0) ? -1 : 1) * Math.min(
                             Math.abs(difference), ms / 200);
                 } else if (this.down) {
                     this.down.duration += ms;
                     if ((this.down.duration > 250) && this.target) {
                         thrust_ms = Math.min(Math.max(
                             0, this.down.duration - 250), ms);
                         this.thrust = true;
                     }
                 }
             }
             if (this.thrust) {
                 this.dx += Math.cos(this.direction) * thrust_ms / 1500;
                 this.dy += Math.sin(this.direction) * thrust_ms / 1500;
             }

             if (this.warpCooldown > 0) {
                 this.warpCooldown = Math.max(
                     0, this.warpCooldown - ms);
                 this.warp = false;
             }
             if (this.warp) {
                 // Move the ship to a "safe" location
                 var place = { x: this.x, y: this.y, dead: 0,
                               dx: 0, dy: 0, size: this.size };

                 this.dx = this.dy = 0;
                 for (var ii = 0; ii < 100; ++ii) {
                     var crash = false;
                     place.x = ((Math.random() - 0.5) *
                         camera.width * 4 / 5);
                     place.y = ((Math.random() - 0.5) *
                         camera.height * 4 / 5);

                     asteroids.forEach(function(asteroid) {
                         if (checkCollide(asteroid, place, 1000))
                             crash = true;
                     }, this);
                     if (!crash)
                         break;
                 }
                 this.x = place.x;
                 this.y = place.y;
                 this.warp = false;
                 this.warpCooldown = 2000;
             }

             this.shield.update(camera, ms);
             moveWrap(this, ms, camera);
         },
         shoot: function() {
             if ((this.dead > 0) || (this.shots.length >= 8))
                 return;
             this.shots.push(createShot(this, this.direction));
         },
         __desiredDirection: function(target) {
             var result = undefined;
             var delta = multivec({ x: target.x - this.x,
                                    y: target.y - this.y });

             if (delta.quadrance() > this.size * this.size / 2) {
                 delta = delta.normalize();
                 if ((delta.dot({theta: this.direction}) < 0.999)) {
                     result = Math.acos(delta.x)
                     if (delta.y < 0)
                         result = -result;
                 }
             }
             return result;
         },
         aim: function(point, camera) {
             // Signals that the player wants the ship to face a
             // specified location.  If the ship is already pointing
             // there or the ship itself is the target we shoot
             // instead.  This means spam tapping a point will
             // eventually result in firing at it.
             if (isNaN(this.__desiredDirection(
                 this.target = { x: point.x - camera.width / 2,
                                 y: point.y - camera.height / 2 })))
                 this.shoot();
         },
         award: function(npoints) {
             if (Math.floor((score + npoints) / o_newlife) >
                 Math.floor(score / o_newlife))
                 this.lives += 1;
             score += npoints;
         },
         destroy: function() {
             if (this.shield.absorb())
                 return;
             var npieces = Math.floor(4 + 4 * Math.random());
             for (var ii = 0; ii < npieces; ++ii)
                 debris.push(createDebris(this));
             this.dead = 3000;
             this.clear();
             if (this.lives === 0)
                 reset = 5000;
         },
         clear: function() {
             this.direction = -Math.PI/2;
             this.warp = false;
             this.warpCooldown = 0;
             this.x  = this.y  = 0;
             this.dx = this.dy = 0;
             this.shield.reset();
         }
     };

     // A flying saucer that shoots at the player ship.  Only one
     // of these can exist at a time and it can be large or small.
     // The large ship fires in a random direction but the small
     // ship aims at the player ship.
     var saucer = {
         x: 0, y: 0, dx: 0, dy: 0,
         size: 0, direction: 0,
         shots: [], dead: o_saucer_respawn * 2,
         small: false, turnTimer: 0, shootTimer: 0,
         shield: createShield(o_shields),
         resize: function(size) {
             this.size = size / (this.small ? 20 : 10); },
         draw: function(ctx) {
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(this.direction);
             ctx.scale(this.size/2, this.size/2);
             ctx.beginPath();
             if (this.dead <= 0) {
                 // This is the dome
                 ctx.moveTo(1/2, 0);
                 ctx.arc(0, 0, 1/2, 0, Math.PI, 1);
                 ctx.lineTo(1/2, 0);

                 // This is the saucer body
                 ctx.lineTo(3/4, 1/4);
                 ctx.lineTo(1/2, 1/2);
                 ctx.lineTo(-1/2, 1/2);
                 ctx.lineTo(-3/4, 1/4);
                 ctx.lineTo(-1/2, 0);
             }
             ctx.restore();
             this.shots.forEach(function(shot) {
                 if (shot) shot.draw(ctx); });
             ctx.stroke();
             this.shield.draw(ctx, this);
             drawRing(ctx, this);
         },
         update: function(camera, ms) {
             if (this.size === 0)
                 this.resize(Math.min(camera.width, camera.height));

             var activeShots = [];
             this.shots.forEach(function(shot) {
                 if (shot && shot.update(camera, ms))
                     activeShots.push(shot); });
             this.shots = activeShots;

             // A dead saucer eventually respawns, but can't interact
             // with anything or shoot until then.
             if (this.dead > 0) {
                 if (ms >= this.dead) {
                     ms -= this.dead;
                     this.dead = 0;
                     this.x = (camera.width + this.size) / 2;
                     this.y = (camera.height + this.size) / 2;
                     this.dx = (((Math.random() * 2 > 1) ?
                                 1 : -1) * this.size /
                         (this.small ? 400 : 800));
                     this.turnTimer = 4000;

                     // Small saucers are more challenging because
                     // they shoot more quickly and aim at the player.
                     // At low scores most saucers are large but
                     // eventually only small saucers can spawn.
                     this.small = (Math.random() *
                         o_small_score < score);
                     this.resize(size);
                 } else { this.dead -= ms; return; }
             }
             if (this.dead > 0)
                 return;

             if (this.turnTimer > 0)
                 this.turnTimer -= ms;
             if (this.turnTimer <= 0) {
                 this.dy = this.dx * (Math.random() * 2 - 1);
                 this.turnTimer = 4000 * (1 * Math.random());
             }
             if (this.shootTimer > 0)
                 this.shootTimer -= ms;
             if (this.shootTimer <= 0) {
                 this.shoot(ms, camera);
                 this.shootTimer = ((this.small ? 800 : 1600) *
                     (1 + Math.random()));
             }

             this.shield.update(camera, ms);
             moveWrap(this, ms, camera);
         },
         shoot: function(ms, camera) {
             if ((this.dead > 0) || (ship.dead > 0) ||
                 (this.shots.length >= 8))
                 return;
             var direction = this.small ? multivec(
                 {x: ship.x - this.x, y: ship.y - this.y}).normalize() :
                             (Math.random() * Math.PI * 2);
             this.shots.push(createShot(this, direction));
         },
         award: function(npoints) { /* No score for saucers, sadly */ },
         clear: function() {
             this.dead = o_saucer_respawn * (1 + Math.random());
         },
         destroy: function() {
             if (this.shield.absorb())
                 return;
             var npieces = Math.floor(4 + 4 * Math.random());
             for (var ii = 0; ii < npieces; ++ii)
                 debris.push(createDebris(this));
             this.clear();
         }
     };

     var drawRock = function(ctx, points, size) {
         if (points && points.length > 0) {
             var index = points.length - 1;
             var point = points[index];
             ctx.moveTo(
                 Math.cos(index * 2 * Math.PI /
                     points.length) * point * size,
                 Math.sin(index * 2 * Math.PI /
                     points.length) * point * size);
             points.forEach(function(point, index) {
                 ctx.lineTo(
                     Math.cos(index * 2 * Math.PI /
                         points.length) * point * size,
                     Math.sin(index * 2 * Math.PI /
                         points.length) * point * size); });
         }
     };

     var createAsteroid = function(config) {
         var points  = [];
         var npoints = 10;
         var nsplits = 2;
         var value   = 100;
         var camera;
         var x = 0, y = 0;

         if ((typeof(config) === "object") && config) {
             if (!isNaN(config.nsplits))
                 nsplits = config.nsplits;
             if (!isNaN(config.x))
                 x = config.x;
             if (!isNaN(config.y))
                 y = config.y;
             if (config.camera)
                 camera = config.camera;
         }

         var ii;
         for (ii = 0; ii < nsplits; ++ii)
             npoints += 2, value = Math.floor(value / 20) * 10;
         for (ii = 0; ii < npoints; ++ii)
             points.push((Math.random() * 5 + 7) / 12);
         var computeSize = function(size) {
             var result = size / 20;
             for (ii = 0; ii < nsplits; ++ii)
                 result *= 2;
             return result;
         };

         if (camera) {
             var size = computeSize(Math.min(
                 camera.width, camera.height));
             if (Math.random() > 0.5) {
                 x = camera.width * (Math.random() - 0.5);
                 y = (camera.height + size) / 2;
             } else {
                 x = (camera.width + size) / 2;
                 y = camera.height * (Math.random() - 0.5);
             }
         }

         return {
             x: x, y: y, dx: 0, dy: 0, size: 0, speed: 0,
             direction: Math.random() * Math.PI * 2,
             angle: Math.random() * Math.PI * 2,
             value: value, nsplits: nsplits,
             points: points, dead: 0,

             draw: function(ctx) {
                 ctx.save();
                 ctx.translate(this.x, this.y);
                 ctx.rotate(this.angle);
                 ctx.scale(this.size/2, this.size/2);
                 ctx.beginPath();
                 drawRock(ctx, this.points, 1);
                 ctx.restore();
                 ctx.stroke();
                 drawRing(ctx, this);
             },

             resize: function(size) {
                 this.size = computeSize(size);

                 // Asteroid speed is proportional to screen size
                 // so the difficult is similar on large and small
                 // screens.  As score goes up they begin to move
                 // faster to make things more challenging.
                 this.speed = ((size * (1 + Math.sqrt(score) / 1000)) /
                     (30 * (this.size + 50)));
                 this.dx = Math.cos(this.direction) * this.speed;
                 this.dy = Math.sin(this.direction) * this.speed;
             },

             update: function(camera, ms) {
                 if (this.size === 0)
                     this.resize(Math.min(camera.width, camera.height));
                 this.angle += ms * Math.PI / (this.size * 30);
                 moveWrap(this, ms, camera);
             },

             split: function(active) {
                 var npieces = Math.floor(
                     2 + this.nsplits * 2 + 4 * Math.random());
                 for (var ii = 0; ii < npieces; ++ii)
                     debris.push(createDebris(this));

                 // Replace the asteroid with two smaller
                 // pieces, unless it's too small.
                 if (this.nsplits > 0) {
                     active.push(createAsteroid({
                         nsplits: this.nsplits - 1,
                         x: this.x, y: this.y}));
                     active.push(createAsteroid({
                         nsplits: this.nsplits - 1,
                         x: this.x, y: this.y}));
                 }
             }
         };
     };

     var screenButtons = {
         size: 0, horizontal: true, collapsed: true,
         draw: function(ctx, camera, now, last) {
             if (o_nobuttons)
                 return;
             var radius = this.size * 3 / 5;
             ctx.save();
             ctx.translate(this.size, camera.height - this.size);

             ctx.beginPath();
             if (this.collapsed) {
                 ctx.moveTo(radius, 0);
                 ctx.arc(0, 0, radius, 0, 2 * Math.PI);
                 ctx.moveTo(-radius / 2, radius / 4);
                 ctx.lineTo(radius / 2, radius / 4);
                 ctx.moveTo(-radius / 2, 0);
                 ctx.lineTo(radius / 2, 0);
                 ctx.moveTo(-radius / 2, -radius / 4);
                 ctx.lineTo(radius / 2, -radius / 4);
             } else {
                 var delx = this.horizontal ? (3 / 2 * this.size) : 0;
                 var dely = this.horizontal ? 0 : -(3 / 2 * this.size);
                 var offx = 0, offy = 0;

                 // Collapse
                 ctx.moveTo(radius + offx, offy);
                 ctx.arc(offx, offy, radius, 0, 2 * Math.PI);
                 ctx.moveTo(offx - radius / 2, offy - radius / 2);
                 ctx.lineTo(offx + radius / 2, offy + radius / 2);
                 ctx.moveTo(offx + radius / 2, offy - radius / 2);
                 ctx.lineTo(offx - radius / 2, offy + radius / 2);
                 offx += delx;
                 offy += dely;

                 // Shoot
                 ctx.moveTo(radius + offx, offy);
                 ctx.arc(offx, offy, radius, 0, 2 * Math.PI);
                 ctx.moveTo(offx + radius / 5, offy - radius / 3);
                 ctx.arc(offx, offy - radius / 3, radius / 5,
                         0, 2 * Math.PI);
                 ctx.moveTo(offx, offy + radius / 2);
                 ctx.lineTo(offx, offy);
                 offx += delx;
                 offy += dely;

                 // Left turn
                 ctx.moveTo(radius + offx, offy);
                 ctx.arc(offx, offy, radius, 0, 2 * Math.PI);
                 ctx.moveTo(offx + Math.cos(Math.PI / 3) * radius / 2,
                            offy + Math.sin(Math.PI / 3) * radius / 2);
                 ctx.arc(offx, offy, radius / 2,
                         Math.PI / 3, -Math.PI * 2 / 3, true);
                 ctx.lineTo(offx, offy - radius / 2);
                 ctx.lineTo(offx, offy - radius / 4);
                 ctx.lineTo(
                     offx + Math.cos(-Math.PI * 2 / 3) * radius / 2,
                     offy + Math.sin(-Math.PI * 2 / 3) * radius / 2);
                 offx += delx;
                 offy += dely;

                 // Thrust
                 ctx.moveTo(radius + offx, offy);
                 ctx.arc(offx, offy, radius, 0, 2 * Math.PI);
                 ctx.moveTo(offx, offy + radius / 2);
                 ctx.lineTo(offx, offy - radius / 2);
                 ctx.lineTo(offx + radius / 5, offy - radius / 3);
                 ctx.lineTo(offx - radius / 5, offy - radius / 3);
                 ctx.lineTo(offx, offy - radius / 2);
                 offx += delx;
                 offy += dely;

                 // Right turn
                 ctx.moveTo(radius + offx, offy);
                 ctx.arc(offx, offy, radius, 0, 2 * Math.PI);
                 ctx.moveTo(
                     offx + Math.cos(Math.PI * 2 / 3) * radius / 2,
                     offy + Math.sin(Math.PI * 2 / 3) * radius / 2);
                 ctx.arc(offx, offy, radius / 2,
                         Math.PI * 2 / 3, -Math.PI / 3);
                 ctx.lineTo(offx, offy - radius / 2);
                 ctx.lineTo(offx, offy - radius / 4);
                 ctx.lineTo(offx + Math.cos(-Math.PI / 3) * radius / 2,
                            offy + Math.sin(-Math.PI / 3) * radius / 2);
                 offx += delx;
                 offy += dely;
             }
             ctx.stroke();
             ctx.restore();
         },
         update: function(camera, elapsed) {
             if (!size)
                 this.resize(camera);
         },
         resize: function(camera) {
             var size = Math.min(camera.width, camera.height);
             this.size = size / 10;
         },
         down: function(event, camera) {
             if (o_nobuttons)
                 return;
             var delx = this.horizontal ? (3 / 2 * this.size) : 0;
             var dely = this.horizontal ? 0 : -(3 / 2 * this.size);
             var offx = 0, offy = 0;
             var threshold = this.size * this.size * 9 / 25;
             var position = multivec({
                 x: event.clientX, y: event.clientY});
             var buttons = [];
             buttons.push({x: this.size + offx,
                           y: camera.height - this.size + offy,
                           action: function() {
                               this.collapsed = !this.collapsed; }});
             offx += delx;  offy += dely;
             buttons.push({x: this.size + offx,
                           y: camera.height - this.size + offy,
                           action: function() { ship.shoot(); }});
             offx += delx;  offy += dely;
             buttons.push({x: this.size + offx,
                           y: camera.height - this.size + offy,
                           action: function() {
                               ship.right = false; ship.left = true;
                               ship.target = null;
                           }});
             offx += delx;  offy += dely;
             buttons.push({x: this.size + offx,
                           y: camera.height - this.size + offy,
                           action: function() {
                               ship.thrust = true; }});
             offx += delx;  offy += dely;
             buttons.push({x: this.size + offx,
                           y: camera.height - this.size + offy,
                           action: function() {
                               ship.right = true; ship.left = false;
                               ship.target = null;
                           }});
             offx += delx;  offy += dely;
             var found = false;

             buttons.forEach(function(button) {
                 if (position.minus(button).quadrance() < threshold) {
                     button.action.call(this);
                     found = true;
                 }
             }, this);
             return found;
         },
         up: function(event, camera) {
             if (o_nobuttons)
                 return;
             ship.right  = false;
             ship.left   = false;
             ship.thrust = false;
         }
     };

     return {
         resize: function(camera) {
             size = Math.min(camera.width, camera.height);
             ship.resize(size);
             saucer.resize(size);
             asteroids.forEach(function(asteroid) {
                 asteroid.resize(size); });
             screenButtons.resize(camera);
         },
         drawBefore: function(ctx, camera, now, last) {
             screenButtons.draw(ctx, camera, now, last);

             ctx.lineCap = "round";
             ctx.lineWidth = size / 400;
             ctx.font = (size / 20) + "px monospace";
             ctx.fillText(score.toLocaleString(),
                          size / 18, size / 15);

             for (var ii = 0; ii < ship.lives; ++ii) {
                 ctx.save();
                 ctx.translate(size / 40 + ship.size * (ii + 1),
                               size / 15 + ship.size);
                 ctx.rotate(-Math.PI / 2);
                 ctx.scale(ship.size / 2, ship.size / 2);
                 ship.drawShape(ctx);
                 ctx.restore();
             }
             ctx.stroke();
         },
         draw: function(ctx, camera, now, last) {
             ctx.lineCap = "round";
             ctx.lineWidth = size / 400;

             ship.draw(ctx);
             saucer.draw(ctx);
             asteroids.forEach(function(asteroid) {
                 asteroid.draw(ctx); });

             ctx.beginPath();
             debris.forEach(function(piece) {
                 piece.draw(ctx); });
             ctx.stroke();

             if (reset > 0) {
                 ctx.font = (size / 10) + "px monospace";
                 var text = "GAME OVER";
                 var metrics = ctx.measureText(text);
                 ctx.fillText(text, -metrics.width / 2, -size/20);
             }
         },

         update: function(camera, ms) {
             if (ms > 100)
                 ms = 100;

             var activeDebris = [];
             debris.forEach(function(piece) {
                 if (piece.update(camera, ms))
                     activeDebris.push(piece);
             });
             debris = activeDebris;

             var activeAsteroids = [];
             asteroids.forEach(function(asteroid) {
                 var checkAsteroidShots = function(vessel) {
                     var activeShots = [];
                     vessel.shots.forEach(function(shot) {
                         if (!shot) return;
                         if (checkCollide(shot, asteroid, ms)) {
                             asteroid.dead = 1;
                             asteroid.split(activeAsteroids);
                             vessel.award(asteroid.value);
                         } else activeShots.push(shot);
                     });
                     vessel.shots = activeShots;
                 };
                 checkAsteroidShots(ship);
                 checkAsteroidShots(saucer);

                 if ((asteroid.dead <= 0) && (ship.dead <= 0) &&
                     checkCollide(ship, asteroid, ms)) {
                     ship.destroy();
                     asteroid.split(activeAsteroids);
                     asteroid.dead = 1;
                 }

                 if ((asteroid.dead <= 0) && (saucer.dead <= 0) &&
                     checkCollide(saucer, asteroid, ms)) {
                     saucer.destroy();
                     asteroid.split(activeAsteroids);
                     asteroid.dead = 1;
                 }

                 if (asteroid.dead <= 0) {
                     asteroid.update(camera, ms);
                     activeAsteroids.push(asteroid);
                 }
             });
             asteroids = activeAsteroids;

             if (reset > 0) {
                 reset -= ms;
                 if (reset <= 0) {
                     reset = 0;
                     score = 0;
                     debris = [];
                     asteroids = [];
                     nextwave = 1000;
                     ship.lives = 4;
                     saucer.clear();
                 }
             } else if (nextwave > 0) {
                 nextwave -= ms;
                 if (nextwave <= 0) {
                     var count = (isNaN(o_nasteroids) ? 8 :
                                  o_nasteroids) + Math.floor(
                                      Math.sqrt(score) / 100);
                     for (var ii = 0; ii < count; ++ii)
                         asteroids.push(createAsteroid({
                             camera: camera}));
                 }
             } else if (asteroids.length === 0)
                 nextwave = 5000;

             var checkEnemyShots = function(vessel, enemy) {
                 if (enemy.dead > 0)
                     return;
                 var activeShots = [];
                 vessel.shots.forEach(function(shot) {
                     if (!shot) return;
                     if (checkCollide(shot, enemy, ms)) {
                         enemy.destroy();
                         vessel.award(enemy.small ? 1000 : 200);
                     } else activeShots.push(shot);
                 }, activeShots);
                 vessel.shots = activeShots;
             };
             checkEnemyShots(ship, saucer);
             checkEnemyShots(saucer, ship);
             if ((ship.dead <= 0) && (saucer.dead <= 0) &&
                 checkCollide(ship, saucer, ms)) {
                 ship.destroy();
                 saucer.destroy();
             }

             ship.update(camera, ms);
             saucer.update(camera, ms);
             screenButtons.update(camera, ms);
         },

         keydown: function(event, camera) {
             if (event.keyCode === 37 || event.key === 'a') {
                 ship.left = true; ship.right = false;
                 ship.target = null;
	     } else if (event.keyCode === 38 || event.key === 'w') {
                 ship.thrust = true; ship.target = null;
	     } else if (event.keyCode === 39 || event.key === 'd') {
                 ship.right = true; ship.left = false;
                 ship.target = null;
	     } else if (event.keyCode === 40 || event.key === 's') {
                 ship.warp = true; ship.target = null;
             } else if (event.key === ' ' || event.key === "Enter") {
                 if (o_repeat || !event.repeat)
                     ship.shoot();
             }
         },

         keyup: function(event, camera) {
             if (event.keyCode === 37 || event.key === 'a')
                 ship.left = false;
	     else if (event.keyCode === 38 || event.key === 'w')
                 ship.thrust = false;
	     else if (event.keyCode === 39 || event.key === 'd')
                 ship.right = false;
         },

         swipe: function(event, camera) {
             var path = {x: event.end.x - event.start.x,
                         y: event.end.y - event.start.y};
             if (path.x * path.x + path.y + path.y > size * size / 9)
                 ship.warp = true;
         },
         down: function(event, camera) {
             if (screenButtons.down(event, camera))
                 return;
             ship.aim(event.point, camera);
             ship.down = {duration: 0};
         },
         up: function(event, camera) {
             if (screenButtons.up(event, camera))
                 return;
             ship.down = null;
             ship.thrust = false;
         },
         isActive: true
     };
 }); //]]></script>
