<!DOCTYPE html>
<meta charset="utf-8" />
<!-- :TODO: swipe for hyperspace -- SWIPERSPACE! -->
<!-- :TODO: make screen buttons reset game over condition -->
<!-- asteroids.html
     Copyright (C) 2020-2024 by Jeff Gold.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License as
     published by the Free Software Foundation, either version 3 of the
     License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     <http://www.gnu.org/licenses/>.

   ---------------------------------------------------------------------

     This file is an independent clone of Asteroids, a space-themed
     arcade game originally designed by Lyle Rains, Ed Logg and
     Dominic Walsh and released by Atari in 1979.
     Source: https://en.wikipedia.org/wiki/Asteroids_(video_game)

     The player controls a space ship in an asteroid field which is
     periodically traversed by flying saucers.

     The original game awarded 20 points for destroying each large
     asteroid, 50 for each medium sized and 100 for each small one.
     Destroying large flying saucers was worth 200 points and small
     ones were worth 1,000.  Each time the player gained another
     10,000 points an extra life was awarded.

     This game extends Asteroids with some optional features.

     * Shields: when active the player ship and enemy saucers have
     a shield that can absorb one hit.  These shields recharge after
     some time.

     * Messy: when active, debris doesn't disappear until it reaches
     the edge of the screen.  This can make things more challenging
     due to extra visual noise.  It also looks interesting.

     * Buttons: the lower left of the screen has an expandable
     button tray which can be used to control the ship without use
     of a keyboard.  This is intended to make mobile use possible.

     * Repeat: enables keyboard repeat, which makes it possible to
     hold down the fire key to create a continuous vortex.  This
     may make the game trivially easy to play but might be enteraining.
-->
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<!-- This is an embedded SVG icon using the same pattern used to
     draw the player ship.  No external file is loaded. -->
<link rel="shortcut icon"
      href="data:image/svg+xml,%3Csvg
           xmlns='http://www.w3.org/2000/svg'
           width='128' height='128'%3E%3Cpolygon
           points='64,8 107,120 64,98 21,120'
           stroke-width='12' stroke='%23111' fill='none'
           /%3E%3Cpolygon points='64,8 107,120 64,98 21,120'
           stroke-width='4' stroke='%23eee' fill='none'
           /%3E%3C/svg%3E" />
<title>Asteroids</title>
<style>
 html, body
 { position: absolute; padding: 0; margin: 0; overflow: hidden; }
 canvas { background: #111; color: #eee; }
</style>

<!-- See ./credits.html for details on these sounds -->
<audio id="shoot-beam">
    <source src="sounds/shoot-beam.ogg" type="audio/ogg" />
</audio>
<audio id="smash-ship">
    <source src="sounds/smash-ship.ogg" type="audio/ogg" />
</audio>
<audio id="smash-rock">
    <source src="sounds/smash-rock.ogg" type="audio/ogg" />
</audio>
<audio id="thruster" loop="true">
    <source src="sounds/thruster.ogg" type="audio/ogg" />
</audio>
<audio id="saucer-siren" loop="true">
    <source src="sounds/saucer-siren.ogg" type="audio/ogg" />
</audio>

<script type="module">//<![CDATA[
 import Camera from "./ripple/camera.mjs";
 const soundThruster = document.getElementById("thruster");
 const soundShootBeam = document.getElementById("shoot-beam");
 const soundSmashShip = document.getElementById("smash-ship");
 const soundSmashRock = document.getElementById("smash-rock");
 const soundSaucerSiren = document.getElementById("saucer-siren");

 function startSound(sound) {
     if (!sound.paused)
         sound.currentTime = 0;
     sound.play();
 }

 /**
  * Convert query parameters from URL to a dictionary */
 const params = window.location.search.substr(1).split('&').reduce(
     (acc, current) => {
         const parts = current.split('=');
         return ((parts.length === 1) ? { ...acc, [current]: true } :
             (parts.length === 2) ? { ...acc, [parts[0]]: parts[1]} :
             acc); }, {});

 /**
  * Convert a query parameter to an integer. */
 function paramInteger(params, name, config) {
     let result = params[name];
     if (!isNaN(result)) {
         result = parseInt(result, 10);
         if (config && !isNaN(config.min))
             result = Math.max(config.min, result);
         if (config && !isNaN(config.max))
             result = Math.min(config.max, result);
     } else result = (config ? config.default : undefined);
     return result;
 }

 /**
  * Convert a query parameter to a boolean. */
 function paramBoolean(params, name) {
     const result = params[name];
     return (typeof(result) === "boolean") ? result :
            !isNaN(result) ? parseInt(result, 10) :
            (typeof(result) === "string") ?
            ["true", "t", "yes", "y", "on", "enable",
             "enabled"].includes(result.toLowerCase()) : result;
 }

 const o_newlife = paramInteger(params, "newlife", {
     min: 500, default: 10000}); // Score needed for each new life
 const o_startwave = paramInteger(params, "startwave", {
     min: 0, default: 4}); // Number of large asteroids at wave start
 const o_maxwave = paramInteger(params, "maxwave", {
     min: 0, default: 11}); // Maximum wave size
 const o_saucer_respawn = paramInteger(params, "saucer-spawn", {
     min: 1000, default: 8000});
 const o_large_score = paramInteger(params, "small-score", {
     min: 0, default: 10000}); // Always large saucers until this score
 const o_small_score = paramInteger(params, "small-score", {
     min: 0, default: 40000}); // Always small saucers after this score
 const o_messy   = paramBoolean(params, "messy");
 const o_rings   = paramBoolean(params, "rings");
 const o_shields = paramBoolean(params, "shields");
 const o_repeat  = paramBoolean(params, "repeat");
 const o_nobuttons = paramBoolean(params, "nobuttons");
 const o_vbuttons = paramBoolean(params, "vbuttons");
 const o_cheats = paramBoolean(params, "cheats");

 /**
  * Return true iff the given value is close enough to zero */
 function zeroish(value) {
     const epsilon = 0.00000000001;
     return !isNaN(value) && (value <= epsilon) && (value >= -epsilon);
 }

 /**
  * Returns the real roots of ax^2 + bx + c = 0.  Note that the
  * constant term should come first, followed by the linear term
  * and finally the quadratic term.  This returns an array which
  * may have zero, one or two values. */
 function quadraticRealRoots(c, b, a) {
     const result = [];
     if (isNaN(a) || zeroish(a)) {
         result.push(-c / b);
     } else {
         const discriminant = b * b - 4 * a * c;

         if (zeroish(discriminant)) {
             result.push(-b / (2 * a));
         } else if (discriminant >= 0) {
             const sqrtdisc = Math.sqrt(discriminant);
             result.push((-b + sqrtdisc) / (2 * a));
             result.push((-b - sqrtdisc) / (2 * a));
         }
     }
     return result;
 }

 /**
  * Renders a red ring intended to show collision boundaries */
 function drawRing(ctx, thing) {
     if (!isNaN(thing.dead) && thing.dead > 0)
         return;
     ctx.moveTo(thing.x + thing.radius, thing.y);
     ctx.arc(thing.x, thing.y, thing.radius, 0, Math.PI * 2);
 }

 /**
  * Connect a ring of points with a closed loop of lines. */
 function drawPointLoop(ctx, points) {
     const last = points[points.length - 1];
     ctx.moveTo(last.x, last.y);
     points.forEach(point => ctx.lineTo(point.x, point.y));
 }

 /**
  * Renders a round shape with spars of lengths given by an array.
  * With random numbers this ends up looking like a rock. */
 function drawSpars(ctx, spars) {
     const factor = 2 * Math.PI / spars.length;
     drawPointLoop(ctx, spars.map((spar, index) => ({
         x: Math.cos(index * factor) * spar,
         y: Math.sin(index * factor) * spar })));
 }

 /**
  * Base clases for player ship, saucers, asteroids and debris. */
 class Movable {
     constructor(config) {
         this.sizeBase = (config && !isNaN(config.sizeBase)) ?
                         config.sizeBase : 0;
         this.sizeFactor = (config && !isNaN(config.sizeFactor)) ?
                           config.sizeFactor : 0.1;
         this.ageless = config ? (!!config.ageless) : true;
         this.dead = (config && !isNaN(config.dead)) ?
                     config.dead : 0;
         this.duration = (config && !isNaN(config.duration)) ?
                         config.duration : 0;
         this.x = (config && !isNaN(config.x)) ? config.x : undefined;
         this.y = (config && !isNaN(config.y)) ? config.y : undefined;
         this.direction = (config && !isNaN(config.direction)) ?
                          config.direction : undefined;
         this.speed = (config && !isNaN(config.speed)) ?
                      config.speed : 0;
         this.angle = (config && !isNaN(config.angle)) ?
                      config.angle : undefined;

         this.pointLoop = undefined;
         this.__refresh();
     }

     resize(camera) {
         this.sizeBase = Math.min(camera.width, camera.height);
         this.__refresh();
     }

     __refresh() {
         const factor = this.speed * this.sizeBase;
         this.dx = Math.cos(this.direction) * factor;
         this.dy = Math.sin(this.direction) * factor;
         this.radius = this.sizeFactor * this.sizeBase;
     }

     __pointLoopSpars(spars) {
         const factor = 2 * Math.PI / spars.length;
         this.pointLoop = spars.map((spar, index) => ({
             x: Math.cos(index * factor) * spar,
             y: Math.sin(index * factor) * spar }));
     }

     checkCollide(other, elapsed) {
         const radius = this.radius + other.radius;
         const dx     = this.x - other.x;
         const dy     = this.y - other.y;
         const ddx    = this.dx - other.dx;
         const ddy    = this.dy - other.dy;
         return (dx * dx + dy * dy <= radius * radius) ||
                quadraticRealRoots(
                    dx * dx + dy * dy - radius * radius,
                    2 * (dx * ddx + dy * ddy),
                    ddx * ddx + ddy * ddy).some(
                        time => (time >= 0) && (time < elapsed));
     }

     #endure(elapsed) {
         this.duration = (elapsed > this.duration) ? 0 :
                         (this.duration - elapsed);
         return (this.duration > 0) || this.ageless;
     }

     /**
      * Move this object according to its velocity, wrapping it around
      * the screen if necessary.  Returns true iff duration remains
      * positive after deducting the elapsed time. */
     moveWrap(camera, elapsed) {
         this.x += this.dx * elapsed;
         if (this.x > this.radius + camera.width/2)
             this.x = -(this.radius + camera.width/2);
         else if (this.x < -(this.radius + camera.width/2))
             this.x = this.radius + camera.width/2;

         this.y += this.dy * elapsed;
         if (this.y > this.radius + camera.height/2)
             this.y = -(this.radius + camera.height/2);
         else if (this.y < -(this.radius + camera.height/2))
             this.y = this.radius + camera.height/2;

         return this.#endure(elapsed);
     }

     /**
      * Move this object according to its velocity.  Returns true iff
      * duration remains positive after deducting the elapsed time
      * and the object remains within the bounds of the camera. */
     moveDrop(camera, elapsed) {
         this.x += this.dx * elapsed;
         this.y += this.dy * elapsed;
         return this.#endure(elapsed) &&
                (this.x < this.radius + camera.width/2) &&
                (this.x > -(this.radius + camera.width/2)) &&
                (this.y < this.radius + camera.height/2) &&
                (this.y > -(this.radius + camera.height/2));
     }

     draw(ctx) {
         ctx.save();
         ctx.translate(this.x, this.y);
         if (!isNaN(this.angle))
             ctx.rotate(this.angle);
         ctx.scale(this.radius, this.radius);
         drawPointLoop(ctx, this.pointLoop);
         ctx.restore();
     }
 }

 class Debris extends Movable {
     constructor(source, ageless) {
         super(source);
         this.sizeFactor = 0.01;
         this.direction = Math.random() * Math.PI * 2;
         this.speed = (Math.random() + 1) / 2500;
         this.duration = 900;
         this.ageless = !!ageless;

         this.__pointLoopSpars(
             new Array(Math.floor(3 + 3 * Math.random())).fill().map(
                 ignore => (Math.random() + 1) / 2));
         this.__refresh();
     }

     static __present = [];

     static create(source, count) {
         new Array(count).fill().forEach(ignore =>
             Debris.__present.push(new Debris(source, o_messy)));
     }

     static resize(camera) {
         Debris.__present.forEach(piece => piece.resize(camera));
     }

     static update(camera, elapsed) {
         Debris.__present = Debris.__present.filter(
             piece => piece.moveDrop(camera, elapsed));
     }

     static draw(ctx, camera) {
         Debris.__present.forEach(piece => piece.draw(ctx));
     }

     static reset() { Debris.__present = []; }
 }

 /**
  * A asteroid serves as a hazard that the player can destroy. */
 class Asteroid extends Movable {
     constructor(score, source) {
         super(source);
         const boost = Math.sqrt(score) / 1000;

         this.nsplits = source ? (source.nsplits - 1) : 2;
         this.sizeFactor = (1 << this.nsplits) / 33;
         this.direction = Math.random() * Math.PI * 2;
         this.angle = this.direction;
         this.speed = ((1 + boost) / (2000 * (1 << this.nsplits)));
         this.score = new Array(this.nsplits).fill().reduce(
             score => Math.floor(score/20) * 10, 100);

         this.__pointLoopSpars(
             new Array(10 + 2 * this.nsplits).fill().map(
                 ignore => (Math.random() * 5 + 7) / 12));
         this.__refresh();
     }

     update(camera, elapsed) {
         if (!this.sizeBase) {
             this.resize(camera);

             const place = Math.random() * 2;
             if (place >= 1) {
                 this.x = (place - 1.5) * camera.width;
                 this.y = this.radius + camera.height / 2;
             } else {
                 this.x = this.radius + camera.width / 2;
                 this.y = (place - 0.5) * camera.height;
             }
         }
         this.angle += elapsed * Math.PI / (1 << this.nsplits) / 1000;
         return this.moveWrap(camera, elapsed);
     }

     impact(fragments, score) {
         if (fragments && (this.nsplits > 0)) {
             fragments.push(new Asteroid(score, this));
             fragments.push(new Asteroid(score, this));
         }
         Debris.create(this, Math.floor(
             1 + this.nsplits * 2 + 4 * Math.random()));
         this.dead = 1;
         startSound(soundSmashRock);
     }
 }

 class Shield {
     constructor() { this.reset() }

     reset() {
         this.ready = o_shields;
         this.recharge = 0;
     }

     update(camera, elapsed) {
         if (this.recharge > 0)
             if (elapsed > this.recharge) {
                 this.recharge = 0;
                 this.ready = true;
             } else this.recharge -= elapsed;
     }

     impact() {
         if (this.ready) {
             this.ready = false;
             this.recharge = 5000;
             return true;
         }
     }

     draw(ctx, vessel) {
         if (!this.ready || (vessel.dead > 0))
             return;
         const dir = Math.random() * 2 * Math.PI;
         const x = vessel.x + Math.cos(dir) * vessel.radius / 9;
         const y = vessel.y + Math.sin(dir) * vessel.radius / 9;
         const factor = vessel.radius * 12 / 10;
         ctx.save();
         ctx.beginPath();
         ctx.strokeStyle = "#66c";
         ctx.moveTo(x + factor, y);
         ctx.arc(x, y, factor, 0, Math.PI * 2);
         ctx.stroke();
         ctx.restore();
     }
 }

 class Shot extends Movable {
     constructor(vessel, direction) {
         super(vessel);
         this.sizeFactor = 1/100;
         this.duration = 350;
         this.ageless = false;

         const vector = (isNaN(this.direction) || (this.speed == 0)) ?
                        {x: 0, y: 0} :
                        {x: Math.cos(this.direction) * this.speed,
                         y: Math.sin(this.direction) * this.speed};
         if (!isNaN(direction)) {
             vector.x += Math.cos(direction) / 650;
             vector.y += Math.sin(direction) / 650;
         } else {
             vector.x += direction.x / 650;
             vector.y += direction.y / 650;
         }
         this.speed = Math.hypot(vector.x, vector.y);
         this.direction = Math.atan2(vector.y, vector.x);
         this.__refresh();
     }

     draw(ctx) {
         ctx.moveTo(this.x + this.radius, this.y);
         ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
     }
 }

 function drawWedgeShip(ctx) {
     drawPointLoop(ctx, [{x: 1, y: 0}, {x: -1, y: 2/3},
                         {x: -2/3, y: 0}, {x: -1, y: -2/3}]);
 }

 /**
  * Represents a ship controlled by the player.
  * Able to turn, shoot, thrust and warp. */
 class WedgeShip extends Movable {
     constructor(lives) {
         super();
         this.shield = new Shield();
         this.sizeFactor = 3 / 100;
         this.lives = lives;
         this.score = 0;
         this.reset();
         this.__refresh();
     }

     reset() {
         this.left = this.right = this.thrust = this.warp = false;
         this.holding = false;
         this.target = undefined;
         this.held = 0;
         this.warpCooldown = 0;

         this.thrust_elapsed = 0;
         this.shots = [];

         this.direction = Math.PI/2;
         this.x = this.y = 0;
         this.dx = this.dy = 0;
         this.shield.reset();
         soundThruster.pause();
         soundThruster.currentTime = 0;
     }

     draw(ctx) {
         ctx.beginPath();
         this.shots.forEach(shot => shot.draw(ctx));
         ctx.stroke();

         if (this.dead <= 0) {
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(this.direction);
             ctx.scale(this.radius, this.radius);
             ctx.beginPath();
             drawWedgeShip(ctx);
             ctx.restore();

             if (this.thrust_elapsed) {
                 ctx.save();
                 ctx.translate(this.x, this.y);
                 ctx.rotate(this.direction);
                 ctx.scale(this.radius, this.radius);
                 drawPointLoop(ctx, [
                     {x: -1, y: 1/3},
                     {x: -3/ 2, y: 0},
                     {x: -1, y: -1/3}].map(point => ({
                         x: point.x + (Math.random() - 1/2) * 0.33,
                         y: point.y + (Math.random() - 1/2) * 0.33
                 })));
                 ctx.restore();
             }
             ctx.stroke();
             this.shield.draw(ctx, this);
         }
     }

     update(camera, elapsed, asteroids) {
         // Process shots and remove any that return falsy
         this.shots = this.shots.filter(shot =>
             shot.moveWrap(camera, elapsed));

         // A dead ship eventually respawns, but can't interact
         // with anything until then.
         if (this.dead > 0) {
             if (this.lives === 0) {
                 // Game is over so don't respawn
             } else if (elapsed >= this.dead) {
                 this.dead = 0;

                 // If an asteroid will immediately smash the player,
                 // wait a while before respawning
                 if (asteroids.some(asteroid =>
                     asteroid.checkCollide(this, 1500)))
                     this.dead = 500;
                 if (this.dead === 0)
                     this.lives -= 1;
             } else this.dead -= elapsed;
         }
         if (this.dead > 0)
             return false;

         // Respond to user input from keyboard, mouse or touch
         if (this.left) {
             this.direction += elapsed / 200;
             this.target = undefined;
         } else if (this.right) {
             this.direction -= elapsed / 200;
             this.target = undefined;
         } else if (!isNaN(this.target)) {
             let difference = this.target - this.direction;
             if (difference > Math.PI)
                 difference -= 2 * Math.PI;
             else if (difference < -Math.PI)
                 difference += 2 * Math.PI;

             if (Math.abs(difference) < elapsed / 200)
                 this.direction = this.target;
             else if (difference < 0)
                 this.direction -= elapsed / 200;
             else this.direction += elapsed / 200;
         }

         this.held = this.holding ? (this.held + elapsed) : 0;
         this.thrust_elapsed =
             (this.thrust || (this.held > 300 + elapsed)) ? elapsed :
             (this.held > 300) ? (this.held - 300) : 0;

         if (this.thrust_elapsed) {
             this.dx += (Math.cos(this.direction) *
                 this.thrust_elapsed * this.radius / 20000);
             this.dy += (Math.sin(this.direction) *
                 this.thrust_elapsed * this.radius / 20000);

             if (soundThruster.paused)
                 soundThruster.play();
         } else {
             soundThruster.pause();
             soundThruster.currentTime = 0;
         }

         if (this.warpCooldown > 0) {
             this.warpCooldown = Math.max(
                 0, this.warpCooldown - elapsed);
             this.warp = false;
         }

         if (this.warp) {
             // Attempt to move the ship to a "safe" location
             let candidate = new Movable(this);

             for (let ii = 0; ii < 100; ++ii) {
                 candidate.x = ((Math.random() - 0.5) *
                     camera.width * 4 / 5);
                 candidate.y = ((Math.random() - 0.5) *
                     camera.height * 4 / 5);
                 if (!asteroids.some(asteroid =>
                     asteroid.checkCollide(candidate, 1000)))
                     break;
             }

             this.dx = this.dy = 0;
             this.x = candidate.x;
             this.y = candidate.y;
             this.warp = false;
             this.warpCooldown = 2000;
         }

         this.shield.update(camera, elapsed);
         return this.moveWrap(camera, elapsed);
     }

     shoot() {
         if ((this.dead > 0) || (this.shots.length >= 9))
             return;
         this.shots.push(new Shot(this, this.direction));
         startSound(soundShootBeam);
     }

     #desiredDirection(target) {
         let result = undefined;
         const delta = { x: target.x - this.x,
                         y: target.y - this.y };
         const quadrance = delta.x * delta.x + delta.y * delta.y;

         if (quadrance > this.radius * this.radius) {
             const length = Math.sqrt(quadrance);
             delta.x /= length;
             delta.y /= length;
             result = (((delta.y > 0) ? 1 : -1) *
                 Math.acos(delta.x));
         }
         return result;
     }

     aim(point, camera) {
         // Turn the ship toward the specified target.
         this.target = this.#desiredDirection({
             x: point.x - camera.width / 2,
             y: camera.height / 2 - point.y });
     }

     impact() {
         if (this.shield.impact())
             return false;
         Debris.create(this, Math.floor(4 + 4 * Math.random()));
         this.dead = 3000;
         this.reset();
         startSound(soundSmashShip);
         return true;
     }
 }
 const playerShip = new WedgeShip(3);

 /**
  * A flying saucer that shoots at the player ship.  Only one of these
  * can exist at a time and it can be large or small.  The large ship
  * fires in a random direction but the small ship aims at the player
  * ship. */
 class Saucer extends Movable {
     constructor() {
         super();
         this.sizeFactor = undefined;
         this.dead = o_saucer_respawn * 2;
         this.shield = new Shield();
         this.small = false;
         this.score = 0;
         this.reset();
     }

     reset() {
         this.dead = o_saucer_respawn * (1 + Math.random());
         this.shield.reset();
         this.shots = [];
     }

     draw(ctx) {
         ctx.beginPath();
         this.shots.forEach(shot => shot.draw(ctx));
         ctx.stroke();

         if (this.dead <= 0) {
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.scale(this.radius, this.radius);
             ctx.beginPath();

             // Saucer dome
             ctx.moveTo(2/3, 0);
             ctx.arc(0, 0, 2/3, 0, Math.PI, 0);
             ctx.lineTo(2/3, 0);

             // Saucer body
             ctx.lineTo(1, -1/3);
             ctx.lineTo(2/3, -2/3);
             ctx.lineTo(-2/3, -2/3);
             ctx.lineTo(-1, -1/3);
             ctx.lineTo(-2/3, 0);

             ctx.restore();
             ctx.stroke();
             this.shield.draw(ctx, this);
         }
     }

     update(camera, elapsed, gameover, score, enemy) {
         this.shots = this.shots.filter(
             shot => shot.moveWrap(camera, elapsed));

         // A dead saucer eventually respawns, but can't interact
         // with anything or shoot until then.
         if (this.dead > 0) {
             if (gameover && (elapsed >= this.dead)) {
                 this.reset();
             } else if (elapsed >= this.dead) {
                 this.dead = 0;

                 // Small saucers are more challenging because
                 // they shoot more quickly and aim at the player.
                 // Large saucers shoot in random directions.
                 // At low scores most saucers are large but
                 // eventually only small saucers can spawn.
                 this.small = (o_large_score > score) ? false :
                              (Math.random() * o_small_score < score);
                 this.score = this.small ? 1000 : 200;
                 this.sizeFactor = this.small ? 1/50 : 1/25;
                 this.__refresh();

                 this.x = this.radius + camera.width / 2;
                 this.y = this.radius + camera.height / 2;
                 this.dx = (((Math.random() * 2 > 1) ? 1 : -1) *
                     this.radius / (this.small ? 400 : 800));
                 this.direction = (this.dx > 0) ? 0 : Math.PI;
                 this.dy = 0;
                 this.turnTimer = 1000;
                 this.shootTimer = 2000;
                 startSound(soundSaucerSiren);
             } else this.dead -= elapsed;
         }
         if (this.dead > 0)
             return;

         if (this.turnTimer <= elapsed) {
             // Attempt to bias saucer toward the middle of the
             // screen where it is more visible and threatening
             const which = (((this.y < 0) ? -1 : 1) *
                 (Math.random() > 0.125) ? -1 : 1);
             this.dy = Math.abs(this.dx) * (Math.random() + 1) * which;
             this.turnTimer = 500 + 2500 * Math.random();;
         } else this.turnTimer -= elapsed;

         if (this.shootTimer <= elapsed) {
             this.shoot(enemy);
             this.shootTimer = ((this.small ? 800 : 1600) *
                 (1 + Math.random()));
         } else this.shootTimer -= elapsed;

         this.shield.update(camera, elapsed);
         this.moveWrap(camera, elapsed);
     }

     shoot(enemy) {
         if (!enemy || (enemy.dead > 0) || (this.dead > 0) ||
             (this.shots.length > 8))
             return;

         const velocity = {x: 0, y: 0};
         if (this.small) { // Small ships target their enemy
             velocity.x = enemy.x - this.x;
             velocity.y = enemy.y - this.y;
             const length = Math.hypot(velocity.x, velocity.y);
             velocity.x /= length;
             velocity.y /= length;
         } else { // Large ships fire in random directions
             const direction = Math.random() * Math.PI * 2;
             velocity.x = Math.cos(direction);
             velocity.y = Math.sin(direction);
         }
         const shot = new Shot(this, velocity);
         this.shots.push(shot);
         startSound(soundShootBeam);
     }

     impact() {
         if (this.shield.impact())
             return false;
         Debris.create(this, Math.floor(4 + 4 * Math.random()));
         this.reset();
         soundSaucerSiren.pause();
         soundSaucerSiren.currentTime = 0;
         startSound(soundSmashShip);
         return true;
     }
 }
 const saucer = new Saucer();

 const screenButtons = {
     size: 0, horizontal: !o_vbuttons, collapsed: true,

     buttons: [{ // Collapse
         draw: function(ctx) {
             ctx.moveTo(1, 0);
             ctx.arc(0, 0, 1, 0, 2 * Math.PI);
             ctx.moveTo(-1/2, -1/2);
             ctx.lineTo(1/2, 1/2);
             ctx.moveTo(1/2, -1/2);
             ctx.lineTo(-1/2, 1/2);
         }, action: function() {
             this.collapsed = !this.collapsed;
         }
     }, { // Turn Left
         draw: function(ctx) {
             ctx.moveTo(1, 0);
             ctx.arc(0, 0, 1, 0, 2 * Math.PI);
             ctx.moveTo(Math.cos(Math.PI / 3) * 1 / 2,
                        Math.sin(Math.PI / 3) * 1 / 2);
             ctx.arc(0, 0, 1 / 2, Math.PI / 3, -Math.PI * 2 / 3, true);
             ctx.lineTo(0,  -1 / 2);
             ctx.lineTo(0,  -1 / 4);
             ctx.lineTo(Math.cos(-Math.PI * 2 / 3) * 1 / 2,
                        Math.sin(-Math.PI * 2 / 3) * 1 / 2);
         }, action: function() {
             playerShip.right = false;
             playerShip.left = true;
         }
     }, { // Turn Right
         draw: function(ctx) {
             ctx.moveTo(1 + 0, 0);
             ctx.arc(0, 0, 1, 0, 2 * Math.PI);
             ctx.moveTo(Math.cos(Math.PI * 2 / 3) * 1 / 2,
                        Math.sin(Math.PI * 2 / 3) * 1 / 2);
             ctx.arc(0, 0, 1 / 2, Math.PI * 2 / 3, -Math.PI / 3);
             ctx.lineTo(0, 0 - 1 / 2);
             ctx.lineTo(0, 0 - 1 / 4);
             ctx.lineTo(Math.cos(-Math.PI / 3) * 1 / 2,
                        Math.sin(-Math.PI / 3) * 1 / 2);
         }, action: function() {
             playerShip.right = true;
             playerShip.left = false;
         }
     }, { // Warp
         draw: function(ctx) {
             ctx.moveTo(1, 0);
             ctx.arc(0, 0, 1, 0, 2 * Math.PI);
             new Array(6).fill().forEach((ingore, index) => {
                 const angle = index * Math.PI * 2 / 6;
                 ctx.moveTo(Math.cos(angle) / 3,
                            Math.sin(angle) / 3);
                 ctx.lineTo(Math.cos(angle) * 2 / 3,
                            Math.sin(angle) * 2 / 3);
             });
         }, action: function() { playerShip.warp = true; }
     }, { // Thrust
         draw: function(ctx) {
             ctx.moveTo(1, 0);
             ctx.arc(0, 0, 1, 0, 2 * Math.PI);
             ctx.moveTo(0, 1 / 2);
             ctx.lineTo(0, -1 / 2);
             ctx.lineTo(1 / 5, -1 / 3);
             ctx.lineTo(-1 / 5, -1 / 3);
             ctx.lineTo(0, -1 / 2);
         }, action: function() { playerShip.thrust = true; }
     }, { // Shoot
         draw: function(ctx) {
             // Shoot
             ctx.moveTo(1, 0);
             ctx.arc(0, 0, 1, 0, 2 * Math.PI);
             ctx.moveTo(1 / 15, -3 / 5);
             ctx.arc(0, -3 / 5, 1 / 15, 0, 2 * Math.PI);
             ctx.moveTo(0, 0);
             ctx.lineTo(0, -2 / 5);
             ctx.save();
             ctx.translate(0, 1 / 3);
             ctx.rotate(-Math.PI / 2);
             ctx.scale(1 / 4, 1 / 4);
             drawWedgeShip(ctx);
             ctx.restore();
         }, action: function() { playerShip.shoot(); }
     }],

     resize: function(camera) { this.size = camera.radius / 5; },

     draw: function(ctx, camera) {
         if (o_nobuttons)
             return;
         ctx.save();
         ctx.translate(3 * this.size / 4,
                       camera.height - 3 * this.size / 4);
         ctx.scale(this.size/2, this.size/2);
         ctx.beginPath();

         if (this.collapsed) {
             ctx.moveTo(1, 0);
             ctx.arc(0, 0, 1, 0, 2 * Math.PI);
             ctx.moveTo(-1 / 2, 1 / 4);
             ctx.lineTo(1 / 2, 1 / 4);
             ctx.moveTo(-1 / 2, 0);
             ctx.lineTo(1 / 2, 0);
             ctx.moveTo(-1 / 2, -1 / 4);
             ctx.lineTo(1 / 2, -1 / 4);
         } else {
             const shift = {
                 x: this.horizontal ? (5 / 2) : 0,
                 y: this.horizontal ? 0 : -(5 / 2) };

             this.buttons.forEach((button, index) => {
                 if (index)
                     ctx.translate(shift.x, shift.y);
                 button.draw(ctx);
             });
         }
         ctx.restore();
         ctx.stroke();
     },

     update: function(camera, elapsed) { },

     __findButton: function(event, camera) {
         let result = undefined;
         const point = camera.getPoint(event);
         const shift = {
             x: this.horizontal ? (5 * this.size / 4) : 0,
             y: this.horizontal ? 0 : -(5 * this.size / 4) };
         const current = {
             x: 3 * this.size / 4,
             y: camera.height - 3 * this.size / 4};

         this.buttons.forEach((button, index) => {
             if (result || (index && this.collapsed))
                 return;
             const quadrance = (
                 (point.x - current.x) * (point.x - current.x) +
                    (point.y - current.y) * (point.y - current.y));

             if (quadrance < this.size * this.size / 4) {
                 result = button;
             } else {
                 current.x += shift.x;
                 current.y += shift.y;
             }
         });
         return result;
     },

     down: function(event, camera) {
         if (o_nobuttons)
             return;
         const button = this.__findButton(event, camera);
         if (button) {
             button.action.call(this);
         }
         return button;
     },

     up: function(event, camera) {
         if (o_nobuttons)
             return;
         const button = this.__findButton(event, camera);
         if (button) {
             playerShip.right  = false;
             playerShip.left   = false;
             playerShip.thrust = false;
             playerShip.warp   = false;
         }
         return button;
     }
 }

 class Asteroids {
     constructor() {
         this.newgame();
     }

     // Settings for managed Camera apps
     active = true;
     autofill = true;
     usekeys = true;

     score = 0;
     gameover = 0;
     nextwave = 0;
     wavesize = undefined;
     lastUpdate = undefined;
     previousClick = undefined;
     asteroids = undefined;

     newgame() {
         this.score = 0;
         this.wavesize = Math.min(o_startwave, o_maxwave);
         this.gameover = 0;
         this.asteroids = [];
         this.nextwave = 1000;
         Debris.reset();
         saucer.reset();
         playerShip.reset();
         playerShip.dead = 0;
         playerShip.score = 0;
         playerShip.lives = 3;
     }

     award(npoints) {
         if (Math.floor((this.score + npoints) / o_newlife) >
             Math.floor(this.score / o_newlife))
             playerShip.lives += 1;
         this.score += npoints;
     }

     resize(event, camera) {
         camera.setScale(camera.radius);
         playerShip.resize(camera);
         saucer.resize(camera);
         this.asteroids.forEach(asteroid =>
             { asteroid.resize(camera); });
         Debris.resize(camera);
         //debris.forEach(piece => { piece.resize(camera); });
         screenButtons.resize(camera);
     }

     drawBefore(ctx, camera) {
         ctx.lineCap = "round";
         ctx.lineWidth = camera.radius / 300;
         ctx.font = Math.floor(camera.radius / 10) + "px monospace";
         ctx.fillText(this.score.toLocaleString(),
                      camera.radius / 18, camera.radius / 10);

         ctx.beginPath();
         new Array(playerShip.lives).fill().forEach((z, index) => {
             ctx.save();
             ctx.translate(camera.radius / 9 * (index + 1),
                           camera.radius / 4);
             ctx.rotate(-Math.PI / 2);
             ctx.scale(camera.radius * 6 / 100,
                       camera.radius * 6 / 100);
             drawWedgeShip(ctx);
             ctx.restore();
         });
         ctx.stroke();

         if (this.gameover > 0) {
             ctx.font = Math.floor(camera.radius / 5) + "px monospace";
             const message = "GAME OVER";
             const metrics = ctx.measureText(message);
             ctx.fillText(
                 message, (camera.width - metrics.width) / 2,
                 (camera.height +
                  metrics.actualBoundingBoxDescent) / 2);
         }
         screenButtons.draw(ctx, camera);
     }

     draw(ctx, camera) {
         ctx.lineCap = "round";
         ctx.lineWidth = camera.radius / 300;

         ctx.beginPath();
         this.asteroids.forEach(asteroid => asteroid.draw(ctx));
         Debris.draw(ctx);
         ctx.stroke();

         playerShip.draw(ctx);
         saucer.draw(ctx);

         if (o_rings) {
             ctx.save();
             ctx.beginPath();
             this.asteroids.forEach(
                 asteroid => drawRing(ctx, asteroid));
             drawRing(ctx, playerShip);
             drawRing(ctx, saucer);
             ctx.strokeStyle = "red";
             ctx.stroke();
             ctx.restore();
         }
     }

     update(now, camera) {
         const elapsed = Math.min(
             100, isNaN(this.lastUpdate) ? 0 : (now - this.lastUpdate));
         this.lastUpdate = now;

         Debris.update(camera, elapsed);

         const fragments = [];
         this.asteroids = this.asteroids.filter(asteroid => {
             if (asteroid.spawn)
                 asteroid.update(camera, elapsed);

             [playerShip, saucer].forEach(vessel => {
                 vessel.shots = vessel.shots.filter(shot => {
                     if ((asteroid.dead <= 0) &&
                         asteroid.checkCollide(shot, elapsed)) {
                         if (vessel === playerShip)
                             this.award(asteroid.score);
                         asteroid.impact(fragments, this.score);
                     } else return true;
                 });

                 if ((asteroid.dead <= 0) && (vessel.dead <= 0) &&
                     asteroid.checkCollide(vessel, elapsed)) {
                     vessel.impact();
                     if (vessel === playerShip)
                         this.award(asteroid.score);
                     asteroid.impact(fragments, this.score);
                 }
             });

             if (asteroid.dead <= 0)
                 asteroid.update(camera, elapsed);
             return !asteroid.dead;
         });
         this.asteroids = this.asteroids.concat(fragments);

         if (this.nextwave > 0) {
             if (this.nextwave <= elapsed) {
                 this.nextwave = 0;
                 this.asteroids = new Array(this.wavesize).fill().map(
                     ignore => new Asteroid(this.score));
                 this.wavesize = Math.min(o_maxwave, this.wavesize + 2);
             } else this.nextwave -= elapsed;
         } else if (this.asteroids.length === 0)
             this.nextwave = 5000;

         function checkEnemyShots(game, vessel, enemy) {
             if (enemy.dead > 0)
                 return;
             vessel.shots = vessel.shots.filter(shot => {
                 if (shot.checkCollide(enemy, elapsed)) {
                     if (enemy.impact() && (vessel === playerShip))
                         game.award(enemy.score);
                 } else return true;
             });
         };
         checkEnemyShots(this, playerShip, saucer);
         checkEnemyShots(this, saucer, playerShip);

         if ((playerShip.dead <= 0) && (saucer.dead <= 0) &&
             playerShip.checkCollide(saucer, elapsed)) {
             if (saucer.impact())
                 this.award(saucer.score)
             playerShip.impact();
         }
         saucer.update(camera, elapsed, this.gameover,
                       playerShip.score, playerShip);
         playerShip.update(camera, elapsed, this.asteroids);

         screenButtons.update(camera, elapsed);
         if (this.gameover > 0)
             this.gameover = Math.max(1, this.gameover - elapsed);
         else if (playerShip.dead && !playerShip.lives)
             this.gameover = 2000;
     }

     keydown(event, camera) {
         if (event.keyCode === 37 || event.key === 'a') {
             if (this.gameover === 1) {
                 this.newgame();
             } else {
                 playerShip.left = true;
                 playerShip.right = false;
             }
	 } else if (event.keyCode === 38 || event.key === 'w') {
             if (this.gameover === 1)
                 this.newgame();
             else playerShip.thrust = true;
	 } else if (event.keyCode === 39 || event.key === 'd') {
             if (this.gameover === 1) {
                 this.newgame();
             } else {
                 playerShip.right = true;
                 playerShip.left = false;
             }
	 } else if (event.keyCode === 40 || event.key === 's') {
             if (this.gameover === 1)
                 this.newgame();
             else playerShip.warp = true;
         } else if (event.key === ' ' || event.key === "Enter") {
             if (o_repeat || !event.repeat)
                 playerShip.shoot();
         } else if (o_cheats && (event.key === 'p')) {
             this.asteroids.forEach(asteroid => {
                 asteroid.dx = asteroid.dy = 0; });
             playerShip.dx = playerShip.dy = 0;
         } else if (o_cheats && (event.key === 'o')) {
             saucer.dead = 1;
         }
     }

     keyup(event, camera) {
         if (event.keyCode === 37 || event.key === 'a') {
             playerShip.left = false;
	 } else if (event.keyCode === 38 || event.key === 'w') {
             playerShip.thrust = false;
	 } else if (event.keyCode === 39 || event.key === 'd') {
             playerShip.right = false;
         }
     }

     tap(event, camera) {
         if (screenButtons.down(event, camera))
             return;
         else if (this.gameover === 1) {
             this.newgame();
             return;
         } else {
             playerShip.aim(camera.getPoint(event), camera);
             playerShip.holding = true;
         }
     }

     mousedown(event, camera) {
         this.tap(event, camera);
         const now = Date.now();
         if (!isNaN(this.previousClick) &&
             (now - this.previousClick < 300))
             playerShip.shoot();
         this.previousClick = now;
     }

     mouseup(event, camera) {
         screenButtons.up(event, camera);
         playerShip.holding = false;
     }

     mousemove(event, camera) {
         if (playerShip.holding)
             playerShip.aim(camera.getPoint(event), camera);
     }

     touchstart(event, camera) { this.tap(event, camera); }

     touchend(event, camera) {
         screenButtons.up(event, camera);
         playerShip.holding = false;
     }

     touchmove(event, camera) {
         if (playerShip.holding)
             playerShip.aim(camera.getPoint(event), camera);
     }
 };

 Camera.preload(null, (loaded) => {
     const camera = new Camera(document.body.appendChild(
         document.createElement("canvas"))).manage(new Asteroids());
 }); //]]></script>
