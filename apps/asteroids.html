<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>Asteroids</title>
<style>
 html, body
 { position: absolute; padding: 0; margin: 0; overflow: hidden; }
 canvas { background: #222; color: #eee; }
</style>
<!-- :TODO: make touch controls work -->

<script src="ripple/polyfill.js"></script>
<script src="ripple/ripple.js"></script>
<script src="ripple/fascia.js"></script>
<script src="ripple/multivec.js"></script>
<script>//<![CDATA[
 // Asteroids is a space-themed multidirectional shooter arcade game
 // designed by Lyle Rains, Ed Logg and Dominic Walsh and released
 // by Atari in 1979.
 // Source: https://en.wikipedia.org/wiki/Asteroids_(video_game)
 //
 // The player controls a space ship in an asteroid field which is
 // periodically traversed by flying saucers.
 //
 // The original game awarded 20 points for destroying each large
 // asteroid, 50 for each medium sized and 100 for each small one.
 // Destroying large flying saucers was worth 200 points and small
 // ones were worth 1,000.  Each time the player gained another
 // 10,000 points an extra life was awarded.
 //
 // This version differs from the original in many ways in that
 // play is continuous.  There is no way to reach a "game over"
 // state.  Instead, when the player ship is destroyed the score
 // is cut in half (rounded down).
 fascia.ready(function() {
     "use strict";
     var size = 1000;
     var debris = [];
     var asteroids = [];
     var respawn = 1;

     var ship = {
         x: 0, y: 0, dx: 0, dy: 0,
         size: 30, direction: -Math.PI/2,
         left: false, right: false,
         thrust: false, brake: false, target: undefined,
         shots: [], score: 0, dead: 0,
         draw: function(ctx) {
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(this.direction);
             ctx.scale(this.size/2, this.size/2);
             ctx.beginPath();
             if (this.dead === 0) {
                 ctx.moveTo(1, 0);
                 ctx.lineTo(-1, 2/3);
                 ctx.lineTo(-2/3, 0);
                 ctx.lineTo(-1, -2/3);
                 ctx.lineTo(1, 0);
                 if (this.thrust) {
                     ctx.moveTo(-1, -1/3);
                     ctx.lineTo(-1, 1/3);
                     ctx.lineTo(-3/2, 0);
                     ctx.lineTo(-1, -1/3);
                 }
                 if (this.brake) {
                     ctx.moveTo(0.7, 0.7);   ctx.lineTo(0.5, 0.5);
                     ctx.moveTo(0.7, -0.7);  ctx.lineTo(0.5, -0.5);
                     ctx.moveTo(-1, -1); ctx.lineTo(-0.8, -0.8);
                     ctx.moveTo(-1, 1);  ctx.lineTo(-0.8, 0.8);
                 }
             }
             ctx.restore();
             this.shots.forEach(function(shot) {
                 ctx.moveTo(shot.x + shot.size/2, shot.y);
                 ctx.arc(shot.x, shot.y, shot.size/2, 0, 2 * Math.PI);
             });
             ctx.stroke();
         },
         update: function(ms, camera) {
             var activeShots = [];
             this.shots.forEach(function(shot) {
                 shot.duration += ms;
                 if (shot.duration < 500) {
                     shot.x += shot.dx * ms;
                     if (shot.x - shot.size > camera.width/2)
                         shot.x = -camera.width/2 - shot.size;
                     else if (shot.x + shot.size < -camera.width/2)
                         shot.x = camera.width/2 + shot.size;
                     shot.y += shot.dy * ms;
                     if (shot.y - shot.size > camera.height/2)
                         shot.y = -camera.height/2 - shot.size;
                     else if (shot.y + shot.size < -camera.height/2)
                         shot.y = camera.height/2 + shot.size;
                     activeShots.push(shot);
                 }
             }, this);
             this.shots = activeShots;

             // A dead ship eventually respawns, but can't interact
             // with anything until then.
             if (this.dead > 0) {
                 if (ms > this.dead) {
                     ms -= this.dead;
                     this.dead = 0;
                 } else {
                     this.dead -= ms;
                     return;
                 }
             }

             // Respond to keyboard events and to touch target.
             if (this.left)
                 this.direction -= ms / 200;
             else if (this.right)
                 this.direction += ms / 200;
             else if (!isNaN(this.target)) {
                 var difference = this.target - this.direction;
                 if (difference > Math.PI) {
                     this.target -= 2 * Math.PI;
                     difference = this.target - this.direction;
                 } else if (difference < -Math.PI) {
                     this.target += 2 * Math.PI;
                     difference = this.target - this.direction;
                 }

                 if (Math.abs(difference) < ms / 200) {
                     this.direction = this.target;
                     this.target = undefined;
                 } else if (difference > 0) {
                     this.direction += ms / 200;
                 } else this.direction -= ms / 200;
             }

             if (this.thrust) {
                 this.dx += Math.cos(this.direction) * ms / 1500;
                 this.dy += Math.sin(this.direction) * ms / 1500;
             } else if (this.brake) {
                 this.dx *= 0.98;
                 this.dy *= 0.98;
             }

             // Movement with wrap around
             this.x += this.dx * ms;
             if (this.x - this.size > camera.width/2)
                 this.x = -camera.width/2 - this.size;
             else if (this.x + this.size < -camera.width/2)
                 this.x = camera.width /2 + this.size;
             this.y += this.dy * ms;
             if (this.y - this.size > camera.height/2)
                 this.y = -camera.height/2 - this.size;
             else if (this.y + this.size < -camera.height/2)
                 this.y = camera.height/2 + this.size;
         },
         shoot: function() {
             if ((this.dead > 0) || (this.shots.length >= 8))
                 return;
             this.shots.push({
                 x: this.x, y: this.y, duration: 0,
                 dx: Math.cos(this.direction) + this.dx,
                 dy: Math.sin(this.direction) + this.dy,
                 size: this.size * 3 / 10
             });
         },
         aim: function(point, camera) {
             // This causes the ship to turn to face a specified point.
             var v = { x: (point.x - camera.width / 2) - this.x,
                       y: (point.y - camera.height / 2) - this.y };
             var len = v.x * v.x + v.y * v.y;
             if (len > this.size * this.size / 4) {
                 len = Math.sqrt(len);
                 v.x /= len;
                 v.y /= len;
                 this.target = Math.acos(v.x);
                 if (v.y < 0)
                     this.target = -this.target;
             } else this.shoot();
         },
         destroy: function() {
             var npieces = Math.floor(4 + 4 * Math.random());
             for (var ii = 0; ii < npieces; ++ii)
                 createDebris(this);
             this.x  = this.y  = 0;
             this.dx = this.dy = 0;
             this.dead = 3000;
         }
     };

     var saucer = {
         x: 0, y: 0, dx: 0, dy: 0,
         size: 30, direction: 0,
         shots: [], dead: 10000, score: 0, small: false,
         turnTimer: 0, shootTimer: 0,
         draw: function(ctx) {
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(this.direction);
             ctx.scale(this.size/2, this.size/2);
             ctx.beginPath();
             if (this.dead === 0) {
                 // This is the dome
                 ctx.moveTo(1, 0);
                 ctx.arc(0, 0, 1, 0, Math.PI, 1);
                 ctx.lineTo(1, 0);

                 // This is the saucer body
                 ctx.lineTo(3/2, 1/2);
                 ctx.lineTo(1, 1);
                 ctx.lineTo(-1, 1);
                 ctx.lineTo(-3/2, 1/2);
                 ctx.lineTo(-1, 0);
             }
             ctx.restore();
             this.shots.forEach(function(shot) {
                 ctx.moveTo(shot.x + shot.size/2, shot.y);
                 ctx.arc(shot.x, shot.y, shot.size/2, 0, Math.PI * 2);
             });
             ctx.stroke();
         },
         update: function(ms, camera) {
             var activeShots = [];
             this.shots.forEach(function(shot) {
                 shot.duration += ms;
                 if (shot.duration < 500) {
                     shot.x += shot.dx * ms;
                     if (shot.x - shot.size > camera.width/2)
                         shot.x = -camera.width/2 - shot.size;
                     else if (shot.x + shot.size < -camera.width/2)
                         shot.x = camera.width/2 + shot.size;
                     shot.y += shot.dy * ms;
                     if (shot.y - shot.size > camera.height/2)
                         shot.y = -camera.height/2 - shot.size;
                     else if (shot.y + shot.size < -camera.height/2)
                         shot.y = camera.height/2 + shot.size;
                     activeShots.push(shot);
                 }
             }, this);
             this.shots = activeShots;

             // A dead ship eventually respawns, but can't interact
             // with anything until then.
             if (this.dead > 0) {
                 if (ms > this.dead) {
                     ms -= this.dead;
                     this.dead = 0;
                     this.x = size;
                     this.y = size;
                     this.turn = 2000;
                 } else {
                     this.dead -= ms;
                     return;
                 }
             }
             if (this.turnTimer > 0)
                 this.turnTimer -= ms;
             if (this.turnTimer <= 0) {
                 var direction = Math.random() * Math.PI * 2;
                 this.dx = Math.cos(direction) / 10;
                 this.dy = Math.sin(direction) / 10;
                 this.turnTimer = 2000 + 2000 * Math.random();
             }
             if (this.shootTimer > 0)
                 this.shootTimer -= ms;
             if (this.shootTimer <= 0) {
                 this.shoot(ms, camera);
                 this.shootTimer = 1000 + 1000 * Math.random();
             }

             // Movement with wrap around
             this.x += this.dx * ms;
             if (this.x - this.size > camera.width/2)
                 this.x = -camera.width/2 - this.size;
             else if (this.x + this.size < -camera.width/2)
                 this.x = camera.width /2 + this.size;
             this.y += this.dy * ms;
             if (this.y - this.size > camera.height/2)
                 this.y = -camera.height/2 - this.size;
             else if (this.y + this.size < -camera.height/2)
                 this.y = camera.height/2 + this.size;
         },
         shoot: function(ms, camera) {
             if ((this.dead > 0) || (ship.dead > 0) ||
                 (this.shots.length >= 8))
                 return;
             var v = this.small ?
                     multivec({x: ship.x - this.x,
                               y: ship.y - this.y}).normalize() :
                     multivec({theta: Math.random() * Math.PI * 2});

             this.shots.push({
                 x: this.x, y: this.y, duration: 0,
                 dx: v.x + this.dx,
                 dy: v.y + this.dy,
                 size: this.size * 3 / 10
             });
         },
         destroy: function() {
             var npieces = Math.floor(4 + 4 * Math.random());
             for (var ii = 0; ii < npieces; ++ii)
                 createDebris(this);
             this.x  = this.y  = 1000;
             this.dx = this.dy = 0;
             this.dead = 8000 + 8000 * Math.random();
         }
     };

     var drawRock = function(ctx, points, size) {
         if (points && points.length > 0) {
             var index = points.length - 1;
             var point = points[index];
             ctx.moveTo(
                 Math.cos(index * 2 * Math.PI /
                     points.length) * point * size,
                 Math.sin(index * 2 * Math.PI /
                     points.length) * point * size);
             points.forEach(function(point, index) {
                 ctx.lineTo(
                     Math.cos(index * 2 * Math.PI /
                         points.length) * point * size,
                     Math.sin(index * 2 * Math.PI /
                         points.length) * point * size); });
         }
     };

     var createAsteroid = function(config) {
         var points = [];
         var npoints = 8;
         var nsplits = 2;
         var score = 100;
         var direction = Math.random() * Math.PI * 2;
         var place = Math.random() * Math.PI * 2;
         var x = Math.cos(place) * 1000;
         var y = Math.sin(place) * 1000;

         if ((typeof(config) === "object") && config) {
             if (!isNaN(config.nsplits))
                 nsplits = config.nsplits;
             if (!isNaN(config.x))
                 x = config.x;
             if (!isNaN(config.y))
                 y = config.y;
             if (!isNaN(config.direction))
                 direction = config.direction;
             if (!isNaN(config.size))
                 size = config.size;
         }

         var ii;
         for (var ii = 0; ii < nsplits; ++ii) {
             npoints += 4;
             score = Math.floor(score / 20) * 10;
         }
         for (var ii = 0; ii < npoints; ++ii)
             points.push((Math.random() + 1) / 2);

         return {
             x: x, y: y, dx: 0, dy: 0, size: 0, score: score,
             nsplits: nsplits, direction: direction,
             angle: Math.random() * Math.PI * 2,
             points: points,
             draw: function(ctx) {
                 ctx.save();
                 ctx.translate(this.x, this.y);
                 ctx.rotate(this.angle);
                 ctx.scale(this.size/2, this.size/2);
                 ctx.beginPath();
                 drawRock(ctx, this.points, 1);
                 ctx.restore();
                 ctx.stroke();
             },
             update: function(ms, camera) {
                 if (this.size === 0)
                     this.resize(size);

                 this.angle += ms * Math.PI / (this.size * 30);

                 this.x += this.dx * ms;
                 if (this.x - this.size > camera.width/2)
                     this.x = -camera.width/2 - this.size;
                 else if (this.x + this.size < -camera.width/2)
                     this.x = camera.width/2 + this.size;

                 this.y += this.dy * ms;
                 if (this.y - this.size > camera.height/2)
                     this.y = -camera.height/2 - this.size;
                 else if (this.y + this.size < -camera.height/2)
                     this.y = camera.height/2 + this.size;
             },
             resize: function(size) {
                 this.size = size / 20;
                 for (var ii = 0; ii < nsplits; ++ii)
                     this.size *= 2;
                 this.dx = (Math.cos(direction) * 20 /
                     (this.size + 50));
                 this.dy = (Math.sin(direction) * 20 /
                     (this.size + 50));
             },
             split: function(active) {
                 // Fragments of the asteroid fly off in all
                 // directions.  Dramatic!
                 var npieces = Math.floor(4 + 4 * Math.random());
                 for (var ii = 0; ii < npieces; ++ii)
                     createDebris(this);

                 // Replace the asteroid with two smaller
                 // pieces, unless it's too small.
                 if (this.nsplits > 0) {
                     active.push(createAsteroid({
                         nsplits: this.nsplits - 1,
                         x: this.x, y: this.y}));
                     active.push(createAsteroid({
                         nsplits: this.nsplits - 1,
                         x: this.x, y: this.y}));
                 }
             }
         };
     };

     var createDebris = function(source) {
         var direction = Math.random() * Math.PI * 2;
         var speed = (Math.random() + 1) / 10;
         var points = [];
         var npoints = Math.floor(Math.random() * 3) +  3;

         for (var ii = 0; ii < npoints; ++ii)
             points.push(1/2 + Math.random() / 2);

         debris.push({
             startx: source.x, starty: source.y,
             x: source.x, y: source.y,
             dx: source.dx + Math.cos(direction) * speed,
             dy: source.dy + Math.sin(direction) * speed,
             size: size / 100, duration: 500, points: points,
             update: function(ms) {
                 this.duration -= ms;
                 if (this.duration <= 0)
                     return false;
                 this.x += this.dx * ms;
                 this.y += this.dy * ms;
                 return true;
             },
             draw: function(ctx) {
                 ctx.save();
                 ctx.translate(this.x, this.y);
                 ctx.scale(this.size, this.size);
                 drawRock(ctx, this.points, 1);
                 ctx.restore();
             }
         });
     };

     var checkCollide = function(a, b, ms) {
         return multivec.collideRadiusRadius(
             {x: a.x, y: a.y},
             {x: a.x + a.dx * ms, y: a.y + a.dy * ms}, a.size/2,
             {x: b.x, y: b.y},
             {x: b.x + b.dx * ms, y: b.y + b.dy * ms}, b.size/2);
     };

     return {
         resize: function(camera) {
             size = Math.min(camera.width, camera.height);
             ship.size = size / 20;
             saucer.size = size / 20;
             asteroids.forEach(function(asteroid) {
                 asteroid.resize(size);
             });
         },
         drawBefore: function(ctx, camera, now, last) {
             ctx.font = "20px sans-serif";
             ctx.fillText("Score: " + ship.score.toLocaleString(),
                          10, 20);
         },
         draw: function(ctx, camera, now, last) {
             ctx.lineCap = "round";
             ctx.lineWidth = size / 400;

             ship.draw(ctx);
             saucer.draw(ctx);
             asteroids.forEach(function(asteroid) {
                 asteroid.draw(ctx); });

             ctx.beginPath();
             debris.forEach(function(piece) {
                 piece.draw(ctx); });
             ctx.stroke();
         },

         update: function(ms, camera) {
             while (ms > 100) {
                 this.update(100, camera);
                 ms -= 100;
             }

             var activeDebris = [];
             debris.forEach(function(piece) {
                 if (piece.update(ms))
                     activeDebris.push(piece);
             });
             debris = activeDebris;

             var activeAsteroids = [];
             asteroids.forEach(function(asteroid) {
                 var survived = true;

                 var checkAsteroidShots = function(vessel) {
                     var activeShots = [];
                     vessel.shots.forEach(function(shot) {
                         if (checkCollide(shot, asteroid, ms)) {
                             survived = false;
                             asteroid.split(activeAsteroids);
                             vessel.score += asteroid.score;
                         } else activeShots.push(shot);
                     });
                     vessel.shots = activeShots;
                 };
                 checkAsteroidShots(ship);
                 checkAsteroidShots(saucer);

                 if (survived && !ship.dead &&
                     checkCollide(ship, asteroid, ms)) {
                     ship.destroy();
                     asteroid.split(activeAsteroids);
                     survived = false;
                 }

                 if (survived && !saucer.dead &&
                     checkCollide(saucer, asteroid, ms)) {
                     saucer.destroy();
                     asteroid.split(activeAsteroids);
                     survived = false;
                 }

                 if (survived) {
                     asteroid.update(ms, camera);
                     activeAsteroids.push(asteroid);
                 }
             });
             asteroids = activeAsteroids;

             if (respawn > 0) {
                 respawn -= ms;
                 if (respawn <= 0)
                     for (var ii = 0; ii < 8; ++ii)
                         asteroids.push(createAsteroid());
             } else if (asteroids.length === 0)
                 respawn = 5000;

             var checkEnemyShots = function(vessel, enemy) {
                 if (enemy.dead > 0)
                     return;
                 var activeShots = [];
                 vessel.shots.forEach(function(shot) {
                     if (checkCollide(shot, enemy, ms)) {
                         enemy.destroy();
                         vessel.score += enemy.small ? 1000 : 200;
                     } else activeShots.push(shot);
                 }, activeShots);
                 vessel.shots = activeShots;
             };
             checkEnemyShots(ship, saucer);
             checkEnemyShots(saucer, ship);
             if ((ship.dead === 0) && (saucer.dead === 0) &&
                 checkCollide(ship, saucer, ms)) {
                 ship.destroy();
                 saucer.destroy();
             }

             ship.update(ms, camera);
             saucer.update(ms, camera);
         },

         tap: function(event, camera) {
             ship.aim(event.point, camera); },
         doubleTap: function(event, camera) { ship.shoot(); },
         keydown: function(event, camera) {
             if (event.keyCode === 37 || event.key === 'a') {
                 ship.left = true; ship.right = false;
                 ship.target = undefined;
	     } else if (event.keyCode === 38 || event.key === 'w') {
                 ship.thrust = true;
	     } else if (event.keyCode === 39 || event.key === 'd') {
                 ship.right = true; ship.left = false;
                 ship.target = undefined;
	     } else if (event.keyCode === 40 || event.key === 's') {
                 ship.brake = true;
             } else if (event.key === ' ' || event.key === "Enter") {
                 ship.shoot();
             }
         },
         keyup: function(event, camera) {
             if (event.keyCode === 37 || event.key === 'a')
                 ship.left = false;
	     else if (event.keyCode === 38 || event.key === 'w')
                 ship.thrust = false;
	     else if (event.keyCode === 39 || event.key === 'd')
                 ship.right = false;
	     else if (event.keyCode === 40 || event.key === 's')
                 ship.brake = false;
         },
         isActive: true
     };
 }); //]]></script>
