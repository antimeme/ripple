<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<title>Eight Queens</title>
<style>
 html, body
 { padding: 0; margin: 0; overflow: hidden; position: relative; }
 canvas { background: white; color: #000; }
</style>

<script src="ripple/polyfill.js"></script>
<script src="ripple/grid.js"></script>
<script src="ripple/fascia.js"></script>
<script src="ripple/ripple.js"></script>
<script>//<![CDATA[
 ripple.ready(function() {
     var colorBlack    = 'rgb(48, 32, 32)';
     var colorWhite    = 'rgb(236, 236, 224)';
     var colorBoundary = 'rgb(198, 198, 198)';
     var colorSuccess  = 'rgb(12, 128, 224)';
     var colorCapture  = 'rgba(192, 128, 128, 0.6)';
     var colorQueen    = 'rgb(64, 160, 64)';

     fascia.app({
         camera: ripple.camera(),
         grid: grid.create({type: 'square', size: 20}),
         queens: [],

         center: function() {
             var width  = this.camera.width;
             var height = this.camera.height;
             var boardEdge = this.grid.size() * 7;

             this.camera.position(
                 {x: boardEdge / 2, y: boardEdge / 2});
             this.camera.setScale(0.8 * Math.min(
                 width / boardEdge, height / boardEdge));
         },
         init: function() {
             var param, queen, ii;

             for (ii = 1; param = ripple.param('queen' + ii); ++ii) {
                 param = param.split(',');
                 if (param.length != 2)
                     continue;
                 queen = {row: parseInt(param[0], 10) - 1,
                          col: parseInt(param[1], 10) - 1}
                 if ((queen.row < 0) || (queen.row >= 8) ||
                     (queen.col < 0) || (queen.col >= 8))
                     continue;
                 if (!this.isCaptured(queen.row, queen.col))
                     this.queens.push(this.grid.coordinate(queen));
                 if (ii >= 8)
                     break;
             }
         },
         resize: function(width, height) {
             this.camera.resize(width, height);
             if (!isNaN(width) && !isNaN(height))
                 this.center();
         },
         drawQueen: function(ctx, x, y, size) {
             ctx.moveTo(x - size / 4, y + size / 4);
             ctx.lineTo(x + size / 4, y + size / 4);

             ctx.moveTo(x - size / 4, y + size / 6);
             ctx.lineTo(x + size / 4, y + size / 6);
             ctx.lineTo(x + size / 3, y - size / 5);
             ctx.lineTo(x + size / 6, y);
             ctx.lineTo(x, y - size / 3);
             ctx.lineTo(x - size / 6, y);
             ctx.lineTo(x - size / 3, y - size / 5);
             ctx.lineTo(x - size / 4, y + size / 6);

             ctx.moveTo(x + size * 0.45, y);
             ctx.arc(x, y, size * 0.45, 0, 2 * Math.PI);
         },
         eachBoard: function(fn, context) {
             for (row = 0; row < 8; ++row)
                 for (col = 0; col < 8; ++col)
                     fn.call(context || this, row, col);
         },
         isCaptured: function(row, col) {
             var capture = false;

             for (var ii = 0; ii < this.queens.length; ++ii) {
                 var queen = this.queens[ii];

                 if (queen.row === row ||
                     queen.col === col ||
                     (queen.row - row === queen.col - col) ||
                     (queen.row - row === col - queen.col))
                     capture = true;
             }
             return capture;
         },
         hasQueen: function(row, col) {
             for (var ii = 0; ii < this.queens.length; ++ii) {
                 var queen = this.queens[ii];

                 if (queen.row === row && queen.col === col)
                     return true;
             }
             return false;
         },
         removeQueen: function(row, col) {
             var result = [];
             for (var ii = 0; ii < this.queens.length; ++ii) {
                 var queen = this.queens[ii];

                 if (queen.row !== row || queen.col !== col)
                     result.push(queen);
             }
             this.queens = result;
         },
         draw: function(ctx, width, height) {
             ctx.save();
             this.camera.setupContext(ctx);

             ctx.beginPath();
             this.eachBoard(function(row, col) {
                 if ((row + col) % 2)
                     this.grid.draw(ctx, this.grid.coordinate(
                         {row: row, col: col}));
             });
             ctx.fillStyle = colorBlack;
             ctx.fill();

             ctx.beginPath();
             this.eachBoard(function(row, col) {
                 if (!((row + col) % 2))
                     this.grid.draw(ctx, this.grid.coordinate(
                         {row: row, col: col}));
             });
             ctx.fillStyle = colorWhite;
             ctx.fill();

             ctx.beginPath();
             this.eachBoard(function(row, col) {
                 if (this.isCaptured(row, col))
                     this.grid.draw(ctx, this.grid.coordinate(
                         {row: row, col: col}));
             });
             ctx.fillStyle = colorCapture;
             ctx.fill();

             ctx.beginPath();
             for (row = 0; row < 8; ++row)
                 for (col = 0; col < 8; ++col) {
                     this.grid.draw(ctx, this.grid.coordinate(
                         {row: row, col: col}));
                 }
             ctx.strokeStyle = (this.queens.length >= 8) ?
                               colorSuccess : colorBoundary;
             ctx.stroke();

             ctx.beginPath();
             for (ii = 0; ii < this.queens.length; ++ii)
                 this.drawQueen(ctx, this.queens[ii].x,
                                this.queens[ii].y, this.grid.size());
             ctx.strokeStyle = (this.queens.length >= 8) ?
                               colorSuccess : colorQueen;
             ctx.stroke();

             ctx.restore();
         },
         tap: function(event, redraw) {
             var capture = false;
             var position = this.grid.position(
                 this.camera.toWorldFromScreen(event.point));
             if ((position.row >= 0) && (position.row < 8) &&
                 (position.col >= 0) && (position.col < 8)) {
                 if (this.hasQueen(position.row, position.col))
                     this.removeQueen(position.row, position.col)
                 else if (!this.isCaptured(position.row, position.col))
                     this.grid.coordinate(this.queens.push(position));
             }
             redraw();
         },
         drag: function(event, redraw) {
             console.log('DEBUG drag', event);
             this.camera.pan({
                 x: (event.last.x - event.current.x) /
                 this.camera.scale,
                 y: (event.last.y - event.current.y) /
                 this.camera.scale});
             redraw();
         },
         wheel: function(event, redraw) {
             var width  = this.camera.width;
             var height = this.camera.height;
             var boardEdge = this.grid.size() * 7;
             var size = this.grid.size();

             this.camera.zoom(
                 1 + 0.1 * event.y, 0.8 * Math.min(
                     width / boardEdge, height / boardEdge),
                 Math.min(width / size, height / size));
             redraw();
         }
     });
 }); //]]></script>
