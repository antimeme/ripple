<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<title>Grille Test</title>
<style>
 html, body {
     padding: 0; margin: 0; overflow: hidden;
     position: relative; background: gray;
 }
 canvas { background: white; color: #336; }
 .menu {
     position: absolute; padding: 0.5em;
     background: #333; color: white;
     border: 2px solid white; border-radius: 5px;
     list-style-type: none; list-style-position: outside;
 }
 .menu a { text-decoration: none; color: white; }
 .menu li { padding: 0.5em; border-radius: 5px; }
 .menu li:hover { background: #55e; }
</style>

<script src="ripple/polyfill.js"></script>
<script src="ripple/ripple.js"></script>
<script src="ripple/grille.js"></script>
<script>//<![CDATA[
 ripple.ready(function() {
     var instance;
     var camera = ripple.camera(320, 240);
     var self = document.createElement('canvas');
     document.body.appendChild(self);

     var colorTapInner = 'rgba(45, 45, 128, 0.8)';
     var colorTapOuter = 'rgba(128, 255, 128, 0.6)';
     var colorSelected = 'rgba(192, 192, 0, 0.6)';
     var colorNeighbor = 'rgba(128, 128, 0, 0.4)';
     var colorRadius   = 'rgba(128, 128, 128, 0.2)';
     var colorLine     = 'rgba(128, 128, 224, 0.5)';
     var colorSegment  = 'rgba(128, 128, 224, 0.5)';
     var colorOccupied = 'rgba(128, 192, 128, 0.5)';

     var lineWidth = 0, lineFactor = 40;
     var numbers = false, combined = false;
     var tap, selected, previous;

     var draw_id = 0;
     var draw = function() {
         if (!self.getContext)
             throw Error("canvas has no getContext");
         var ctx = self.getContext('2d');
         var width  = self.clientWidth;
         var height = self.clientHeight;
         var style  = getComputedStyle(self);
         var color = (style.color === 'transparent') ?
                     'white' : style.color;
         var points, last, index;
         var neighbors, vector, radius;

         if (!instance) {
             instance = grille.createGrid({radius: 50});
             lineWidth = instance.getRadius() / lineFactor;
         }

         ctx.save();
         ctx.fillStyle = 'black';
         ctx.fillRect(0, 0, width, height);
         camera.setupContext(ctx);

         // Draw the grid itself
         ctx.beginPath();
         ctx.lineWidth = lineWidth;
         ctx.textAlign = 'center';
         ctx.font = 'bold ' + 12 + 'pt sans-serif';
         instance.map({
             start: camera.toWorldFromScreen({x: 0, y: 0}),
             end:   camera.toWorldFromScreen({x: width, y: height})},
                      function(node) { instance.draw(ctx, node); });
         ctx.fillStyle = style['background-color'];
         ctx.fill();
         ctx.strokeStyle = color;
         ctx.stroke();

         // Drawn grid numbers if configured
         if (combined)
             instance.map({
                 start: camera.toWorldFromScreen({x: 0, y: 0}),
                 end:   camera.toWorldFromScreen({
                     x: width, y: height})},
                          function(node) {
                              ctx.fillStyle = color;
                              ctx.fillText(
                                  ripple.pair(node.row, node.col),
                                  node.x, node.y); });
         else if (numbers)
             instance.map({
                 start: camera.toWorldFromScreen({x: 0, y: 0}),
                 end:   camera.toWorldFromScreen({
                     x: width, y: height})},
                          function(node) {
                              ctx.fillStyle = color;
                              ctx.fillText(
                                  '(' + node.row + ', ' +
                                  node.col + ')', node.x, node.y); });

         if (selected) {
             // Show the currently selected cell.
             ctx.beginPath();
             instance.draw(ctx, selected);
             ctx.fillStyle = colorSelected;
             ctx.fill();

             // Show the cells adjacent to the selected cell.
             ctx.beginPath();
             instance.eachNeighbor(
                 selected, {points: true}, function(neighbor) {
                     instance.draw(ctx, neighbor); });
             ctx.fillStyle = colorNeighbor;
             ctx.fill();

             // Show the boundaries between cells using a different
             // color for each adjacent cell.
             var colors = [
                 'red', 'green', 'blue', 'cyan', 'magenta',
                 'yellow', 'black', 'white'];
             instance.eachNeighbor(
                 selected, {center: true, points: true},
                 function(neighbor, index) {
                     var points = neighbor.points;

                     ctx.beginPath();
                     if (points.length > 1) {
                         vector = {x: points[1].x - points[0].x,
                                   y: points[1].y - points[0].y};
                         ctx.moveTo(points[0].x + 0.25 * vector.x,
                                    points[0].y + 0.25 * vector.y);
                         ctx.lineTo(points[0].x + 0.75 * vector.x,
                                    points[0].y + 0.75 * vector.y);
                     } else if (points.length === 1) {
                         radius = lineWidth * 5;
                         ctx.moveTo(points[0].x + radius,
                                    points[0].y);
                         ctx.arc(points[0].x, points[0].y,
                                 radius, 0, 2 * Math.PI);
                     }
                     ctx.moveTo(neighbor.x + lineWidth * 2,
                                neighbor.y);
                     ctx.arc(neighbor.x, neighbor.y,
                             lineWidth * 2, 0, 2 * Math.PI);

                     ctx.lineWidth = lineWidth;
                     ctx.strokeStyle = colors[index % colors.length];
                     ctx.stroke();
             });

             /* if (previous) {
              *     ctx.beginPath();
              *     instance.eachSegment(
              *         previous, selected, function(node) {
              *             instance.draw(
              *                 ctx, instance.markCenter(node)); });
              *     ctx.fillStyle = colorLine;
              *     ctx.fill();

              *     ctx.beginPath();
              *     ctx.moveTo(previous.x, previous.y);
              *     ctx.lineTo(selected.x, selected.y);
              *     ctx.lineWidth = 2 * lineWidth;
              *     ctx.lineCap = 'round';
              *     ctx.strokeStyle = colorSegment;
              *     ctx.stroke();
              * } */
         }

         if (tap) {
             var targets = tap.targets || [tap];
             for (index = 0; index < targets.length; ++index) {
                 ctx.beginPath();
                 ctx.arc(targets[index].x,
                         targets[index].y,
                         20, 0, 2 * Math.PI);
                 ctx.fillStyle = colorTapOuter;
                 ctx.fill();
             }

             if (targets.length > 1) {
                 ctx.beginPath();
                 instance.eachSegment(
                     targets[0], targets[1], function(node) {
                         instance.draw(
                             ctx, instance.getCenter(node)); });
                 ctx.fillStyle = colorLine;
                 ctx.fill();

                 ctx.beginPath();
                 ctx.moveTo(targets[0].x, targets[0].y);
                 ctx.lineTo(targets[1].x, targets[1].y);
                 ctx.lineWidth = 2 * lineWidth;
                 ctx.lineCap = 'round';
                 ctx.strokeStyle = colorSegment;
                 ctx.stroke();
             }

             ctx.beginPath();
             ctx.arc(tap.x, tap.y, 10, 0, 2 * Math.PI);
             ctx.fillStyle = colorTapInner;
             ctx.fill();
         }

         ctx.restore();
         draw_id = 0;
     };
     var redraw = function()
     { if (!draw_id) draw_id = requestAnimationFrame(draw); };

     window.addEventListener('resize', function(event) {
         // Consume enough space to fill the window.
         self.height = window.innerHeight || window.clientHeight;
         self.width = window.innerWidth || window.clientWidth;
         camera.resize(self.width, self.height);
         redraw();
     });
     window.dispatchEvent(new Event('resize'));

     ripple.gestur({
         tap: function(event) {
             tap = instance.getCell(
                 camera.toWorldFromScreen(event.point));

             previous = selected;
             selected = instance.getCenter(tap);
             redraw();
         },
         doubleTap: function(event) { menuate(event.point); },
         drag: function(event) {
             var start = camera.toWorldFromScreen(event.current);
             var end   = camera.toWorldFromScreen(event.last);
             camera.pan({x: end.x - start.x, y: end.y - start.y});
             redraw();
         },
         wheel: function(event) {
             var size = Math.min(camera.width, camera.height);
             camera.zoom(1 + 0.1 * event.y,
                         size / instance.getRadius() / 20,
                         size / instance.getRadius());
             redraw();
         },
         pinchStart: function(event, camera) {
             this._pinchScale = camera.scale; },
         pinchMove: function(event, camera) {
             var size = Math.min(camera.width, camera.height);
             camera.setScale(this._pinchScale * event.length,
                             size / instance.getRadius() / 20,
                             size / instance.getRadius()); },
     }, self);

     // Populate menu with available grid types
     var menu = ripple.hide(ripple.createElement(
         'ul', {'class': 'menu'}));
     self.parentElement.appendChild(menu);
     var gridSelect = ripple.createElement('select');
     grille.canonical.forEach(function (entry) {
         var value = JSON.stringify(entry);
         gridSelect.appendChild(ripple.createElement(
             'option', {value: value}, entry.name));
     });
     gridSelect.addEventListener("change", function(event) {
         var gridType = event.target.value;
         if (gridType) {
             var options = JSON.parse(decodeURIComponent(
                 event.target.value));
             if (!options)
                 options = {type: gridType};
             options.radius = 50;
             instance = grille.createGrid(options);
             lineWidth = instance.getRadius() / lineFactor;

             tap = undefined;
             selected = undefined;
             previous = undefined;
             ripple.hide(menu);
             redraw();
         }
     });
     menu.appendChild(gridSelect);
     menu.appendChild(document.createElement('hr'));
     menu.appendChild(ripple.createElement(
         'li', {data: {action: "numbers"}}, 'Toggle Numbers'));
     menu.appendChild(ripple.createElement(
         'li', {data: {action: "colors"}}, 'Swap Colors'));
     menu.appendChild(ripple.createElement(
         'li', {data: {action: "full-screen"}}, 'Full Screen'));
     menu.addEventListener('click',function(event) {
         if (event.target.tagName.toLowerCase() !== 'li')
             return false;
         ripple.hide(menu);
         switch (event.target.getAttribute('data-action')) {
             case 'full-screen': {
                 ripple.toggleFullscreen(self.parentElement);
             } break;
             case 'numbers': {
                 if (combined) {
                     numbers = combined = false;
                 } else if (numbers)
                     combined = true;
                 else numbers = true;
                 redraw();
             } break;
             case 'colors': {
                 var style = getComputedStyle(self);
                 var swap = style.color;
                 self.style.color = style['background-color'];
                 self.style['background-color'] = swap;
                 redraw();
             } break;
         }
     });

     // Show grid menu at event location
     var menuate = function(tap) {
         menu.style.top = 10 + 'px';
         menu.style.left = 25 + 'px';
         ripple.show(menu);
         drag = undefined;
     };

 }); //]]></script>
