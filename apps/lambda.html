<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<style>
</style>
<title>Lambda Calculus</title>
<h1>Lambda Calculus</h1>
<textarea id="expression" rows="12" cols="80">
</textarea><br />
<button id="reduce">Reduce</button>
<button id="repeat">Repeat</button>
Steps: <input id="steps" type="text" disabled="disabled" />
<br />
<button id="library">Library</button>
<select id="library-expressions">
    <option></option>
</select>
<button id="restore">Restore</button>

<p>
    Lambda Calculus is an abstract model of computation.  Alan Turing
    proved that it is equivalent to his notion of a Turing machine.
    This program implements lambda expressions, normal order reduction
    and a library of useful functions.  The lambda calculus itself
    contains only variables, grouping, abstractions and applications.
    Notice that this does not include boolean logic, data structures
    recursion or numbers.  And yet the library included here contains
    all of these things because there are indirect ways to implement
    them on the minimal foundation that lambda calculus provides.
</p>
<h2>Contents</h2>
<ol><li>
    <a href="#definition">Definition</a>
</li><li>
    <a href="#computation">Computation</a>
</li><li>
    <a href="#halting">Halting</a>
</li><li>
    <a href="#instructions">Instructions</a>
</li><li>
    <a href="#arithmetic">Arithmetic</a>
</li><li>
    <a href="#recusion">Recusion</a>
</li></ol>
<h2><a name="definition">Definition</a></h2>
<p>
    A lambda calculus expression is composed from four components.
    Note that while all lambda calculus abstractions accept exactly
    one variable, in practice we allow more than one variable
    with a simplified notation.  For example, instead of writing
    <code>lambda a.lambda b.a</code> we will usually write
    <code>lambda a b.a</code> instead.
</p><ul><li>
    Variable: any identifier not containing lambda,
    <q>(</q>, <q>)</q> or <q>.</q>
</li><li>
    Grouping: ( [expression] )
</li><li>
    Abstraction: lambda [variable].[expression]
</li><li>
    Application: [expression1] [expression2]
</li></ul><p>
    Any combination of these components is a valid lambda calculus
    expression.  Here are some examples:
</p><ul><li><code>
    λa.a
</code></li><li><code>
    (λa b f.f a b) (λf a.f a) ((λa b f.f a b) (λf a.f (f a)) ((λa b f.f a b) (λf a.f (f (f a))) (λa.λa b.a)))
</code></li><li><code>FIX (λf n.(EQUAL n ZERO) ONE
     (MULTIPLY n (f (PREDECESSOR n))))
</code></li></li></ul><p>
    Variables within a lambda calculus expression are either bound or
    free.  Any variable following a lambda is bound in the expression
    following the next dot.  A variable not bound in this way is free.
    The first two examples above have no free variables.  The third
    has many free variables, including <code>FIX</code>,
    <code>EQUAL</code> and <code>MULTIPLY</code>.
</p><p>
    Any lambda expression with no free variables is called a
    combinator.  Many combinators are useful enough that we give them
    names.  For example λa.a is called the identity combinator.  This
    is the simplest possible combinator.
</p>

<h2><a name="computation">Computation</a></h2>
<p>
    Computation in lambda calculus is performed by reductions.  A
    reduction applies an expression to an abstraction by replacing
    all instance of a variable with that expression inside the body
    of the abstraction.  For example, let's reduce the following
    lambda expression:
</p><ul><li>
    <code>(λa.a) VALUE</code>
</li><li>
    <code>a [a := VALUE]</code>
</li><li>
    <code>VALUE</code>
</li></ul><p>
    We reduce the abstraction by replacing it with its body.  In this
    case the body consists only of the variable <code>a</code>.
    However, we must also replace all instances of the variable with
    the value we are applying.  That's simple in this case, but there
    may be no instance to replace or there may be many.  Here is
    another example with more than one instance:
</p><ul><li>
    <code>(λf a.f (f a)) λb.b</code>
</li><li>
    <code>(λa.f (f a)) [f := (λb.b)]</code>
</li><li>
    <code>(λa.(λb.b) ((λb.b) a))</code>
</li></ul><p>
    Often it will be possible to further reduce a reduced value, as
    in this example:
</p><ul><li>
    <code>(λn.n ((λa b.a) (λa b.b)) (λa b.a)) (λa b.b)</code>
</li><li>
    <code>n ((λa b.a) (λa b.b)) (λa b.a) [n := (λa b.b)]</code>
</li><li>
    <code>(λa b.b) ((λa b.a) (λa b.b)) (λa b.a)</code>
</li><li>
    <code>(λb.b) [a := ((λa b.a) (λa b.b))] (λa b.a)</code>
</li><li>
    <code>(λb.b) (λa b.a)</code>
</li><li>
    <code>b [b := (λa b.a)]</code>
</li><li>
    <code>(λa b.a)</code>
</li></ul><p>
    We will usually want to continue reducing until no more reductions
    are possible.  When this happens we say that the expression is in
    normal form.  Not all expressions have a normal form, but for those
    that do there is only one.  This is the
    <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem"
    >Church-Rosser Theorem</a>.
</p><p>
    What would an expression without a normal form look like?  There is
    a simple example we can create using the Mockingbird combinator:
</p><ul><li>
    <code>(λm.m m) (λm.m m)</code>
</li><li>
    <code>m m [m := (λm.m m)]</code>
</li><li>
    <code>(λm.m m) (λm.m m)</code>
</li></ul><p>
    Each time we reduce this expression, we end up back where we
    started.  There are always more reductions to perform so there is
    no normal form.
</p>
<h2><a name="halting">Halting Problem</a></h2>
<p>
    Let's use the lambda calculus to take on the famous
    <a href="https://en.wikipedia.org/wiki/Halting_problem">halting
        problem</a>.  Can we write a program that accepts another
    program as input and returns TRUE if it has a normal form and
    FALSE if it doesn't?  It turns out that this is impossible.  Let's
    use the lambda calculus to understand why.
</p><p>
    Suppose we could solve the problem.  Suppose a lambda
    expression which we'll call <code>DOES-HALT?</code> does
    the job.  Here is what that might look like:
</p><ul><li>
    <code>DOES-HALT? p</code>
</li></ul><p>
    This reduces to TRUE if p has a normal form and FALSE otherwise.
    Maybe we aren't clever enough to figure out how to implement this
    but it certainly seems like it should be possible.  But even the
    existance of such a program is enough to create a profoundly
    troubling situation.  Let's start by doing this:
</p><ul><li>
    <code>(λp.(DOES-HALT? p) ((λm.m m) (λm.m m)) TRUE)</code>
</li></ul><p>
    This is clearly a valid lambda calculus expression.  Given an
    input program with a normal form this program reduces to a program
    without a normal form.  Otherwise it reduces to TRUE, which does
    have a normal form.  So it does the opposite of the program it has
    been given.  Again, this seems reasonable enough.  But consider
    what happens when we try this:
</p><ul><li>
    <code>DOES-HALT? ((λm.m m) (λp.(DOES-HALT? p)
                       ((λm.m m) (λm.m m)) TRUE))</code>
</li></ul><p>
    What happens when we apply this program to itself?  Does it halt?
    If the answer is yes then it clearly doesn't halt because it
    reduces to a program without a normal form.  But if the answer is
    no then it clearly does because it reduces to TRUE!  There's no
    way <code>DOES-HALT?</code> could return either TRUE or FALSE!
    The only way to resolve this contradiction is to accept that
    <code>DOES-HALT?</code> is impossible to construct.
</p>
<h2><a name="computation">Instructions</a></h2>
<p>
    As we will see, lambda calculus is not an efficient way to perform
    computations.  However it's still impressive that such a simple
    system can be universal.  Select a library function from the drop
    down box to study it.  Can you understand how it works?  Or type
    your own lambda expressions into the text area.
</p><p>
    Click the Reduce button to perform a single step of computation.
    Most computations require a large number of steps, so you can
    instead click the repeat button to continuously perform reductions.
    This will terminate when no more reductions are possible, though
    of course not all programs terminate.  For an example of a program
    that doesn't terminate try this:
</p><blockquote><pre>
                (lambda n.n n) (lambda m.m m)
</pre></blockquote><p>
    Copy and paste this into the text area above and click repeat.
    This will reduce indefinitely.  Click reduce to stop the process --
    it will never stop on its own.
</p>
<h2><a name="arithmetic">Arithmetic</a></h2>
<p>
    Let's explore a computation that does terminate.  We'll use the
    built in library to add two numbers.  Copy and paste the following
    into the text area:
</p><blockquote><pre>
                ADD TWO THREE
</pre></blockquote><p>
    This will not reduce further since all three of the terms here are
    free variables.  Click the Library button twice to replace these
    free variables with combinators.  Once there are no more free
    variables click repeat.  This should reduce to normal form in
    thirteen steps.  But what did it reduce to?  This is a function
    that takes two arguments and applies the first to the second five
    times.  That is the Church Numeral representation of five. In
    other words, two plus three is five!
</p><p>
    How can we be sure?  We can use the library to check.  Change the
    buffer by prepending so that it looks like this:
</p><blockquote><pre>
                EQ FIVE lambda f a.f (f (f (f (f a))))
</pre></blockquote><p>
    Click the Library button until there are no more free variables.
    Then click repeat and get comfortable.  This will take 384 steps
    and considerable time.  But it will return the lambda calculus
    value of TRUE which is: lambda a b.a
</p><p>
    In the lambda calculus true and false are functions that accept
    two arguments and return their first and second arguments,
    respectively.  We can use free variables to make this more clear:
</p><blockquote><pre>
                (EQ FIVE lambda f a.f (f (f (f (f a))))) YES NO
</pre></blockquote><p>
    After 386 steps this should reduce to YES.  We can check that
    this is meaningful by trying an incorrect equation:
</p><blockquote><pre>
                (EQ SEVEN lambda f a.f (f (f (f (f a))))) YES NO
</pre></blockquote><p>
    Now after 416 steps this reduces to NO.  That makes sense, doesn't
    it?  Seven is not equal to five.
</p><p>
    Another way we could have checked is to select FIVE from the
    drop down box.  This produces the same expression.  We can see
    that both the answer to or original expression and the library
    version of FIVE are the same.
</p>
<h2><a name="recusion">Recursion</a></h2>
<p>
    Sometimes computatsion are more convenient to express in terms
    of recursion.  This means a function calls itself on a reduced
    form of its input in order to break down the problem.  Of course,
    lambda calculas has no support for recursion.  Even so, our
    library contains a recursive function called FACTORIAL.  Here
    is an example of this function you can try running yourself:
</p><blockquote><pre>
                FACTORIAL THREE
</pre></blockquote><p>
    After 2907 steps this arrives at the Church Numeral representation
    of SIX (because three factorial is three times two times one).
    This representation of six looks a little different.  In
    particular, it uses a different variable name.  We can check that
    this is SIX the same way we compared our earlier result to five.
</p><p>
    So how does this work?  It makes use of the FIX combinator -- also
    known as the
    <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Y
        combinator</a>.  The Y combinator causes a function to be
    called with itself as an argument.  This makes it possible for
    the function to call itself without any support for recursion in
    the programming environment.
</p>

<script src="ripple/ripple.js"></script>
<script src="ripple/solvo.js"></script>
<script>//<![CDATA[
 var expression = document.getElementById("expression");
 var reduce     = document.getElementById("reduce");
 var repeat     = document.getElementById("repeat");
 var restore    = document.getElementById("restore");
 var library    = document.getElementById("library");
 var lexprs     = document.getElementById("library-expressions");
 var steps      = document.getElementById("steps");
 var stepCount = 0;
 var repeating = false;
 var previous = null;

 solvo.forEachLambda(function(expression, name) {
     var option = document.createElement("option");
     option.setAttribute("value", expression.toString());
     option.innerHTML = name;
     lexprs.appendChild(option);
 });
 lexprs.addEventListener("change", function(event) {
     if (lexprs.value) {
         previous = expression.value;
         expression.value = lexprs.value;
         steps.value = stepCount = 0;
     }
 });

 var continuousReduce = function() {
     var expr = solvo.lambda(expression.value);
     expr = expr.reduce();

     if (!expr.normal) {
         expression.value = expr.toString();
         stepCount += 1;
         steps.value = stepCount;
         if (repeating)
             setTimeout(continuousReduce, 50);
     }
 };

 expression.addEventListener("change", function(event) {
     repeating = false;
     steps.value = stepCount = 0;
     lexprs.value = "";
 });

 reduce.addEventListener("click", function(event) {
     var expr = solvo.lambda(expression.value);
     expr = expr.reduce();
     if (!expr.normal) {
         expression.value = expr.toString();
         stepCount += 1;
         steps.value = stepCount;
     }
     repeating = false;
 });
 repeat.addEventListener("click", function(event) {
     previous = expression.value;
     steps.value = stepCount = 0;
     repeating = true;
     setTimeout(continuousReduce, 50);
 });
 restore.addEventListener("click", function(event) {
     if (previous)
         expression.value = previous;
     steps.value = stepCount = 0;
     previous = null;
     repeating = true;
 });
 library.addEventListener("click", function(event) {
     var expr = solvo.lambda(expression.value);
     expression.value = expr.useLibrary().toString();
     repeating = false;
 });
 //]]></script>
