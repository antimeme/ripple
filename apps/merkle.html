<!DOCTYPE html>
<title>Merkle Tree</title>
<!-- An interactive illustration of a Merkle tree.
     Click to select a node. -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<style>
 html, body, canvas, div { margin: 0; padding: 0 }
 html, body { height: 100%; }
 body { overflow-x: visible; overflow-y: hidden; }
 #screen { background-color: slategray; }
</style>
<canvas id="screen"></canvas>
<script type="module">//<![CDATA[
 import Camera from "./ripple/camera.mjs";
 import Multivec from "./ripple/multivec.mjs";

 class MerkleTree {
     constructor(depth, radius, center) {
         this.selected = null;
         this.center = center || {x: 0, y: 0};
         this.radius = isNaN(radius) ? 1 : Math.abs(radius);
         this.depth = isNaN(depth) ? 5 : Math.max(1, depth);
         this.colors = {
             base: "white",
             lines: "darkslategray",
             selected: "deepskyblue",
             parent: "tomato",
             child: "orchid" };
     }

     __quadrance(point) {
         let delta = {
             x: point.x - this.center.x,
             y: point.y - this.center.y };
         return delta.x * delta.x + delta.y * delta.y;
     }

     __radians(point) {
         let delta = {
             x: point.x - this.center.x,
             y: point.y - this.center.y };
         let length = Math.sqrt(delta.x * delta.x + delta.y * delta.y);
         return Math.acos(delta.x / length);
     }

     __arc(ctx, radius, begin, end) {
         ctx.moveTo(this.center.x + radius, this.center.y);
         ctx.arc(this.center.x, this.center.y, radius, begin, end);
     }

     __compliment(path) {
         var result = [];
         for (let ii = 0; ii < path.length; ++ii) {
             let current = path.slice(0, path.length - ii);
             current[current.length - 1] ^= 1;
             result.push(current);
         }
         return result;
     }

     __section(point, increment) {
         if (!point)
             return null;
         let quadrance = this.__quadrance(this.selected);
         if (!increment)
             increment = this.radius / (this.depth + 1);

         let result = null;

         if (quadrance < increment * increment) {
             result = { root: true };
         } else if ((this.selected.y > 0) &&
                    (quadrance < this.radius * this.radius)) {
             let radians = this.__radians(point);
             let path = [];

             for (let ii = 1; ii <= this.depth; ++ii) {
                 let slices = 1 << ii;
                 let slice = Math.floor(slices * radians / Math.PI);

                 path.push(slice);
                 if (quadrance < ((ii + 1) * increment *
                     (ii + 1) * increment)) {

                     result = {
                         inner: ii * increment,
                         outer: (ii + 1) * increment,
                         start: Math.PI * slice / slices,
                         stop: Math.PI * (slice + 1) / slices,
                         path: path
                     };
                     break;
                 }
             }
         }
         return result;
     }

     __drawSection(ctx, start, stop, outer, inner) {
         ctx.moveTo(
             this.center.x + Math.cos(start) * outer,
             this.center.y + Math.sin(start) * outer);
         ctx.arc(this.center.x, this.center.y, outer, start, stop);
         ctx.lineTo(
             this.center.x + Math.cos(stop) * inner,
             this.center.y + Math.sin(stop) * inner);
         ctx.arc(this.center.x, this.center.y, inner,
                 stop, start, true);
     }

     draw(ctx) {
         let increment = this.radius / (this.depth + 1);
         let ii, jj;

         // Background
         ctx.beginPath();
         this.__arc(ctx, this.radius, 0, Math.PI);
         this.__arc(ctx, increment, 0, 2 * Math.PI);
         ctx.fillStyle = this.colors["base"];;
         ctx.fill();

         let section = this.__section(this.selected, increment);
         if (section) {
             // Highlight children of selected node
             ctx.beginPath();
             if (section.root)
                 this.__arc(ctx, this.radius, 0, Math.PI);
             else this.__drawSection(ctx, section.start, section.stop,
                                     this.radius, section.inner);
             ctx.closePath();
             ctx.fillStyle = this.colors["child"];;
             ctx.fill();

             // Highlight selected node itself
             ctx.beginPath();
             if (section.root)
                 this.__arc(ctx, increment, 0, 2 * Math.PI);
             else this.__drawSection(ctx, section.start, section.stop,
                                     section.outer, section.inner);
             ctx.closePath();
             ctx.fillStyle = this.colors["selected"];;
             ctx.fill();

             // Highlight nodes needed for proof of membership
             ctx.beginPath();
             if (section.path) {
                 this.__compliment(section.path).forEach((path) => {
                     let index = path.length;
                     let slices = 1 << index;
                     let slice = path[path.length - 1];

                     this.__drawSection(
                         ctx, Math.PI * slice / slices,
                         Math.PI * (slice + 1) / slices,
                         (index + 1) * increment, index * increment);
                 }, this);
             }
             ctx.fillStyle = this.colors["parent"];
             ctx.fill();
         }

         // Lines to separate each cell
         ctx.beginPath();
         for (ii = 2; ii <= this.depth; ++ii)
             this.__arc(ctx, increment * ii, 0, Math.PI);
         for (ii = 1; ii <= this.depth; ++ii) {
             for (jj = 0; jj < (1 << (ii - 1)); ++jj) {
                 let radians = Math.PI * (2 * jj + 1) / (1 << ii);;
                 ctx.moveTo(ii * increment * Math.cos(radians),
                            ii * increment * Math.sin(radians));
                 ctx.lineTo(this.radius * Math.cos(radians),
                            this.radius * Math.sin(radians));
             }
         }
         ctx.moveTo(increment, 0);
         ctx.lineTo(this.radius, 0);
         this.__arc(ctx, this.radius, 0, Math.PI);
         ctx.lineTo(-increment, 0);
         this.__arc(ctx, increment, 0, 2 * Math.PI);
         ctx.lineWidth = 0.01;
         ctx.strokeStyle = this.colors["lines"];
         ctx.stroke();
     }

     select(point) {
         let quadrance = this.__quadrance(point);

         if ((quadrance < (this.radius * this.radius /
             this.depth * this.depth)) ||
             ((point.y > 0) &&
              (quadrance < (this.radius * this.radius))))
             this.selected = point;
         else this.selected = null;
             
     }
 }

 let screen = document.querySelector("#screen");
 let camera = undefined;
 let ctx = undefined;
 let tree = new MerkleTree(5);

 function draw() {
     camera.configureContext(ctx);
     tree.draw(ctx);
     camera.restoreContext(ctx);
 }

 function update() {
     draw();
 }

 screen.addEventListener("mousedown", (event) => {
     if (camera)
         tree.select(camera.toWorld({
             x: event.clientX, y: event.clientY}));
     update();
 });

 screen.addEventListener("mouseup", (event) => { });

 screen.addEventListener("mouseleave", (event) => { });

 screen.addEventListener("mousemove", (event) => { });

 document.addEventListener("DOMContentLoaded", () => {
     window.addEventListener("resize", function() {
         ctx = screen.getContext("2d");
         screen.width = document.body.clientWidth;
         screen.height = document.body.clientHeight;
         camera = new Camera(screen.width, screen.height);
         camera.pan({x: 0, y: -0.45});
         camera.zoom(1.5);
         update();
         draw();
     });
     window.dispatchEvent(new Event("resize"));
 });

 //]]></script>
