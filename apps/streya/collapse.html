<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<style>
 html, body
 { position: absolute; padding: 0; margin: 0; overflow: hidden; }
 canvas { background-color: #112; }
</style>
<title>Collapse</title>
<script type="module">//<![CDATA[
 import Ripple from "../ripple/ripple.mjs";
 import Camera from "../ripple/camera.mjs";
 import { createSampleShip } from "./structure.mjs";

 function roundRect(ctx, x, y, width, height, radius) {
     ctx.beginPath();
     ctx.moveTo(x + radius, y);
     ctx.lineTo(x + width - radius, y);
     ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
     ctx.lineTo(x + width, y + height - radius);
     ctx.quadraticCurveTo(x + width, y + height,
                          x + width - radius, y + height);
     ctx.lineTo(x + radius, y + height);
     ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
     ctx.lineTo(x, y + radius);
     ctx.quadraticCurveTo(x, y, x + radius, y);
     ctx.closePath();
     ctx.fill();
 }

 Ripple.preloadURLs(undefined, (loaded) => {
     const screen = document.createElement("canvas");
     const camera = new Camera(screen).setScale(4);
     document.body.appendChild(screen);

     const ship = createSampleShip();
     let nCells = 0;
     let nFree  = 0;
     ship.eachCell(function(cell, node) { ++nCells; });
     ship.eachRoom(function(room) { room.eachNode(
         function(node) { ++nFree; }); });

     let draw_id = 0;
     function draw() {
         if (!screen.getContext)
             throw Error("canvas has no getContext");
         const ctx = screen.getContext("2d");
         camera.configureContext(ctx);

         ship.draw(ctx, camera);

         camera.restoreContext(ctx);
         ctx.globalAlpha = 0.5;
         ctx.fillStyle = "#eee";
         const width  = camera.width / 3;
         const height = camera.height / 15;
         roundRect(ctx, camera.width / 2 - width / 2,
                   camera.height * 94 / 100 - height / 2,
                   width, height,
                   Math.max(camera.width, camera.height) / 100);

         ctx.globalAlpha = 1.0;
         ctx.font = (
             Math.min(camera.width, camera.height) /
             20) + "px sans";
         ctx.textAlign = "center";
         ctx.fillStyle = "black";
         ctx.fillText("Rooms: " + ship.getRoomCount() +
                      " Cells: " + nFree + "/" + nCells,
                      camera.width / 2,
                      camera.height * 19 / 20);
         draw_id = 0;
     }
     function redraw() {
         if (!draw_id)
             draw_id = requestAnimationFrame(draw);
         return false;
     }

     function getPoint(event, thing) {
         const bounds = event.target.getBoundingClientRect();
         if (!thing)
             thing = event;
         return {x: thing.clientX - bounds.x,
                 y: thing.clientY - bounds.y};
     }

     let drag = undefined;
     let selected = undefined;

     screen.addEventListener("mousedown", event => {
         drag = camera.toWorld(getPoint(event));
         selected = drag;
         return redraw();
     });

     screen.addEventListener("mousemove", event => {
         if (!drag)
             return false;
         drag = camera.toWorld(getPoint(event));
         camera.pan({x: drag.x - selected.x,
                     y: drag.y - selected.y});
         return redraw();
     });

     screen.addEventListener("mouseup", event => {
         drag = undefined;
         return redraw();
     });

     screen.addEventListener("wheel", event => {
         camera.zoom((event.wheelDeltaY > 0) ? (5/4) : (4/5), 1, 20);
         event.preventDefault();
         return redraw();
     });

     window.addEventListener("resize", event => {
         screen.height = window.innerHeight || window.clientHeight;
         screen.width = window.innerWidth || window.clientWidth;
         camera.resize();
         return redraw();
     });
     window.dispatchEvent(new Event("resize"));
 }); //]]></script>
