<!DOCTYPE html>
<title>Triangulate</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, user-scalable=no" />
<meta name="viewport" content="initial-scale=1, maximum-scale=1" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<style>
 html, body
 { position: absolute; padding: 0; margin: 0; overflow: hidden;  }
 fieldset.menu {
     border: 2px solid black;  background: lightgray;
 }
 fieldset.menu legend {
     border: 2px solid black;  background: lightgray;
 }
</style>
<script src="ripple/polyfill.js"></script>
<script src="ripple/ripple.js"></script>
<script src="ripple/fascia.js"></script>
<script src="ripple/random.js"></script>
<script src="ripple/multivec.js"></script>
<script>//<![CDATA[
 "use strict";

 var npoints = Math.max(parseInt(ripple.param('npoints'), 10) || 0, 3);
 var drawVoroni   = ripple.param('voroni');
 var drawDelaunay = ripple.param('delaunay');
 var drawCircles  = ripple.param('circles');

 var generatePoints = function() {
     var result = [];
     var ii;
     var r = random.random();

     for (ii = 0; ii < npoints; ++ii)
         result.push({ x: r.random() * 0.9 + 0.05,
                       y: r.random() * 0.9 + 0.05 });
     return result;
 };

 var getDelaunayTriangles = function(config, points) {
     // This is an implementation of the Bowyer-Watson algorithm:
     // https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm
     // Unlike most implementations this one does not rely on a
     // super-triangle or bounding region.  Instead we start with
     // one triangle made from the first three points and three
     // triangles with vertices at infinity.  Compactification!
     if (Array.isArray(config)) {
         points = config;
         config = undefined;
     }
     if (!points || points.length < 3)
         throw new Error("Not enough points");
     if (!(points[0] instanceof multivec) ||
         !multivec.zeroish(points[0].quadrance()))
         points = points.map(function(point) {
             return multivec(point).createPoint(); });

     var createTriangle = function(indices) {
         var result = Object.create(getDelaunayTriangles);
         result.indices = indices;
         result.vertices = indices.map(function(index) {
             return (index >= 0) ? points[index] :
                    multivec.infinityPoint; });
         result.edges = [[indices[0], indices[1]],
                         [indices[1], indices[2]],
                         [indices[2], indices[0]]];
         result.circle = result.vertices.reduce(
             function(circle, vertex) {
                 return circle ? circle.wedge(vertex) : vertex; });
         result.isFinite = function() {
             return (this.indices[0] >= 0) &&
                    (this.indices[1] >= 0) &&
                    (this.indices[2] >= 0); };
         return result;
     };

     // Begin with a single triangle made from the first three points
     // as well as one triangle from each edge completed by the point
     // at infinity, which is represented by index -1 here.
     var result = [[0, 1, 2], [-1, 1, 0], [-1, 2, 1], [-1, 0, 2]]
         .map(createTriangle);

     // All points exist within a carrier plane, represented here.
     var carrier = result[0].circle.wedge(multivec.infinityPoint);

     var ii, jj, point, triangle, next, edges;
     for (ii = 3; ii < points.length; ++ii) {
         point = points[ii];

         // Find all triangle with circumcircles that include the
         // new point.  Those are discarded but their edges are
         // stored for later use, except any that are duplicated.
         // This will leave us with a polygonal gap.
         next = [];
         edges = {};
         for (jj = 0; jj < result.length; ++jj) {
             triangle = result[jj];

             // Positive scalars indicate the point is inside the
             // circumcircle (or equivalent for a line).  That
             // invalidates the triangle but we keep its edges
             // from which to construct new triangles.
             if (triangle.circle.wedge(point)
                         .divide(carrier).scalar < 0) {
                 triangle.edges.forEach(function(edge) {
                     var index = ripple.pair(edge[0], edge[1]);
                     var indrv = ripple.pair(edge[1], edge[0]);
                     if (index in edges)
                         delete edges[index];
                     else if (indrv in edges)
                         delete edges[indrv];
                     else edges[index] = true;
                 });
             } else next.push(result[jj]);
         }

         // Combine each edge with the new point to make a new triangle
         Object.keys(edges).forEach(function(pair, index) {
             var edge = ripple.unpair(pair);
             next.push(createTriangle([edge.x, edge.y, ii]));
         });
         result = next;
     }

     // Discard triangles with vertices at infinity
     if (!config || config.dropOutside)
         result = result.filter(function(triangle) {
             return triangle.isFinite(); });
     return result;
 };

 var getVoroniEdges = function(elements) {
     if (!elements || elements.length < 1)
         throw new Error("Not enough points");
     var result = [];
     var triangles = getDelaunayTriangles.isPrototypeOf(elements[0]) ?
                     elements : getDelaunayTriangles(elements);
     var edges = {};
     triangles.forEach(function(triangle) {
         triangle.center = multivec.infinityPoint
                                   .applyVersor(triangle.circle)
                                   .normalizePoint();
         triangle.edges.forEach(function(edge) {
             var other;
             var index = ripple.pair(edge[0], edge[1]);
             var indrv = ripple.pair(edge[1], edge[0]);
             if (index in edges) {
                 other = edges[index];
                 console.log("DEBUG-a", index, other);
                 delete edges[index];
             } else if (indrv in edges) {
                 other = edges[indrv];
                 console.log("DEBUG-b", index, other);
                 delete edges[indrv];
             } else edges[index] = triangle;

             if (other)
                 result.push([triangle.center, other.center]);
         });
     });
     console.log(result.length, result);
     return result;
 };

 fascia.ready(function() {
     'use strict';
     var applegend = 'Triangulate';
     var points = generatePoints();
     var triangles = getDelaunayTriangles(points);
     var voroni = getVoroniEdges(triangles);
     var redraw = function() {};

     return {
         init: function(camera, canvas, container, fasciaRedraw) {
             canvas.style.background = 'rgb(224, 224, 224)';
             redraw = fasciaRedraw;
         },
         draw: function(ctx, camera, now, last) {
             var size = Math.min(camera.width, camera.height);

             ctx.lineCap = 'round';
             ctx.lineWidth = 2;

             if (drawCircles) {
                 ctx.beginPath();
                 triangles.forEach(function(triangle) {
                     try {
                         var center = multivec.infinityPoint
                                              .applyVersor(triangle.circle)
                                              .normalizePoint();
                         var radius = Math.sqrt(triangle.circle.divide(
                             triangle.circle.wedge(
                                 multivec.infinityPoint)).quadrance());
                         ctx.moveTo((center.x - 0.5) * camera.width +
                                    radius * camera.width,
                                    (center.y - 0.5) * camera.height);
                         ctx.ellipse((center.x - 0.5) * camera.width,
                                     (center.y - 0.5) * camera.height,
                                     radius * camera.width,
                                     radius * camera.height,
                                     0, 0, Math.PI * 2);
                     } catch(error) { console.error(error); }
                 });
                 ctx.strokeStyle = 'skyblue';
                 ctx.stroke();
             }

             if (drawDelaunay) {
                 ctx.beginPath();
                 triangles.forEach(function(triangle) {
                     ctx.moveTo(
                         (triangle.vertices[0].x - 0.5) * camera.width,
                         (triangle.vertices[0].y - 0.5) * camera.height);
                     ctx.lineTo(
                         (triangle.vertices[1].x - 0.5) * camera.width,
                         (triangle.vertices[1].y - 0.5) * camera.height);
                     ctx.lineTo(
                         (triangle.vertices[2].x - 0.5) * camera.width,
                         (triangle.vertices[2].y - 0.5) * camera.height);
                     ctx.lineTo(
                         (triangle.vertices[0].x - 0.5) * camera.width,
                         (triangle.vertices[0].y - 0.5) * camera.height);
                 });
                 ctx.strokeStyle = 'darkred';
                 ctx.stroke();                 
             }

             if (drawVoroni) {
                 ctx.beginPath();
                 voroni.forEach(function(edge) {
                     console.log("DEBUG", edge);
                     ctx.moveTo(
                         (edge[0].x - 0.5) * camera.width,
                         (edge[0].y - 0.5) * camera.height);
                     ctx.lineTo(
                         (edge[1].x - 0.5) * camera.width,
                         (edge[1].y - 0.5) * camera.height);
                 });
                 ctx.strokeStyle = 'darkblue';
                 ctx.stroke();
             }

             ctx.beginPath();
             points.forEach(function(point, index) {
                 var p = { x: (point.x - 0.5) * camera.width,
                           y: (point.y - 0.5) * camera.height };
                 ctx.moveTo(p.x + size / 60, p.y);
                 ctx.arc(p.x, p.y, size / 60, 0, Math.PI * 2);
             });
             ctx.fillStyle = 'rgb(32, 192, 32)';
             ctx.fill();
             ctx.strokeStyle = 'rgb(32, 32, 192)';
             ctx.stroke();

             ctx.beginPath();
             ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
             ctx.textAlign = 'center';
             ctx.textBaseline = 'top';
             ctx.font = 'bold ' + Math.round(
                 Math.min(camera.height, camera.width) / 20) +
                        'px sans';
             ctx.fillText(applegend, 0, -camera.height/2);
         },
         tap: function(event, camera) {
         },
         wheel: function(event, camera)
         { camera.zoom(1 + 0.1 * event.y, 1, 10); },
     }
 }); //]]></script>
