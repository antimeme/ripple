<!DOCTYPE html>
<html lang="en">
    <title>Lambda Calculus</title>
    <!-- Copyright (C) 2020-2021 by Jeff Gold.  All rights reserved. -->
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="lambdacalculus.svg" />
    <link rel="stylesheet" href="lib/reveal/reveal.css" />
    <link rel="stylesheet" href="lib/reveal/sky.css" />
    <link rel="stylesheet" href="lib/slides.css" />
    <div class="reveal"><div class="slides"><section id="lambdacalculus">
        <section>
            <h1>Lambda Calculus</h1>
            <p>
                &#x03bb;f.f (&#x03bb;a b c.a c (b c)) &#x03bb;d e.d
            </p>
        </section>
        <section>
            <h2>Lambda Calculus</h2>
            <p>
                Lambda calculus is a simple, compact and universal
                model of computation.  Published by
                <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonso
                    Church</a> in 1936 CE, it slightly predates
                <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing
                    Machines</a>.  Both can compute any generally
                recursive function.
            </p>
        </section><section>
            <h3>Definition</h3>
            <ul><li class="fragment">
                Variables: <span class="variable">v</span> :=
                "[^&#x03bb;.()\s]+"
            </li><li class="fragment">
                Expressions:
                <span class="expression">E</span> :=
                <span class="variable">v</span> |
                &#x03bb;<span class="variable"
                        >v</span>.<span class="expression">E</span> |
                <span class="expression">E</span>
                <span class="expression">E</span> |
                (<span class="expression">E</span>)
            </li><li class="fragment">
                Free Variables: FV[<span class="expression">E</span>]
                &#x2282; <span class="variable">v</span>
            </li><li class="fragment">
                Equivalence:
                b&#x2209;FV[<span class="expression">E</span>] &#x27f9;
                &#x03bb;a.<span class="expression">E</span> &#x2251;
                &#x03bb;b.(<span class="expression">E</span> [a := b])
            </li><li class="fragment">
                Reduction:
                (&#x03bb;a.<span class="expression">E</span>)
                <span class="expression">F</span> ... &#x25b7;
                <span class="expression">E</span>
                [a := <span class="expression">F</span>] ...
            </li></ul><p class="fragment">
                This is a complete description of lambda calculus.
            </p>
        </section><section>
            <h3>Variables</h3>
            <p>
                <span class="variable">a</span> := "[^&#x03bb;.()\s]+"
            </p><p>
                A variable is a sequence of characters excluding
                <q class="intro">&#x03bb;</q>, <q class="intro">.</q>,
                <q class="intro">(</q>, <q class="intro">)</q> and
                white space.  A single variable by itself is a valid
                expression.
            </p><p class="fragment">
                Examples: <span class="">a</span>,
                <span class="">b</span>,
                <span class="">c</span>,
                <span class="">MULTIPLY</span>,
                <span class="">172</span>,
                <span class="">IS-NIL?</span>,
                <span class="">@!</span>, ...
            </p>
        </section><section>
            <h3>Expressions</h3>
            <p>
                <span class="expression">E</span> :=
                <span class="variable">v</span> |
                &#x03bb;<span class="variable"
                        >v</span>.<span class="expression">E</span> |
                <span class="expression">E</span>
                <span class="expression">E</span> |
                (<span class="expression">E</span>)
            </p><ul><li class="fragment">
                Variable: <span class="variable">v</span>
            </li><li class="fragment">
                Abstraction:
                &#x03bb;<span class="variable"
                        >v</span>.<span class="expression">E</span>
            </li><li class="fragment">
                Application: <span class="expression">E</span>
                <span class="expression">E</span>
            </li><li class="fragment">
                Grouping: (<span class="expression">E</span>)
            </li></ul><p class="fragment">
                Expressions are left associative, so
                <span class="expression">E</span>
                <span class="expression">F</span>
                <span class="expression">G</span>
                is the same as
                (<span class="expression">E</span>
                <span class="expression">F</span>)
                <span class="expression">G</span>
                but not
                <span class="expression">E</span>
                (<span class="expression">F</span>
                <span class="expression">G</span>)
            </p>
        </section><section>
            <h3>Free Variables</h3>
            <p>
                Any variable not bound by an abstraction is free.
            </p><ul><li class="fragment">
                FV[a] &#x225d; {a}
            </li><li class="fragment">
                FV[&#x03bb;a.<span class="expression">E</span>] &#x225d;
                FV[<span class="expression">E</span>] - {a}
            </li><li class="fragment">
                FV[<span class="expression">E</span>
                <span class="expression">F</span>] &#x225d;
                FV[<span class="expression">E</span>] &cup;
                FV[<span class="expression">F</span>]
            </li><li class="fragment">
                FV[(<span class="expression">E</span>)] &#x225d;
                FV[<span class="expression">E</span>]
            </li></ul><p class="fragment">
                These rules cover all possible expressions.
            </p>
        </section>
        <section>
            <h3>Free Variables: Examples</h3>
            <ul><li class="fragment">
                FV[&#x03bb;a.a]
                <span class="fragment">= {a} - {a} = {}</span>
            </li><li class="fragment">
                FV[&#x03bb;a.b]
                <span class="fragment">= {b} - {a} = {b}</span>
            </li><li class="fragment">
                FV[(&#x03bb;b.b) b]
                <span class="fragment">= {} &cup; {b} = {b}</span>
            </li><li class="fragment">
                FV[(&#x03bb;a.a b) &#x03bb;b.c b c]
                <span class="fragment">= {b, c}</span>
            </li><li class="fragment">
                FV[&#x03bb;a.&#x03bb;b.b a]
                <span class="fragment">= {}</span>
            </li></ul>
        </section>
        <section>
            <h3>Substitution</h3>
            <p>
                Substitution replaces all instances of a free variable
                with an expression.
            </p><ul><li class="fragment">
                a [a := <span class="expression">G</span>] &#x225d;
                <span class="expression">G</span>
                <span class="fragment">
                    &and; b [a := <span class="expression">G</span>]
                    &#x225d; b
                </span>
            </li><li class="fragment">
                &#x03bb;a.<span class="expression">E</span>
                [a := <span class="expression">G</span>] &#x225d;
                &#x03bb;a.<span class="expression">E</span>
                <span class="fragment">
                    &and; <br />
                    &#x03bb;b.<span class="expression">E</span>
                    [a := <span class="expression">G</span>] &#x225d;
                    &#x03bb;b.(<span class="expression">E</span>
                    [a := <span class="expression">G</span>])
                </span>
            </li><li class="fragment">
                <span class="expression">E</span>
                <span class="expression">F</span>
                [a := <span class="expression">G</span>] &#x225d;
                <span class="expression">E</span>
                [a := <span class="expression">G</span>]
                <span class="expression">F</span>
                [a := <span class="expression">G</span>]
            </li><li class="fragment">
                (<span class="expression">E</span>)
                [a := <span class="expression">G</span>] &#x225d;
                (<span class="expression">E</span>
                [a := <span class="expression">G</span>])
            </li></ul>
        </section>
        <section>
            <h3>Equivalence</h3>
            <p>
                Replacing all occurances of a bound variable does not
                change the meaning of an expression unless it coincides
                with a free variable.
            </p><p>
                b&#x2209;FV[<span class="expression">E</span>] &#x27f9;
                &#x03bb;a.<span class="expression">E</span>
                &#x2251;
                &#x03bb;b.(<span class="expression">E</span> [a := b])
            </p>
        </section>
        <section>
            <h3>Equivalence: Examples</h3>
            <table><tr><td><ul><li class="fragment">
                &#x03bb;a.a &#x2251;
                <span class="true">&#x03bb;b.b</span>
            </li><li class="fragment">
                &#x03bb;a.c &#x2251;
                <span class="true">&#x03bb;b.c</span>
            </li><li class="fragment">
                &#x03bb;f.(&#x03bb;a.f (a a)) &#x03bb;a.f (a a)
                &#x2251; <br />
                <span class="true">
                    &#x03bb;g.(&#x03bb;b.g (b b)) &#x03bb;c.g (c c)
                </span>
            </li></ul></td><td><ul><li class="fragment">
                &#x03bb;a.b &ne;
                <span class="false">&#x03bb;a.c</span>
            </li><li class="fragment">
                &#x03bb;a.b &ne;
                <span class="false">&#x03bb;b.b</span>
            </li><li class="fragment">
                &#x03bb;a.&#x03bb;b.a &ne;
                <span class="false">&#x03bb;c.&#x03bb;b.a</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Reduction</h3>
            <p>
                Reduction replaces an abstraction followed by an
                expression with the body of the abstraction
                with the variable substited by the expression.
            </p><p>
                (&#x03bb;a.<span class="expression">E</span>)
                <span class="expression">F</span> ...
                <span class="fragment">
                    &#x25b7; <span class="expression">E</span>
                    [a := <span class="expression">F</span>] ...
                </span>
            </p>
        </section><section>
            <h3>Reduction: Examples</h3>
            <ul><li class="fragment">
                (&#x03bb;a.a) b
                <span class="fragment">
                    &#x25b7; a [a := b]
                </span><span class="fragment">
                    &#x25b7; b
                </span>
            </li><li class="fragment">
                (&#x03bb;a.a a) b c
                <span class="fragment">
                    &#x25b7; (a a [a := b]) c
                </span><span class="fragment">
                    &#x25b7; b b c
                </span>
            </li><li class="fragment">
                &#x03bb;a.(&#x03bb;b.b a) c
                <span class="fragment">
                    &#x25b7; &#x03bb;a.(b a [b := c])
                </span><span class="fragment">
                    &#x25b7; &#x03bb;a.c a
                </span>
            </li></ul>
        </section><section>
            <h3>Reduction: Free Variables</h3>
            <p>
                Free variables in the application must not match any
                bound variables in the abstraction.
            </p><p class="fragment">
                (&#x03bb;a.&#x03bb;b.a) b
                <span class="fragment false">
                    &#x25b7; &#x03bb;b.a [a := b]
                </span><span class="fragment false">
                    &#x25b7; &#x03bb;b.b
                </span>
            </p><p class="fragment">
                (&#x03bb;a.&#x03bb;c.a) b    
                <span class="fragment true">
                    &#x25b7; &#x03bb;c.a [a := b]
                </span><span class="fragment true">
                    &#x25b7; &#x03bb;c.b
                </span>
            </p><p class="fragment">
                We must use an equivalent expression instead.
            </p>
        </section>
        <section>
            <h3>Normal Form</h3>
            <p>
                An expression in normal cannot be reduced.
            </p><ul><li class="fragment">
                a <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                &#x03bb;a.a <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                a (&#x03bb;b.b) c <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                (&#x03bb;a.a) &#x03bb;b.&#x03bb;c.b
                <span class="fragment">
                    &#x25b7; a [a := &#x03bb;b.&#x03bb;c.b]
                </span><span class="fragment">
                    &#x25b7; &#x03bb;b.&#x03bb;c.b
                </span><span class="fragment">&#10003;</span>
            </li><li class="fragment">
                (&#x03bb;a.a) ((&#x03bb;b.b) &#x03bb;c.c)
                <span class="fragment">
                    &#x25b7; a [a := (&#x03bb;b.b) &#x03bb;c.c]
                </span><span class="fragment">
                    &#x25b7; <br />(&#x03bb;b.b) &#x03bb;c.c
                </span><span class="fragment">
                    &#x25b7; b [b := &#x03bb;c.c]
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.c
                </span><span class="fragment">&#10003;</span>
            </li></ul>
        </section>
        <section>
            <h3>Ad Infinitum</h3>
            <p>
                Not all expressions have a normal from.
            </p><p class="fragment">
                (&#x03bb;a.a a) &#x03bb;a.a a
                <span class="fragment">
                    &#x25b7; <br /> a a [a := &#x03bb;a.a a]
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">
                    &#x25b7; <br /> (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">&#x25b7; ...</span>
            </p>
        </section>
        <section>
            <h3>Normal Order</h3>
            <p>
                Normal order performs the outer most, left most
                reduction first when more than one are available.
            </p><ul><li class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; a a [a := ((&#x03bb;b.b) c)]
                </span>
            </li><li class="fragment">
                ((&#x03bb;b.b) c) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; b [b := c] ((&#x03bb;b.b) c)
                </span>
            </li><li class="fragment">
                c ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; c b [b := c]
                </span><span class="fragment">
                    &#x25b7; c c
                </span><span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                Normal order is guaranteed to reach a normal form
                for any expression if one exists.
            </p>
        </section>
        <section>
            <h3>Applicative Order</h3>
            <p>
                A disadvantage of normal form is that it can evaluate
                parts of an expression many times.  Applicative
                evaluation solves this problem.
            </p><ul><li class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; (&#x03bb;a.a a) b [b := c]
                </span>
            </li><li class="fragment">
                (&#x03bb;a.a a) c
                <span class="fragment">
                    &#x25b7; a a [a := c]
                </span><span class="fragment">
                    &#x25b7; c c
                </span><span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                Only two reductions were necessary.
            </p>
        </section>
        <section>
            <h3>A Little Too Eager</h3>
            <p>
                Sometimes applicative order fails...
            </p><p>
                (&#x03bb;a.&#x03bb;b.a) c
                ((&#x03bb;d.d d) &#x03bb;d.d d)
            </p><table class="large"><tr><td><ul class="fragment">
                Normal Order                
                <li class="fragment">
                    (&#x03bb;b.c) ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    c [b := ((&#x03bb;d.d d) &#x03bb;d.d d)]
                </li><li class="fragment">
                    c <span class="fragment">&#10003;</span>
                </li></ul>
            </td><td><ul class="fragment">
                Applicative Order
                <li class="fragment">
                    (&#x03bb;a.&#x03bb;b.a) c
                    ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    (&#x03bb;a.&#x03bb;b.a) c
                    ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    ...
                </li></ul>
            </td></tr></table><p class="fragment">
                Stable or efficient -- pick one!
            </p>
        </section><section>
            <h3>Lazy Order</h3>
            <p>
                Lazy evaluation is like normal order but it keeps
                of expressions so they're evaluated only once.
            </p><ul><li class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; a a [a := ((&#x03bb;b.b) c)]
                </span>
            </li><li class="fragment">
                ((&#x03bb;b.b) c) ((&#x03bb;b.b) c)
                <span class="fragment">&#x25b7; c c</span>
                <span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                This is the best of both worlds but may be tricky to
                implement.
            </p>
        </section><section>
            <h3>Currying</h3>
            <p>
                All abstractions accept a single variable (Frege 1893
                CE).  Additional variables are nested:
                &#x03bb;a.&#x03bb;b.<span class="expression">E</span>
            </p><ul><li class="fragment">
                (&#x03bb;a.&#x03bb;b.<span class="expression">E</span>)
                <span class="expression">F</span>
                <span class="expression">G</span>
                <span class="fragment">
                    &#x25b7;
                    (&#x03bb;b.<span class="expression">E</span>
                    [a := <span class="expression">F</span>])
                    <span class="expression">G</span>
                </span><span class="fragment">
                    &#x25b7; <br /> <span class="expression">E</span>
                    [a := <span class="expression">F</span>,
                    b := <span class="expression">G</span>]
                </span>
            </li><li class="fragment">
                (&#x03bb;a.&#x03bb;b.<span class="expression">E</span>)
                <span class="expression">F</span>
                <span class="fragment">
                    &#x25b7;
                    &#x03bb;b.<span class="expression">E</span>
                    [a := <span class="expression">F</span>]
                </span>
            </li></ul><p class="fragment">
                Supplying some but not all arguments is allowed.
            </p>
        </section><section>
            <h3>Multi-Argument Notation</h3>
            <p>
                There is a convenient short hand for nested
                abstractions.
            </p><p>
                <span class="intro">&#x03bb;a
                    b.</span><span class="expression">E</span> &#x225d;
                &#x03bb;a.&#x03bb;b.<span class="expression">E</span>
            </p><p class="fragment">
                <span class="intro">&#x03bb;a b
                    c.<span class="expression">E</span></span> &#x225d;
                &#x03bb;a.&#x03bb;b.&#x03bb;c.<span class="expression"
                                              >E</span>
            </p><p class="fragment">
                And so on for more arguments...
            </p>
        </section><section>
            <h3>Lambda Calculus</h3>
            <ul><li>
                Variables: <span class="variable">v</span> :=
                "[^&#x03bb;.()\s]+"
            </li><li>
                Expressions:
                <span class="expression">E</span> :=
                <span class="variable">v</span> |
                &#x03bb;<span class="variable"
                        >v</span>.<span class="expression">E</span> |
                <span class="expression">E</span>
                <span class="expression">E</span> |
                (<span class="expression">E</span>)
            </li><li>
                Free Variables: FV[<span class="expression">E</span>]
                &#x2282; <span class="variable">v</span>
            </li><li>
                Equivalence:
                b&#x2209;FV[<span class="expression">E</span>] &#x27f9;
                &#x03bb;a.<span class="expression">E</span> &#x2251;
                &#x03bb;b.(<span class="expression">E</span> [a := b])
            </li><li>
                Reduction:
                (&#x03bb;a.<span class="expression">E</span>)
                <span class="expression">F</span> ... &#x25b7;
                <span class="expression">E</span>
                [a := <span class="expression">F</span>] ...
            </li></ul><p>
                Notation: &#x03bb;a
                b.</span><span class="expression">E</span> &#x225d;
                &#x03bb;a.&#x03bb;b.<span class="expression">E</span>
            </p>
        </section><section>
            <h3>Lambda Playground</h3>
            <div class="lambda"></div>
            <p>Not yet <a href="../apps/lambda">integrated</a>...</p>
        </section>
    </section><section>
        <section>
            <h2>Lambda Computation</h2>
            <p>
                Lambda calculus is certainly simple.  But isn't it
                supposed to be universal?  There's no boolean logic,
                no numbers, no recursion and no data structures.
            </p><p>
                We can construct these using combinators.
            </p>
        </section><section>
            <h3>Combinators</h3>
            <p>
                A combinator is an abstraction with no free variables.
                As a consequence they have no state or external
                interactions.
            </p><p>
                FV[&#x03bb;<span class="variable"
                           >v</span>.<span class="expression">E</span>]
                = {}
            </p>
        </section><section>
            <h3>Combinator Birds</h3>
            <p>
                Raymond Smullyan wrote a book about combinatory logic
                titled
                <a href="https://en.wikipedia.org/wiki/To_Mock_a_Mockingbird">
                    To Mock a Mockingbird</a>.
                Giving names to combinators helps us to remember them.
            </p>
        </section>
        <section>
            <h3>Meet the Birds</h3>
            <ul><li class="fragment">
                Ibis (Identity): &#x03bb;a.a
            </li><li class="fragment">
                Mockingbird (Self-Apply): &#x03bb;a.a a
            </li><li class="fragment">
                Kestral (True/Const): &#x03bb;a b.a
            </li><li class="fragment">
                Kite (False/Zero): &#x03bb;a b.b
            </li><li class="fragment">
                Cardinal (Flip/Not): &#x03bb;a b c.a c b
            </li><li class="fragment">
                Bluebird (Compose):
                &#x03bb;a b c.a (b c)
            </li><li class="fragment">
                Thrush (Power): &#x03bb;a b.b a
            </li><li class="fragment">
                Vireo (Pair): &#x03bb;a b c.c a b
            </li><li class="fragment">
                Blackbird:
                &#x03bb;a b c d.a (b c d)
            </li><li class="fragment">
                Starling: &#x03bb;a b c.a c (b c)
            </li></ul>
        </section><section>
            <h3>Combinator Booleans</h3>
            <p>
                One thing we might want to compute is boolean logic.
                Everything must evaluate to true or false.  How could
                we represent these in lambda calculus?
            </p>
            <ul><li class="fragment">
                <span class="true">TRUE</span>[Kestral]: &#x03bb;a b.a
            </li><li class="fragment">
                <span class="false">FALSE</span>[Kite]: &#x03bb;a b.b
            </li></ul>
        </section><section>
            <h3>Conditional Statements</h3>
            <p>
                IF p THEN ELSE
            </p><ul><li class="fragment">
                (&#x03bb;p a b.p a b) p THEN ELSE
                <span class="fragment">&#x25b7;
                    p THEN ELSE
                </span>
            </li><li class="fragment">
                TRUE THEN ELSE
                <span class="fragment">
                    &#x25b7; (&#x03bb;a b.a) THEN ELSE
                </span><span class="fragment">
                    &#x25b7; THEN
                </span>
            </li><li class="fragment">
                FALSE THEN ELSE
                <span class="fragment">
                    &#x25b7; (&#x03bb;a b.b) THEN ELSE
                </span><span class="fragment">
                    &#x25b7; ELSE
                </span>
            </li></ul><p class="fragment">
                We don't need a condtional combinator.
            </p>
        </section><section>
            <h3>Combinator NOT</h3>
            <p>
                NOT [Cardinal]: &#x03bb;p a b.p b a
            </p><table><tr><td><ul><li class="fragment">
                NOT TRUE
            </li><li class="fragment">
                &#x03bb;a b.TRUE b a
            </li><li class="fragment">
                &#x03bb;a b.b
                <span class="fragment">&#x25b7; FALSE</span>
            </li></ul></td><td><ul><li class="fragment">
                NOT FALSE
            </li><li class="fragment">
                &#x03bb;a b.FALSE b a
            </li><li class="fragment">
                &#x03bb;a b.a
                <span class="fragment">&#x25b7; TRUE</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator AND</h3>
            <p>
                AND: &#x03bb;p q.p q p
            </p><table><tr><td><ul><li class="fragment">
                AND TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                AND TRUE FALSE
            </li><li class="fragment">
                TRUE FALSE TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                AND FALSE TRUE
            </li><li class="fragment">
                FALSE TRUE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td><td><ul><li class="fragment">
                AND FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator OR</h3>
            <p>
                OR: &#x03bb;p q.p p q
            </p><table><tr><td><ul><li class="fragment">
                OR TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                OR TRUE FALSE
            </li><li class="fragment">
                TRUE TRUE FALSE
            </li><li class="fragment">
                TRUE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                OR FALSE TRUE
            </li><li class="fragment">
                FALSE FALSE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                OR FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator Booleans</h3>
            <p>
                BOOLEQ?: &#x03bb;p q.p q (NOT q)
            </p><table class="large"><tr><td><ul><li class="fragment">
                BOOLEQ? TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE (NOT TRUE)
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                BOOLEQ? TRUE FALSE
            </li><li class="fragment">
                TRUE FALSE (NOT FALSE)
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                BOOLEQ? FALSE TRUE
            </li><li class="fragment">
                FALSE TRUE (NOT TRUE)
            </li><li class="fragment">
                NOT TRUE
                <span class="fragment">&#x25b7; FALSE</span>
            </li></ul></td><td><ul><li class="fragment">
                BOOLEQ? FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE (NOT FALSE)
            </li><li class="fragment">
                NOT FALSE
                <span class="fragment">&#x25b7; TRUE</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator Booleans</h3>
            <ul><li>
                TRUE[Kestral]: &#x03bb;a b.a
            </li><li>
                FALSE[Kite]: &#x03bb;a b.b
            </li><li>
                NOT[Cardinal]: &#x03bb;p a b.p b a
            </li><li>
                AND: &#x03bb;p q.p q p
            </li><li>
                OR: &#x03bb;p q.p p q
            </li><li>
                BOOLEQ?: &#x03bb;p q.p q (NOT q)
            </li></ul>
        </section><section>
            <h3>Combinator Numbers</h3>
            <p>
                Church Numerals represent numbers by repeatedly
                applying a first argument a second.
            </p><ul><li class="fragment">
                ONE: &#x03bb;f a.f a
            </li><li class="fragment">
                TWO: &#x03bb;f a.f (f a)
            </li><li class="fragment">
                THREE: &#x03bb;f a.f (f (f a))
            </li><li class="fragment">
                ...
            </li></ul>
        </section><section>
            <h3>Combinator Successors</h3>
            <p>
                Natural numbers include zero and its successors.
            </p><p class="fragment">
                ZERO <span class="fragment">[Kite/FALSE]</span>:
                &#x03bb;f a.a
            </p><p class="fragment">
                SUCCESSOR: &#x03bb;n f a.f (n f a)
            </p>
        </section><section>
            <h3>Combinator Successors</h3>
            <table><tr><td><ul><li class="fragment">
                SUCCESSOR ZERO
            </li><li class="fragment">
                &#x03bb;f a.f (ZERO f a)
            </li><li class="fragment">
                &#x03bb;f a.f a <span class="fragment">[ONE]</span>
            </li></ul></td><td><ul><li class="fragment">
                SUCCESSOR ONE
            </li><li class="fragment">
                &#x03bb;f a.f (ONE f a)
            </li><li class="fragment">
                &#x03bb;f a.f (f a) <span class="fragment">[TWO]</span>
            </li></ul></td></tr></table><p class="fragment">
                And so on.
            </p>
        </section><section>
            <h3>Combinator Addition</h3>
            <p>
                Take the successor repeatedly to add:
            </p><p>
                ADD: &#x03bb;m n.n SUCCESSOR m
            </p><ul><li class="fragment">
                ADD THREE TWO
            </li><li class="fragment">
                TWO SUCCESSOR THREE
            </li><li class="fragment">
                SUCCESSOR (SUCCESSOR THREE)
            </li><li class="fragment">
                SUCCESSOR FOUR
            </li><li class="fragment">
                FIVE
            </li></ul>
        </section><section>
            <h3>Combinator Multiplication</h3>
            <p>
                Compose numbers to multiply:
            </p><p>
                MULTIPLY [Bluebird]: &#x03bb;m n f.m (n f)
            </p><ul><li class="fragment">
                MULTIPLY THREE TWO
            </li><li class="fragment">
                &#x03bb;f.THREE (TWO f)
            </li><li class="fragment">
                &#x03bb;f.(&#x03bb;f a.f (f (f a)))
                ((&#x03bb;f a.f (f a)) f)
            </li><li class="fragment">
                &#x03bb;f.(&#x03bb;f a.f (f (f a))) (&#x03bb;a.f (f a))
            </li><li class="fragment">
                &#x03bb;f.&#x03bb;a.f (f (f (f (f (f a)))))
            </li><li class="fragment">
                &#x03bb;f a.f (f (f (f (f (f a)))))
                <span class="fragment">[SIX]</span>
            </li></ul>
        </section><section>
            <h3>Combinator Exponentiation</h3>
            <p>
                Raise one number to the power of another:
            </p><p>
                POWER [Thrush]: &#x03bb;n m.m n
            </p><ul><li class="fragment">
                POWER THREE TWO
            </li><li class="fragment">
                TWO THREE
            </li><li class="fragment">
                (&#x03bb;f a.f (f a)) &#x03bb;f a.f (f (f a))
            </li><li class="fragment">
                ...
            </li><li class="fragment">
                &#x03bb;f a.f (f (f (f (f (f (f (f (f a))
                <span class="fragment">[NINE]</span>
            </li></ul>
        </section><section>
            <h3>Combinator Numbers</h3>
            <ul><li>
                ZERO [Kite/FALSE]: &#x03bb;f a.a
            </li><li>
                SUCCESSOR: &#x03bb;n f a.f (n f a)
            </li><li>
                ADD: &#x03bb;m n.n SUCCESSOR m
            </li><li>
                MULTIPLY [Bluebird]: &#x03bb;m n f.m (n f)
            </li><li>
                POWER [Thrush]: &#x03bb;n m.m n
            </li></ul>
        </section><section>
            <h3>Combinator Subtraction</h3>
            <p>
                Subtraction is addition reversed.
            </p><p class="fragment">
                SUBTRACT: &#x03bb;m n.n PREDECESSOR m
            </p><p class="fragment">
                PREDECESSOR: &#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)
            </p>
        </section><section>
            <h3>Combinator Subtraction</h3>
            <p>
                PREDECESSOR TWO
            </p><ul><li class="fragment">
                (&#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)) &#x03bb;f a.f (f a)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;f a.f (f a)) (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;g h.h (g f)) ((&#x03bb;g h.h (g f))
                (&#x03bb;c.a)) (&#x03bb;b.b)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;h.h (((&#x03bb;g h.h (g f))
                (&#x03bb;c.a)) f)) (&#x03bb;b.b)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;b.b) (((&#x03bb;g h.h (g f))
                (&#x03bb;c.a)) f)
            </li><li class="fragment">
                &#x03bb;f a.((&#x03bb;g h.h (g f))
                (&#x03bb;c.a)) f
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;h.h ((&#x03bb;c.a) f)) f
            </li><li class="fragment">
                &#x03bb;f a.f ((&#x03bb;c.a) f)
                <span class="fragment">
                    &#x25b7; &#x03bb;f a.f a
                </span><span class="fragment">
                    &#x25b7; ONE
                </span>
            </li></ul>
        </section><section>
            <h3>Combinator Subtraction</h3>
            <p>
                PREDECESSOR ONE
            </p><ul><li class="fragment">
                (&#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)) &#x03bb;f a.f a
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;f a.f a) (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;h.h ((&#x03bb;c.a) f))
                (&#x03bb;b.b)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;b.b) ((&#x03bb;c.a) f)
            </li><li class="fragment">
                &#x03bb;f a.((&#x03bb;c.a) f)
                <span class="fragment">
                    &#x25b7; &#x03bb;f a.a
                </span><span class="fragment">
                    &#x25b7; ZERO
                </span>
            </li></ul>
        </section><section>
            <h3>Combinator Subtraction</h3>
            <p>
                PREDECESSOR ZERO
            </p><ul><li class="fragment">
                (&#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)) &#x03bb;f a.a
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;f a.a) (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;c.a) (&#x03bb;b.b)
                <span class="fragment">
                    &#x25b7; &#x03bb;f a.a
                </span><span class="fragment">
                    &#x25b7; ZERO
                </span>
            </li></ul><p class="fragment">
                Zero is its own predecessor.  This isn't mathematically
                accurate but it will prove useful.
            </p>
        </section><section>
            <h3>Combinator Division</h3>
            <p>
                Division is multiplication reversed.
            </p><p class="fragment">
                DIVIDE: &#x03bb;n.((&#x03bb;f.(&#x03bb;x.x x)
                (&#x03bb;x.f (x x)))
                (&#x03bb;c n m f x.
                (&#x03bb;d.(&#x03bb;n.n
                (&#x03bb;x a b.b)
                (&#x03bb;a b.a)) d
                ((&#x03bb;f x) f x) (f (c d m f x)))
                ((&#x03bb;m n.n
                (&#x03bb;n f x.n
                (&#x03bb;g h.h (g f)) (&#x03bb;u.x)
                (&#x03bb;u.u)) m) n m)))
                ((&#x03bb;n f x.f (n f x)) n)
            </p><p class="fragment">
                Any questions?  Of course not.  Moving on...
            </p>
        </section><section>
            <h3>Combinator Zero Test</h3>
            <p>
                We can ask questions about numbers:
            </p><p>
                IS-ZERO?: &#x03bb;n.n (&#x03bb;a.FALSE) TRUE
            </p><table class="large"><tr><td><ul><li class="fragment">
                IS-ZERO? ZERO
            </li><li class="fragment">
                ZERO (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                (&#x03bb;f a.a) (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                IS-ZERO? ONE
            </li><li class="fragment">
                (&#x03bb;f a.f a) (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table><p class="fragment">
                What happens if we ask about a successor of one?
            </p>
        </section><section>
            <h3>Combinator Even</h3>
            <p>
                How can we ask whether a number is even?
            </p><p class="fragment">
                IS-EVEN?: &#x03bb;n.n NOT TRUE
            </p><table class="xlarge"><tr><td><ul><li class="fragment">
                IS-EVEN? ZERO
            </li><li class="fragment">
                ZERO NOT TRUE
            </li><li class="fragment">
                (&#x03bb;f a.a) NOT TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                IS-EVEN? ONE
            </li><li class="fragment">
                (&#x03bb;f a.f a) NOT TRUE
            </li><li class="fragment">
                NOT TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td><td><ul><li class="fragment">
                IS-EVEN? TWO
            </li><li class="fragment">
                (&#x03bb;f a.f (f a)) NOT TRUE
            </li><li class="fragment">
                NOT (NOT TRUE)
            </li><li class="fragment">
                TRUE
            </li></ul></td></tr></table><p class="fragment">
                How could we define IS-ODD?
            </p>
        </section><section>
            <h3>Combinator Comparisons</h3>
            <ul><li class="fragment">
                LESSEQ?: &#x03bb;n m.IS-ZERO? (SUBTRACT n m)
            </li><li class="fragment">
                GREATEREQ?: &#x03bb;n m.IS-ZERO? (SUBTRACT m n)
            </li><li class="fragment">
                EQUAL?: &#x03bb;n m.AND (LESSEQ? n m) (LESSEQ? m n)
            </li><li class="fragment">
                LESS?: &#x03bb;n m.NOT (GREATEREQ? n m)
            </li><li class="fragment">
                GREATER?: &#x03bb;n m.NOT (LESSEQ? n m)
            </li></ul>
        </section><section id="loops">
            <h3>Combinator Loops</h3>
            <p>See <a href="#recursion">recursion</a>.</p>
        </section><section id="recursion">
            <h3>Combinator Recursion</h3>
            <p>See <a href="#loops">loops</a>.</p>
        </section><section>
            <h3>Combinator Flow</h3>
            <p>
                While Church Numerals make it easy to create a loop
                with a fixed count we have no way to perform a
                computation until some condition is met.  That's an
                important gap in our programming ability.
            </p>
        </section><section>
            <h3>Combinator Recursion</h3>
            <p>
                Functions have no names in lambda calculus but
                we can still implement recursion using a combinator:
            </p><ul><li class="fragment">
                Y &#x225d; &#x03bb;f.(&#x03bb;a.f (a a))
                &#x03bb;a.f (a a)
            </li><li class="fragment">
                Y g
                <span class="fragment">
                    = (&#x03bb;a.g (a a))
                    &#x03bb;a.g (a a)
                </span>
            </li><li class="fragment">
                Y g = g ((&#x03bb;a.g (a a)) &#x03bb;a.g (a a))
            </li><li class="fragment">
                Y g = g (Y g)
                <span class="fragment">
                    = g (g (Y g))
                </span><span class="fragment">
                    = g (g (g (Y g)))
                </span><span class="fragment">
                    = ...
                </span>
            </li></ul>
        </section><section>
            <h3>Factorial</h3>
            <p>
                FSTEP: (&#x03bb;f n.(IS-ZERO? n) ONE <br />
                (MULTIPLY n (f (PREDECESSOR n))))
            </p><p class="fragment">
                FACTORIAL &#x225d; Y FSTEP
            </p>
        </section><section>
            <h3>Factorial</h3>
            <p>
                FACTORIAL ONE
                <span class="fragment"> &#x225d; Y FSTEP ONE</span>
    </li><li class="fragment">
        Y FSTEP ONE &#x25b7; FSTEP (Y FSTEP) ONE
    </li><li class="fragment">
        (IS-ZERO? ONE) ONE <br />
        (MULTIPLY ONE (Y FSTEP (PREDECESSOR ONE)))
    </li><li class="fragment">
        MULTIPLY ONE (Y FSTEP (PREDECESSOR ONE))
    </li><li class="fragment">
        MULTIPLY ONE (FSTEP (Y FSTEP) ZERO)
    </li><li class="fragment">
        MULTIPLY ONE ONE &#x25b7; ONE
    </li></ul>
        </section><section>
            <h3>Combinator Ordered Pairs</h3>
            <p>
                We can take advantage of closure to store values.
            </p><ul><li class="fragment">
                PAIR[Verio]: &#x03bb;a b f.f a b
            </li><li class="fragment">
                HEAD: &#x03bb;p.p TRUE
            </li><li class="fragment">
                TAIL: &#x03bb;p.p FALSE
            </li></ul><p class="fragment">
                This will serve as a foundation for data structures.
            </p>
        </section><section>
            <h3>Combinator Ordered Pairs</h3>
            <p>
                How does this work in practice?
            </p><ul><li class="fragment">
                PAIR FIRST LAST
                <span class="fragment">
                    &#x25b7; (&#x03bb;a b f.f a b) FIRST LAST
                </span><span class="fragment">
                    &#x25b7; <br />(&#x03bb;b f.f FIRST b) LAST
                </span><span class="fragment">
                    &#x25b7; &#x03bb;f.f FIRST LAST
                </span>
            </li><li class="fragment">
                HEAD (PAIR FIRST LAST)
                <span class="fragment">
                    &#x25b7; <br />
                    (&#x03bb;p.p TRUE) &#x03bb;f.f FIRST LAST
                </span><span class="fragment">
                    &#x25b7; <br />(&#x03bb;f.f FIRST LAST) TRUE
                </span><span class="fragment">
                    &#x25b7; <br />TRUE FIRST LAST
                </span><span class="fragment">
                    &#x25b7; FIRST
                </span>
            </li><li class="fragment">
                TAIL (PAIR FIRST LAST)
                <span class="fragment">
                    &#x25b7; <br />FALSE FIRST LAST
                </span><span class="fragment">
                    &#x25b7; LAST
                </span>
            </li></ul>
        </section><section>
            <h3>Combinator Lists</h3>
            <p>
                Chaining ordered pairs together to make lists requires
                a way to find the end.
            </p><ul><li class="fragment">
                IS-NIL?: &#x03bb;p.p &#x03bb;a b.FALSE
            </li><li class="fragment">
                NIL: &#x03bb;f.TRUE
            </li></ul>
        </section><section>
            <h3>Combinator Lists</h3>
            <p>
                IS-NIL? NIL
            </p><ul><li class="fragment">
                (&#x03bb;p.p &#x03bb;a b.FALSE) &#x03bb;f.TRUE
            </li><li class="fragment">
                (&#x03bb;f.TRUE) &#x03bb;a b.FALSE
                <span class="fragment">&#x25b7; TRUE</span>
            </li></ul>
        </section><section>
            <h3>Combinator Lists</h3>
            <p>
                IS-NIL? (PAIR FIRST LAST)
            </p><ul><li class="fragment">
                (&#x03bb;p.p &#x03bb;a b.FALSE) (PAIR FIRST LAST)
            </li><li class="fragment">
                (PAIR FIRST LAST) &#x03bb;a b.FALSE
            </li><li class="fragment">
                (&#x03bb;f.f FIRST LAST) &#x03bb;a b.FALSE
            </li><li class="fragment">
                (&#x03bb;a b.FALSE) FIRST LAST
                <span class="fragment">&#x25b7; FALSE</span>
            </li></ul>
        </section><section>
            <h3>Combinator Lists</h3>
            <p>
                Now we can construct lists of arbitrary length.
            </p><ul><li class="fragment">
                PAIR ONE NIL
            </li><li class="fragment">
                PAIR ONE (PAIR TWO NIL)
            </li><li class="fragment">
                PAIR ONE (PAIR TWO (PAIR THREE NIL))
            </li><li class="fragment">
                ...
            </li></ul><p class="fragment">
                So how do we work with these?
            </p>
        </section><section>
            <h3>Combinator Select</h3>
            <p>
                We can traverse a list using Church numerals.
            </p><p>
                NTH: &#x03bb;n l.n (&#x03bb; l.(IS-NIL? l)
                NIL (TAIL l)) l
            </p><ul><li class="fragment">
                NTH 1 (PAIR FIRST (PAIR SECOND (PAIR THIRD)))
            </li><li class="fragment">
                &#x25b7; ONE (&#x03bb; l.(IS-NIL? l)
                NIL (TAIL l)) (PAIR ...)
            </li><li class="fragment">
                &#x25b7; (&#x03bb; l.(IS-NIL? l)
                NIL (TAIL l)) (PAIR ...)
            </li><li class="fragment">
                &#x25b7; (IS-NIL? (PAIR ...))
                NIL (TAIL (PAIR ...))
            </li><li class="fragment">
                &#x25b7; TAIL (PAIR ...)
            </li></ul><p class="fragment">
                An index beyond the end of the list will give NIL
            </p>
        </section><section>
            <h3>Combinator Sums</h3>
            <p>
                Let's add up a list of numbers.
            </p><ul><li class="fragment">
                SUM (PAIR ONE (PAIR TWO (PAIR THREE NIL)))
            </li><li class="fragment">
                SUM = Y (&#x03bb;f l.(IS-NIL? l) ZERO <br />
                (ADD (HEAD l) (f (TAIL l))))
            </li><li class="fragment">
                ADD ONE (ADD TWO (ADD THREE ZERO))
                <span class="fragment">
                    &#x25b7; SIX
                </span>
            </li></ul>
        </section><section>
            <h3>Combinator Map</h3>
            <p>
                We can apply a function to every member of a list
            </p><ul><li class="fragment">
                MAP = Y (&#x03bb;f g l.(IS-NIL? l) NIL <br />
                (PAIR (g (HEAD l)) (f g (TAIL l))))
            </li><li class="fragment">
                MAP (&#x03bb;n.ADD n n) <br />
                (PAIR ONE (PAIR TWO (PAIR THREE NIL)))
            </li><li class="fragment">
                PAIR TWO (PAIR FOUR (PAIR SIX NIL))
            </li></ul>
        </section><section>
            <h3>Combinator Data Structures</h3>
            <ul><li>
                PAIR[Verio]: &#x03bb;a b f.f a b
            </li><li>
                HEAD: &#x03bb;p.p TRUE
            </li><li>
                TAIL: &#x03bb;p.p FALSE
            </li><li>
                NIL: &#x03bb;f.TRUE
            </li><li>
                IS-NIL?: &#x03bb;p.p &#x03bb;a b.FALSE
            </li></ul>
        </section><section>
            <h3>Combinator Integers</h3>
            <p>
                How can we construct an integer?  Consider a pair of
                Church numerals.  If we interpret them as a subtraction
                we can represent any integer value.
            </p><p class="fragment">
                INT-CREATE: PAIR n m
            </p><p class="fragment">
                This represents the integer <em>n - m</em>
            </p>
        </section><section>
            <h3>Combinator Integers</h3>
            <p>
                Here are some simple tools for integers.
            </p><ul><li class="fragment">
                INT-IS-ZERO?: &#x03bb;n.EQUAL? (HEAD n) (TAIL n)
            </li><li class="fragment">
                INT-EQUAL?: &#x03bb;n m.EQUAL? <br />
                (ADD (HEAD n) (TAIL m))
                (ADD (HEAD m) (TAIL n))
            </li><li class="fragment">
                INT-NEGATE: &#x03bb;n.PAIR (TAIL n) (HEAD n)
            </li></ul>
        </section><section>
            <h3>Combinator Integers</h3>
            <p>
                Integer arithmetic is messy but straightforward.
            </p><ul><li class="fragment">
                INT-ADD: &#x03bb;n m.PAIR (ADD (HEAD n) (HEAD m))
                <br />(ADD (TAIL n) (TAIL m))
            </li><li class="fragment">
                INT-MULTIPLY: &#x03bb;n m.PAIR <br />
                (ADD (MULTIPLY (HEAD n) (HEAD m))<br />
                (MULTIPLY (TAIL n) (TAIL m)))<br />
                (ADD (MULTIPLY (HEAD n) (TAIL m))<br />
                (MULTIPLY (TAIL n) (HEAD m)))
            </li></ul>
        </section><section>
            <h3>Combinator Rationals</h3>
            <p>
                How can we represent rational numbers?  Consider
                an pair of integers.  If we interpret this as a
                division we can represent any rational number.
            </p><p class="fragment">
                RATIONAL-CREATE: PAIR a b
            </p><p class="fragment">
                This represents the rational number <em>a / b</em>
            </p>
        </section><section>
            <h3>Combinator Rationals</h3>
            <p>
                Here are some simple tools for rational numbers.
            </p><ul><li class="fragment">
                RATIONAL-IS-ZERO?: &#x03bb;a.INT-IS-ZERO? (HEAD a)
            </li><li class="fragment">
                RATIONAL-EQUAL?: &#x03bb;a b.EQUAL? <br />
                (INT-MULTIPLY (HEAD a) (TAIL b)) <br />
                (INT-MULTIPLY (HEAD b) (TAIL a))
            </li><li class="fragment">
                RATIONAL-NEGATE: &#x03bb;a.PAIR <br />
                (INT-NEGATE (HEAD a)) (TAIL a)
            </li><li class="fragment">
                RATIONAL-INVERSE: &#x03bb;a.PAIR (TAIL a) (HEAD a)
            </li></ul>
        </section><section>
            <h3>Combinator Rationals</h3>
            <p>
                And of course we can add and multiply.
            </p><ul><li class="fragment">
                RATIONAL-ADD: &#x03bb;n m.PAIR <br />
                (INT-ADD (INT-MULTIPLY (HEAD n) (TAIL m)) <br />
                (INT-MULTIPLY (HEAD m) (TAIL n))) <br />
                (INT-MULTIPLY (TAIL n) (TAIL m))
            </li><li class="fragment">
                RATIONAL-MULTIPLY: &#x03bb;n m.PAIR <br />
                (INT-MULTIPLY (HEAD m) (TAIL n))) <br />
                (INT-MULTIPLY (TAIL n) (TAIL m))
            </li></ul>
        </section><section>
            <h3>Lambda Computation</h3>
            <ul><li>
                Booleans: &#x03bb;a b.a, &#x03bb;a b.b
            </li><li>
                Numbers: &#x03bb;f a.a, &#x03bb;n f a.f (n f a)
            </li><li>
                Arithmetic: &#x03bb;m n.n (&#x03bb;n f a.f (n f a)) m
            </li><li>
                Recursion: &#x03bb;f.(&#x03bb;a.f (a a))
                &#x03bb;a.f (a a)
            </li><li>
                Data Structures: &#x03bb;a b f.f a b
            </li></ul><p>
                Lambda calculus simple, compact and universal.
            </p>            
        </section>
    </section><section>
        <section>
            <h3>Starling and Kestral</h3>
            <p>
                The Starling and Kestral combinators are universal
                (Schönfinkel 1924 CE).
                Like lambda calculus and Turing machines they can
                compute any computable function.
            </p><ul><li>
                Starling (S): &#x03bb;a b c.a c (b c)
            </li><li>
                Kestral (K): &#x03bb;a b.a
            </li></ul>
        </section><section>
            <h3>Simplification: Identity</h3>
            <p>
                We can simplify some Starling and Kestral combinations.
            </p><ul><li class="fragment">
                S K X
            </li><li class="fragment">
                (&#x03bb;a b c.a c (b c)) K X
                <span class="fragment">
                    &#x25b7; (&#x03bb;b c.K c (b c)) X
                </span>
            </li><li class="fragment">
                &#x25b7; &#x03bb;c.K c (X c)
                <span class="fragment">
                    &#x25b7; &#x03bb;c.(&#x03bb;a b.a) c (X c)
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.c
                </span>
            </li></ul><p class="fragment">
                S K K
                <span class="fragment">
                    = S K S
                </span><span class="fragment">
                    = S K (anything)
                </span><span class="fragment">
                    = I
                </span>
            </p>
        </section><section>
            <h3>Simplification: Kestral</h3>
            <p>
                We can simplify some Starling and Kestral combinations.
            </p><p class="fragment">
                S (K K) I <span class="fragment">= K</span>
            </p><ul><li class="fragment">
                (&#x03bb;a b c.a c (b c)) (K K) I
                <span class="fragment">
                    &#x25b7; (&#x03bb;b c.(K K) c (b c))  I
                </span>
            </li><li class="fragment">
                &#x25b7; &#x03bb;c.(K K) c
                (<span class="intro">I c</span>)
                <span class="fragment">
                    &#x25b7; &#x03bb;c.<span class="intro">K
                    K c</span> c
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.K c
                </span>
            </li><li class="fragment">
                &#x25b7; &#x03bb;c.(&#x03bb;a b.a) c
                <span class="fragment">
                    &#x25b7; &#x03bb;c.&#x03bb;b.c
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c b.c
                </span><span class="fragment">
                    &#x25b7; K
                </span>
            </li></ul>
        </section><section>
            <h3>Converting Lambda</h3>
            <p>
                Any lambda term
                <a href="https://en.wikipedia.org/wiki/Combinatory_logic">
                    can be converted</a>.
            </p><ul><li class="fragment">
                T[a] &#x27f9;  a
            </li><li class="fragment">
                T[<span class="expression">E</span>
                <span class="expression">F</span>] &#x27f9;
                T[<span class="expression">E</span>]
                T[<span class="expression">F</span>]
            </li><li class="fragment">
                T[(<span class="expression">E</span>)] &#x27f9;
                (T[<span class="expression">E</span>])
            </li><li class="fragment">
                T[&#x03bb;a.<span class="expression">E</span>]
                &and; a&#x2209;FV[<span class="expression">E</span>]
                &#x27f9; K T[<span class="expression">E</span>]
            </li><li class="fragment">
                T[&#x03bb;a.a] &#x27f9; S K K
                <span class="fragment">&#x27f9; I</span>
            </li><li class="fragment">
                T[&#x03bb;a.&#x03bb;b.<span class="expression">E</span>]
                &and; a&#x2208;FV[<span class="expression">E</span>]
                &#x27f9; T[&#x03bb;a.T[&#x03bb;b.<span class="expression"
                                                 >E</span>]]
            </li><li class="fragment">
                T[&#x03bb;a.<span class="expression">E</span>
                <span class="expression">F</span>]
                &and; a&#x2208;(FV[<span class="expression">E</span>] &cup;
                FV[<span class="expression">F</span>])
                &#x27f9; S T[&#x03bb;a.<span class="expression">E</span>]
                T[&#x03bb;a.<span class="expression">F</span>]]
            </li></ul>
        </section><section>
            <h3>Conversion: Thrush</h3>
            <p>
                Thrush: &#x03bb;a b.b a
            </p><ul><li class="fragment">
                T[&#x03bb;a b.b a]
                <span class="fragment">
                    &#x27f9;
                    T[&#x03bb;a.T[&#x03bb;b.b a]]
                </span>
            </li><li class="fragment">
                T[&#x03bb;a.S T[&#x03bb;b.b] T[&#x03bb;b.a]]
            </li><li class="fragment">
                T[&#x03bb;a.S I (K a)]
            </li><li class="fragment">
                S T[&#x03bb;a.(S I)] T[&#x03bb;a.K a]
            </li><li class="fragment">
                S (K (S I)) (S T[&#x03bb;a.K] T[&#x03bb;a.a])
            </li><li class="fragment">
                S (K (S I)) (S (K K) I)
            </li><li class="fragment">
                S (K (S I)) K
            </li></ul>
        </section><section>
            <h3>Other Combinators</h3>
            <ul><li class="fragment">
                Ibis: I = S K K = S K S
            </li><li class="fragment">
                Mockingbird: M = S I I
            </li><li class="fragment">
                Kite: Ki = K I
            </li><li class="fragment">
                Cardinal: C = S ((S (K ((S (K S)) K))) S) (K K)
            </li><li class="fragment">
                Bluebird: B = S (K S) K
            </li><li class="fragment">
                Thrush: Th = S (K (S I)) K
            </li><li class="fragment">
                Vireo: V =  S (K (S (S (K (S (K S) K)) S) (K K)))
                <br />(S (K (S I)) K)
            </li><li class="fragment">
                Blackbird: Bl = S (K (S (K S) K)) (S (K S) K)
            </li><li class="fragment">
                Y = S (K (S I I)) (S (S (K S) K) (K (S I I)))
            </li></ul>
        </section><section>
            <h3>There Can Be Only One</h3>
            <p>
                The <a href="https://en.wikipedia.org/wiki/Iota_and_Jot"
                    >iota</a> combinator is universal all by itself
                (Chris Barker 2001 CE)
            </p><p>
                i &#x225d; &#x03bb;f.f (&#x03bb;a b c.a c (b c))
                &#x03bb;d e.d
            </p><ul><li class="fragment">
                i i
                <span class="fragment">
                    = (&#x03bb;f.f S K) &#x03bb;f.f S K
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;f.f S K) S K
                </span><span class="fragment">
                    &#x25b7; <br />S S K K
                </span><span class="fragment">
                    &#x25b7; S K (K K)
                </span><span class="fragment">
                    &#x25b7; I
                </span>
            </li><li class="fragment">
                i (i (i i))
                <span class="fragment">
                    = (&#x03bb;f.f S K) ((&#x03bb;f.f S K) I)
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;f.f S K) I S K
                </span><span class="fragment">
                    &#x25b7; <br />I S K S K
                </span><span class="fragment">
                    &#x25b7; S K S K
                </span><span class="fragment">
                    &#x25b7; I K
                </span><span class="fragment">
                    &#x25b7; K
                </span>
            </li><li class="fragment">
                i (i (i (i i)))
                <span class="fragment">
                    = (&#x03bb;f.f S K) K
                </span><span class="fragment">
                    &#x25b7; K S K
                </span><span class="fragment">
                    &#x25b7; S
                </span>
            </li></ul>
        </section><section>
            <h3>Binary Iota</h3>
            <p>
                Chris Barker created a simple binary encoding:
            </p><p>
                term := "1" | "0" term term
            </p><ul><li class="fragment">
                1 = i
            </li><li class="fragment">
                011 = i i = I
            </li><li class="fragment">
                0101011 = i (i (i i)) = K
            </li><li class="fragment">
                010101011 = i (i (i i)) = S
            </li></ul><p class="fragment">
                But remember... just because you can stick peas up
                your nose doesn't mean you should.
            </p>
        </section>
    </section><section>
        <section>
            <h2>Conclusion</h2>
            <p>
                None of this is efficient compared to conventional von
                Neumann programming languages.  So what's the point?
            </p>
        </section><section>
            <h3>Conclusion</h3>
            <ul><li class="fragment">
                Expressions alone are universal
            </li><li class="fragment">
                Expressions can be parallelized
            </li><li class="fragment">
                Expressions submit to mathematical tools
            </li></ul><p class="fragment">
                Hopefully all this helps to appreciate how the power
                of computation can bloom from simple seeds.
            </p>
        </section>
    </section></div></div>
    <script src="lib/reveal/head.min.js"></script>
    <script src="lib/reveal/reveal.js"></script>
    <script src="ripple/polyfill.js"></script>
    <script src="ripple/ripple.js"></script>
    <script src="ripple/logic.js"></script>
    <script src="ripple/multivec.js"></script>
    <script src="ripple/triggy.js"></script>
    <script src="lib/slides.js"></script>
</html>
