<!DOCTYPE html>
<html lang="en">
    <title>Lambda Calculus</title>
    <!-- Copyright (C) 2020-2021 by Jeff Gold.  All rights reserved. -->
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="lambdacalculus.svg" />
    <link rel="stylesheet" href="lib/reveal/reveal.css" />
    <link rel="stylesheet" href="lib/reveal/sky.css" />
    <link rel="stylesheet" href="lib/slides.css" />
    <div class="reveal"><div class="slides"><section id="lambdacalculus">
        <section>
            <h1>Lambda Calculus</h1>
            <p>
                &#x03bb;f.f (&#x03bb;a b c.a c (b c)) &#x03bb;d e.d
            </p>
        </section>
        <section>
            <h2>Lambda Calculus</h2>
            <p>
                Lambda calculus is a simple, compact and universal
                model of computation.  Published by
                <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonso
                    Church</a> in 1936 CE, it slightly predates
                <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing
                    Machines</a>.  Both can compute any generally recursive
                function.
            </p>
        </section>
        <section>
            <h3>Definition</h3>
            <table><tr><td class="fragment">
                <p>Syntax</p><ul><li class="fragment">
                    Variables: a
                </li><li class="fragment">
                    Abstraction:
                    &#x03bb;a.<span class="expression">E</span>
                </li><li class="fragment">
                    Application: <span class="expression">E</span>
                    <span class="expression">F</span>
                </li><li class="fragment">
                    Grouping: (<span class="expression">E</span>)
                </li></ul>
            </td><td class="fragment">
                <p>Semantics</p><ul><li class="fragment">
                    Equivalence:
                    b&#x2209;FV[<span class="expression">E</span>] &#x27f9;
                    <br /> &#x03bb;a.<span class="expression">E</span>
                    &#x2251;
                    &#x03bb;b.(<span class="expression">E</span> [a := b])
                </li><li class="fragment">
                    Reduction: <br />
                    (&#x03bb;a.<span class="expression">E</span>)
                    <span class="expression">F</span> ... &#x25b7;
                    <span class="expression">E</span>
                    [a := <span class="expression">F</span>] ...
                </li></ul>
            </td></tr></table><p class="fragment">
                This is a complete description of lambda calculus.
            </p>
        </section>
        <section>
            <h3>Variables</h3>
            <p>
                A variable is a sequence of characters excluding
                <q class="intro">&#x03bb;</q>, <q class="intro">.</q>,
                <q class="intro">(</q>, <q class="intro">)</q> and
                white space.  A single variable by itself is a valid
                expression.
            </p><p class="fragment">
                Examples: a, b, c, MULTIPLY, 172, ISNIL?, @!, ...
            </p>
        </section>
        <section>
            <h3>Free Variables</h3>
            <p>
                Any variable not bound by an abstraction is free.
            </p><ul><li class="fragment">
                FV[a] &#x225d; {a}
            </li><li class="fragment">
                FV[&#x03bb;a.<span class="expression">E</span>] &#x225d;
                FV[<span class="expression">E</span>] - {a}
            </li><li class="fragment">
                FV[<span class="expression">E</span>
                <span class="expression">F</span>] &#x225d;
                FV[<span class="expression">E</span>] &cup;
                FV[<span class="expression">F</span>]
            </li><li class="fragment">
                FV[(<span class="expression">E</span>)] &#x225d;
                FV[<span class="expression">E</span>]
            </li></ul><p class="fragment">
                These rules cover all possible expressions.
            </p>
        </section>
        <section>
            <h3>Free Variables: Examples</h3>
            <ul><li class="fragment">
                FV[&#x03bb;a.a] <span class="fragment">= {}</span>
            </li><li class="fragment">
                FV[&#x03bb;a.b] <span class="fragment">= {b}</span>
            </li><li class="fragment">
                FV[(&#x03bb;b.b) b] <span class="fragment">= {b}</span>
            </li><li class="fragment">
                FV[(&#x03bb;a.a b) &#x03bb;b.c b c]
                <span class="fragment">= {b, c}</span>
            </li><li class="fragment">
                FV[&#x03bb;a.&#x03bb;b.b a]
                <span class="fragment">= {}</span>
            </li></ul>
        </section>
        <section>
            <h3>Substitution</h3>
            <p>
                Substitution replaces all instances of a free variable
                with an expression.
            </p><ul><li class="fragment">
                a [a := <span class="expression">G</span>] &#x225d;
                <span class="expression">G</span>
                <span class="fragment">
                    &and; b [a := <span class="expression">G</span>]
                    &#x225d; b
                </span>
            </li><li class="fragment">
                &#x03bb;a.<span class="expression">E</span>
                [a := <span class="expression">G</span>] &#x225d;
                &#x03bb;a.<span class="expression">E</span>
                <span class="fragment">
                    &and; <br />
                    &#x03bb;b.<span class="expression">E</span>
                    [a := <span class="expression">G</span>] &#x225d;
                    &#x03bb;b.(<span class="expression">E</span>
                    [a := <span class="expression">G</span>])
                </span>
            </li><li class="fragment">
                <span class="expression">E</span>
                <span class="expression">F</span>
                [a := <span class="expression">G</span>] &#x225d;
                <span class="expression">E</span>
                [a := <span class="expression">G</span>]
                <span class="expression">F</span>
                [a := <span class="expression">G</span>]
            </li><li class="fragment">
                (<span class="expression">E</span>)
                [a := <span class="expression">G</span>] &#x225d;
                (<span class="expression">E</span>
                [a := <span class="expression">G</span>])
            </li></ul>
        </section>
        <section>
            <h3>Equivalence</h3>
            <p>
                Replacing all occurances of a bound variable does not
                change the meaning of an expression unless it coincides
                with a free variable.
            </p><p>
                b&#x2209;FV[<span class="expression">E</span>] &#x27f9;
                &#x03bb;a.<span class="expression">E</span>
                &#x2251;
                &#x03bb;b.(<span class="expression">E</span> [a := b])
            </p>
        </section>
        <section>
            <h3>Equivalence: Examples</h3>
            <table><tr><td><ul><li class="fragment">
                &#x03bb;a.a &#x2251;
                <span class="true">&#x03bb;b.b</span>
            </li><li class="fragment">
                &#x03bb;a.c &#x2251;
                <span class="true">&#x03bb;b.c</span>
            </li><li class="fragment">
                &#x03bb;f.(&#x03bb;a.f (a a)) &#x03bb;a.f (a a)
                &#x2251; <br />
                <span class="true">
                    &#x03bb;g.(&#x03bb;b.g (b b)) &#x03bb;c.g (c c)
                </span>
            </li></ul></td><td><ul><li class="fragment">
                &#x03bb;a.b &ne;
                <span class="false">&#x03bb;a.c</span>
            </li><li class="fragment">
                &#x03bb;a.b &ne;
                <span class="false">&#x03bb;b.b</span>
            </li><li class="fragment">
                &#x03bb;a.&#x03bb;b.a &ne;
                <span class="false">&#x03bb;c.&#x03bb;b.a</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Reduction</h3>
            <p>
                Reduction replaces an abstraction followed by an
                expression with the body of the abstraction
                with the variable substited by the expression.
            </p><p>
                (&#x03bb;a.<span class="expression">E</span>)
                <span class="expression">F</span> ...
                <span class="fragment">
                    &#x25b7; <span class="expression">E</span>
                    [a := <span class="expression">F</span>] ...
                </span>
            </p>
        </section><section>
            <h3>Reduction: Examples</h3>
            <ul><li class="fragment">
                (&#x03bb;a.a) b
                <span class="fragment">
                    &#x25b7; a [a := b]
                </span><span class="fragment">
                    &#x25b7; b
                </span>
            </li><li class="fragment">
                a (&#x03bb;a.a a) b c
                <span class="fragment">
                    &#x25b7; a (a a [a := b]) c
                </span><span class="fragment">
                    &#x25b7; a b b c
                </span>
            </li><li class="fragment">
                &#x03bb;a.(&#x03bb;b.b a) c
                <span class="fragment">
                    &#x25b7; &#x03bb;a.b a [b := c]
                </span><span class="fragment">
                    &#x25b7; &#x03bb;a.c a
                </span>
            </li></ul>
        </section><section>
            <h3>Reduction: Free Variables</h3>
            <p>
                Free variables in the application must not match any
                bound variables in the abstraction.
            </p><p class="fragment">
                (&#x03bb;a.&#x03bb;b.a) b
                <span class="fragment false">
                    &#x25b7; &#x03bb;b.a [a := b]
                </span><span class="fragment false">
                    &#x25b7; &#x03bb;b.b
                </span>
            </p><p class="fragment">
                (&#x03bb;a.&#x03bb;c.a) b    
                <span class="fragment true">
                    &#x25b7; &#x03bb;c.a [a := b]
                </span><span class="fragment true">
                    &#x25b7; &#x03bb;c.b
                </span>
            </p><p class="fragment">
                We must use an equivalent expression instead.
            </p>
        </section>
        <section>
            <h3>Reduction: Normal Form</h3>
            <p>
                An expression in normal cannot be reduced.
            </p><ul><li class="fragment">
                a <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                &#x03bb;a.a <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                a &#x03bb;b.b <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                (&#x03bb;a.a) b
                <span class="fragment">
                    &#x25b7; a [a := b]
                </span><span class="fragment">
                    &#x25b7; b
                </span><span class="fragment">&#10003;</span>
            </li><li class="fragment">
                (&#x03bb;a.a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; a [a := (&#x03bb;b.b) c]
                </span><span class="fragment">
                    &#x25b7; <br />(&#x03bb;b.b) c
                </span><span class="fragment">
                    &#x25b7; b [b := c]
                </span><span class="fragment">
                    &#x25b7; c
                </span><span class="fragment">&#10003;</span>
            </li></ul>
        </section>
        <section>
            <h3>Reduction: Ad Infinitum</h3>
            <p>
                Not all expressions have a normal from.
            </p><p class="fragment">
                (&#x03bb;a.a a) &#x03bb;a.a a
                <span class="fragment">
                    &#x25b7; <br /> a a [a := &#x03bb;a.a a]
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">
                    &#x25b7; <br /> (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">&#x25b7; ...</span>
            </p>
        </section>
        <section>
            <h3>Reduction: Normal Order</h3>
            <p>
                Normal order performs the outer most, left most
                reduction first when more than one are available.
            </p><ul><li class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; a a [a := ((&#x03bb;b.b) c)]
                </span>
            </li><li class="fragment">
                ((&#x03bb;b.b) c) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; b [b := c] ((&#x03bb;b.b) c)
                </span>
            </li><li class="fragment">
                c ((&#x03bb;b.b) c)
                <span class="fragment">&#x25b7; c b [b := c]</span>
            </li><li class="fragment">
                c c <span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                Normal order is guaranteed to reach a normal form
                for any expression if one exists.
            </p>
        </section>
        <section>
            <h3>Reduction: Eager Order</h3>
            <p>
                A disadvantage of normal form is that it can evaluate
                parts of an expression many times.  Eager evaluation
                solves this problem.
            </p><ul><li class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; (&#x03bb;a.a a) b [b := c]
                </span>
            </li><li class="fragment">
                (&#x03bb;a.a a) c
                <span class="fragment">&#x25b7; a a [a := c]</span>
            </li><li class="fragment">
                c c <span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                Only two reductions were necessary.
            </p>
        </section>
        <section>
            <h3>A Little Too Eager</h3>
            <p>
                Sometimes eager order fails...
            </p><p>
                (&#x03bb;a.&#x03bb;b.a) c
                ((&#x03bb;d.d d) &#x03bb;d.d d)
            </p><table class="large"><tr><td><ul class="fragment">
                Normal Order                
                <li class="fragment">
                    (&#x03bb;b.c) ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    c [b := ((&#x03bb;d.d d) &#x03bb;d.d d)]
                </li><li class="fragment">
                    c <span class="fragment">&#10003;</span>
                </li></ul>
            </td><td><ul class="fragment">
                Eager Order                
                <li class="fragment">
                    (&#x03bb;a.&#x03bb;b.a) c
                    ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    (&#x03bb;a.&#x03bb;b.a) c
                    ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    ...
                </li></ul>
            </td></tr></table><p class="fragment">
                Stable or efficient -- pick one!
            </p>
        </section><section>
            <h3>Reduction: Lazy Order</h3>
            <p>
                Lazy evaluation is like normal order but it keeps
                of expressions so they're evaluated only once.
            </p><ul><li class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x25b7; a a [a := ((&#x03bb;b.b) c)]
                </span>
            </li><li class="fragment">
                ((&#x03bb;b.b) c) ((&#x03bb;b.b) c)
                <span class="fragment">&#x25b7; c c</span>
                <span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                This is the best of both worlds.
            </p>
        </section><section>
            <h3>Reduction: Currying</h3>
            <p>
                All abstractions accept a single variable (Frege 1893
                CE).  Additional variables are nested:
                &#x03bb;a.&#x03bb;b.<span class="expression">E</span>
            </p><ul><li class="fragment">
                (&#x03bb;a.&#x03bb;b.<span class="expression">E</span>)
                <span class="expression">F</span>
                <span class="expression">G</span>
                <span class="fragment">
                    &#x25b7;
                    (&#x03bb;b.<span class="expression">E</span>
                    [a := <span class="expression">F</span>])
                    <span class="expression">G</span>
                </span><span class="fragment">
                    &#x25b7; <br /> <span class="expression">E</span>
                    [a := <span class="expression">F</span>,
                    b := <span class="expression">G</span>]
                </span>
            </li><li class="fragment">
                (&#x03bb;a.&#x03bb;b.<span class="expression">E</span>)
                <span class="expression">F</span>
                <span class="fragment">
                    &#x25b7;
                    &#x03bb;b.<span class="expression">E</span>
                    [a := <span class="expression">F</span>]
                </span>
            </li></ul><p class="fragment">
                Supplying some but not all arguments is allowed.
            </p>
        </section><section>
            <h3>Reduction: Argument Notation</h3>
            <p>
                There is a convenient short hand for nested
                abstractions.
            </p><p>
                <span class="intro">&#x03bb;a
                    b.</span><span class="expression">E</span> &#x225d;
                &#x03bb;a.&#x03bb;b.<span class="expression">E</span>
            </p><p class="fragment">
                <span class="intro">&#x03bb;a b
                    c.<span class="expression">E</span></span> &#x225d;
                &#x03bb;a.&#x03bb;b.&#x03bb;c.<span class="expression"
                                              >E</span>
            </p><p class="fragment">
                And so on for more arguments...
            </p>
        </section><section>
            <h3>Lambda Calculus</h3>
            <table><tr><td>
                <p>Syntax</p><ul><li>
                    Variables: a
                </li><li>
                    Abstraction:
                    &#x03bb;a.<span class="expression">E</span>
                </li><li>
                    Application: <span class="expression">E</span>
                    <span class="expression">F</span>
                </li><li>
                    Grouping: (<span class="expression">E</span>)
                </li></ul>
            </td><td>
                <p>Semantics</p><ul><li>
                    Equivalence:
                    b&#x2209;FV[<span class="expression">E</span>] &#x27f9;
                    <br /> &#x03bb;a.<span class="expression">E</span>
                    &#x2251;
                    &#x03bb;b.(<span class="expression">E</span> [a := b])
                </li><li>
                    Reduction: <br />
                    (&#x03bb;a.<span class="expression">E</span>)
                    <span class="expression">F</span> ... &#x25b7;
                    <span class="expression">E</span>
                    [a := <span class="expression">F</span>] ...
                </li></ul>
            </td></tr></table><p>
                Notation: &#x03bb;a
                b.</span><span class="expression">E</span> &#x225d;
                &#x03bb;a.&#x03bb;b.<span class="expression">E</span>
            </p>
        </section><section>
            <h3>Lambda Calculus</h3>
            <div class="lambda"></div>
        </section>
    </section><section>
        <section>
            <h2>Lambda Computation</h2>
            <p>
                Lambda calculus is certainly simple.  But isn't it
                supposed to be universal?  There's no boolean logic,
                no numbers, no data structures and no recusion.
            </p><p>
                We can construct these using combinators.
            </p>
        </section><section>
            <h3>Combinators</h3>
            <p>
                A combinator is an abstraction with no free variables.
                These can only operate on bound variables.
            </p><p>
                FV[&#x03bb;a.<span class="expression">E</span>] = {}
            </p>
        </section><section>
            <h3>Combinator Birds</h3>
            <p>
                Raymond Smullyan wrote a book about combinatory logic
                titled
                <a href="https://en.wikipedia.org/wiki/To_Mock_a_Mockingbird">
                    To Mock a Mockingbird</a>.
                Giving names to combinators helps us to remember them.
            </p>
        </section>
        <section>
            <h3>Meet the Birds</h3>
            <ul><li class="fragment">
                Ibis (Identity): &#x03bb;a.a
            </li><li class="fragment">
                Mockingbird (Self-Apply): &#x03bb;a.a a
            </li><li class="fragment">
                Kestral (True/Const): &#x03bb;a b.a
            </li><li class="fragment">
                Kite (False/Zero): &#x03bb;a b.b
            </li><li class="fragment">
                Cardinal (Flip/Not): &#x03bb;f a b.f b a
            </li><li class="fragment">
                Bluebird (Compose):
                &#x03bb;f g a.f (g a)
            </li><li class="fragment">
                Thrush (Power): &#x03bb;a f.f a
            </li><li class="fragment">
                Vireo (Pair): &#x03bb;a b f.f a b
            </li><li class="fragment">
                Blackbird:
                &#x03bb;f g a b.f (g a b)
            </li><li class="fragment">
                Starling: &#x03bb;a b c.a c (b c)
            </li></ul>
        </section><section>
            <h3>Combinator Booleans</h3>
            <p>
                One thing we might want to compute is boolean logic.
                Everything must evaluate to true or false.  How could
                we represent these in lambda calculus?
            </p>
            <ul><li class="fragment">
                <span class="true">TRUE</span>: &#x03bb;a b.a [Kestral]
            </li><li class="fragment">
                <span class="false">FALSE</span>: &#x03bb;a b.b [Kite]
            </li></ul><p class="fragment">
                Consider: &#x03bb;p.p (&#x03bb;a.a)
                ((&#x03bb;a.a a) &#x03bb;a.a a)
            </p>
        </section><section>
            <h3>Combinator NOT</h3>
            <p>
                NOT [Cardinal]: &#x03bb;p a b.p b a
            </p><table><tr><td><ul><li class="fragment">
                NOT TRUE
            </li><li class="fragment">
                &#x03bb;a b.TRUE b a
            </li><li class="fragment">
                &#x03bb;a b.b
                <span class="fragment">&#x25b7; FALSE</span>
            </li></ul></td><td><ul><li class="fragment">
                NOT FALSE
            </li><li class="fragment">
                &#x03bb;a b.FALSE b a
            </li><li class="fragment">
                &#x03bb;a b.a
                <span class="fragment">&#x25b7; TRUE</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator AND</h3>
            <p>
                AND: &#x03bb;p q.p q p
            </p><table><tr><td><ul><li class="fragment">
                AND TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                AND TRUE FALSE
            </li><li class="fragment">
                TRUE FALSE TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                AND FALSE TRUE
            </li><li class="fragment">
                FALSE TRUE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td><td><ul><li class="fragment">
                AND FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator OR</h3>
            <p>
                OR: &#x03bb;p q.p p q
            </p><table><tr><td><ul><li class="fragment">
                OR TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                OR TRUE FALSE
            </li><li class="fragment">
                TRUE TRUE FALSE
            </li><li class="fragment">
                TRUE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                OR FALSE TRUE
            </li><li class="fragment">
                FALSE FALSE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                OR FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator Booleans</h3>
            <p>
                BOOLEQ?: &#x03bb;p q.p q (NOT q)
            </p><table class="large"><tr><td><ul><li class="fragment">
                BOOLEQ? TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE (NOT TRUE)
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                BOOLEQ? TRUE FALSE
            </li><li class="fragment">
                TRUE FALSE (NOT FALSE)
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                BOOLEQ? FALSE TRUE
            </li><li class="fragment">
                FALSE TRUE (NOT TRUE)
            </li><li class="fragment">
                NOT TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td><td><ul><li class="fragment">
                BOOLEQ? FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE (NOT FALSE)
            </li><li class="fragment">
                NOT FALSE
            </li><li class="fragment">
                TRUE
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator Booleans</h3>
            <ul><li>
                TRUE: &#x03bb;a b.a [Kestral]
            </li><li>
                FALSE: &#x03bb;a b.b [Kite]
            </li><li>
                NOT: &#x03bb;p a b.p b a [Cardinal]
            </li><li>
                AND: &#x03bb;p q.p q p
            </li><li>
                OR: &#x03bb;p q.p p q
            </li><li>
                BOOLEQ?: &#x03bb;p q.p q (NOT q)
            </li></ul>
        </section><section>
            <h3>Combinator Numbers</h3>
            <p>
                Church Numerals represent numbers by repeatedly
                applying a first argument a second.
            </p><ul><li class="fragment">
                ONE: &#x03bb;f a.f a
            </li><li class="fragment">
                TWO: &#x03bb;f a.f (f a)
            </li><li class="fragment">
                THREE: &#x03bb;f a.f (f (f a))
            </li><li class="fragment">
                ...
            </li></ul>
        </section><section>
            <h3>Combinator Successor</h3>
            <p>
                Natural numbers include zero and its successors.
            </p><p class="fragment">
                ZERO <span class="fragment">[Kite/FALSE]</span>:
                &#x03bb;f a.a
            </p><p class="fragment">
                SUCCESSOR: &#x03bb;n f a.f (n f a)
            </p><ul><li class="fragment">
                SUCCESSOR ZERO
            </li><li class="fragment">
                &#x03bb;f a.f (ZERO f a)
            </li><li class="fragment">
                &#x03bb;f a.f a <span class="fragment">[ONE]</span>
            </li></ul>
        </section><section>
            <h3>Combinator Addition</h3>
            <p>
                Take the successor n times to add:
            </p><p>
                ADD: &#x03bb;m n.n SUCCESSOR m
            </p><ul><li class="fragment">
                ADD THREE TWO
            </li><li class="fragment">
                TWO SUCCESSOR THREE
            </li><li class="fragment">
                SUCCESSOR (SUCCESSOR THREE)
            </li><li class="fragment">
                SUCCESSOR FOUR
            </li><li class="fragment">
                FIVE
            </li></ul>
        </section><section>
            <h3>Combinator Multiplication</h3>
            <p>
                Compose numbers to multiply:
            </p><p>
                MULTIPLY [Bluebird]: &#x03bb;m n f.m (n f)
            </p><ul><li class="fragment">
                MULTIPLY THREE TWO
            </li><li class="fragment">
                &#x03bb;f.THREE (TWO f)
            </li><li class="fragment">
                &#x03bb;f.THREE ((&#x03bb;f a.f (f a)) f)
            </li><li class="fragment">
                &#x03bb;f.THREE (&#x03bb;a.f (f a))
            </li><li class="fragment">
                &#x03bb;f.&#x03bb;a.f (f (f (f (f (f a)))))
            </li><li class="fragment">
                &#x03bb;f a.f (f (f (f (f (f a)))))
                <span class="fragment">[SIX]</span>
            </li></ul>
        </section><section>
            <h3>Combinator Exponentiation</h3>
            <p>
                Raise one number to the power of another:
            </p><p>
                POWER [Thrush]: &#x03bb;n m.m n
            </p><ul><li class="fragment">
                POWER THREE TWO
            </li><li class="fragment">
                TWO THREE
            </li><li class="fragment">
                (&#x03bb;f a.f (f a)) &#x03bb;f a.f (f (f a))
            </li><li class="fragment">
                ...
            </li><li class="fragment">
                &#x03bb;f a.f (f (f (f (f (f (f (f (f a))
                <span class="fragment">[NINE]</span>
            </li></ul>
        </section><section>
            <h3>Combinator Numbers</h3>
            <ul><li>
                ZERO [Kite/FALSE]: &#x03bb;f a.a
            </li><li>
                SUCCESSOR: &#x03bb;n f a.f (n f a)
            </li><li>
                ADD: &#x03bb;m n.n SUCCESSOR m
            </li><li>
                MULTIPLY [Bluebird]: &#x03bb;m n f.m (n f)
            </li><li>
                POWER [Thrush]: &#x03bb;n m.m n
            </li></ul>
        </section><section>
            <h3>Combinator Inverses</h3>
            <p>
                Can we subtract and divide?
                <span class="fragment">Yes, but...</span>
            </p><p class="fragment">
                SUBTRACT: &#x03bb;m n.n PREDECESSOR m
            </p><p class="fragment">
                PREDECESSOR: &#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) (&#x03bb;b.b)
            </p><p class="fragment">
                DIVIDE: &#x03bb;n.((&#x03bb;f.(&#x03bb;x.x x)
                (&#x03bb;x.f (x x)))
                (&#x03bb;c n m f x.
                (&#x03bb;d.(&#x03bb;n.n
                (&#x03bb;x a b.b)
                (&#x03bb;a b.a)) d
                ((&#x03bb;f x) f x) (f (c d m f x)))
                ((&#x03bb;m n.n
                (&#x03bb;n f x.n
                (&#x03bb;g h.h (g f)) (&#x03bb;u.x)
                (&#x03bb;u.u)) m) n m)))
                ((&#x03bb;n f x.f (n f x)) n)
            </p>
        </section><section>
            <h3>Combinator Zero Test</h3>
            <p>
                We can ask questions about numbers:
            </p><p>
                IS-ZERO?: &#x03bb;n.n (&#x03bb;a.FALSE) TRUE
            </p><table class="large"><tr><td><ul><li class="fragment">
                IS-ZERO? ZERO
            </li><li class="fragment">
                ZERO (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                (&#x03bb;f a.a) (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                IS-ZERO? ONE
            </li><li class="fragment">
                (&#x03bb;f a.f a) (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table><p class="fragment">
                What happens if we ask about a successor of one?
            </p>
        </section><section>
            <h3>Combinator Even</h3>
            <p>
                How can we ask whether a number is even?
            </p><p class="fragment">
                IS-EVEN?: &#x03bb;n.n NOT TRUE
            </p><table class="large"><tr><td><ul><li class="fragment">
                IS-EVEN? ZERO
            </li><li class="fragment">
                ZERO NOT TRUE
            </li><li class="fragment">
                (&#x03bb;f a.a) NOT TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                IS-EVEN? ONE
            </li><li class="fragment">
                (&#x03bb;f a.f a) NOT TRUE
            </li><li class="fragment">
                NOT TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table><p class="fragment">
                Each application flips the result.  Ask yourself
                how to define IS-ODD?
            </p>
        </section><section>
            <h3>Combinator Comparisons</h3>
            <ul><li class="fragment">
                LESSEQ?: &#x03bb;n m.IS-ZERO? (SUBTRACT n m)
            </li><li class="fragment">
                GREATEREQ?: &#x03bb;n m.IS-ZERO? (SUBTRACT m n)
            </li><li class="fragment">
                EQUAL?: &#x03bb;n m.AND (LESSEQ? n m) (LESSEQ? m n)
            </li><li class="fragment">
                LESS?: &#x03bb;n m.NOT (GREATEREQ? n m)
            </li><li class="fragment">
                GREATER?: &#x03bb;n m.NOT (LESSEQ? n m)
            </li></ul>
        </section><section>
            <h3>Combinator Ordered Pairs</h3>
            <p>
                We can take advantage of closure to store values.
            </p><ul><li class="fragment">
                PAIR: &#x03bb;a b f.f a b [Verio]
            </li><li class="fragment">
                PAIR a b
                <span class="fragment">
                    &#x25b7; &#x03bb;f.f a b
                </span>
            </li><li class="fragment">
                HEAD: &#x03bb;p.p TRUE
            </li><li class="fragment">
                TAIL: &#x03bb;p.p FALSE
            </li></ul><p class="fragment">
                This will serve as a foundation for data structures.
            </p>
        </section><section>
            <h3>Combinator Ordered Pairs</h3>
            <table class="xlarge"><tr><td><ul><li class="fragment">
                HEAD (PAIR TWO THREE)
            </li><li class="fragment">
                HEAD (&#x03bb;f.f TWO THREE)
            </li><li class="fragment">
                (&#x03bb;p.p TRUE) (&#x03bb;f.f TWO THREE)
            </li><li class="fragment">
                (&#x03bb;f.f TWO THREE) TRUE
            </li><li class="fragment">
                TRUE TWO THREE
                <span class="fragment">&#x25b7; TWO</span>
            </li></ul></td><td><ul><li class="fragment">
                TAIL (PAIR TWO THREE)
            </li><li class="fragment">
                TAIL (&#x03bb;f.f TWO THREE)
            </li><li class="fragment">
                (&#x03bb;p.p FALSE) (&#x03bb;f.f TWO THREE)
            </li><li class="fragment">
                (&#x03bb;f.f TWO THREE) FALSE
            </li><li class="fragment">
                FALSE TWO THREE
                <span class="fragment">&#x25b7; THREE</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Combinator Advanced Numbers</h3>
            <p>
                Integers are ordered pairs of Church Numerals.
                Rational numbers are ordered pairs of integers.
                We'll discuss how to construct ordered pairs later.
            </p>
        </section><section>
            <h3>Combinator Lists</h3>
            <p>
                Chaining ordered pairs together to make lists requires
                a way to find the end.
            </p><ul><li class="fragment">
                ISNIL?: &#x03bb;p.p &#x03bb;a b.FALSE
            </li><li class="fragment">
                NIL: &#x03bb;a.TRUE
            </li></ul>
        </section><section>
            <h3>Combinator Lists</h3>
            <p>
                ISNIL? NIL
            </p><ul><li class="fragment">
                (&#x03bb;p.p &#x03bb;a b.FALSE) &#x03bb;a.TRUE
            </li><li class="fragment">
                (&#x03bb;a.TRUE) &#x03bb;a b.FALSE
                <span class="fragment">&#x25b7; TRUE</span>
            </li></ul>
        </section><section>
            <h3>Combinator Lists</h3>
            <p>
                ISNIL? (PAIR TWO THREE)
            </p><ul><li class="fragment">
                (&#x03bb;p.p &#x03bb;a b.FALSE) (PAIR TWO THREE)
            </li><li class="fragment">
                (PAIR TWO THREE) &#x03bb;a b.FALSE
            </li><li class="fragment">
                (&#x03bb;f.f TWO THREE) &#x03bb;a b.FALSE
            </li><li class="fragment">
                (&#x03bb;a b.FALSE) TWO THREE
                <span class="fragment">&#x25b7; FALSE</span>
            </li></ul>
        </section><section>
            <h3>Combinator Lists</h3>
            <p>
                Now we can construct lists of arbitrary length.
            </p><ul><li class="fragment">
                PAIR ONE NIL
            </li><li class="fragment">
                PAIR ONE (PAIR TWO NIL)
            </li><li class="fragment">
                PAIR ONE (PAIR TWO (PAIR THREE NIL))
            </li><li class="fragment">
                ...
            </li></ul><p class="fragment">
                We can also make more sophisticated data structures
                such as balanced binary trees and so on.
            </p>
        </section><section>
            <h3>Combinator Data Structures</h3>
            <ul><li>
                PAIR: &#x03bb;a b f.f a b [Verio]
            </li><li>
                HEAD: &#x03bb;p.p TRUE
            </li><li>
                TAIL: &#x03bb;p.p FALSE
            </li><li>
                NIL: &#x03bb;a.TRUE
            </li><li>
                ISNIL?: &#x03bb;p.p &#x03bb;a b.FALSE
            </li></ul>
        </section><section>
            <h3>Combinator Recursion</h3>
            <p>
                There are no names or recursion in lambda calculus.
                However, there is a way to achieve the same effect
                using a combinator:
            </p><ul><li class="fragment">
                Y &#x225d; &#x03bb;f.(&#x03bb;a.f (a a))
                &#x03bb;a.f (a a)
            </li><li class="fragment">
                Y g
                <span class="fragment">
                    = (&#x03bb;a.g (a a))
                    &#x03bb;a.g (a a)
                </span>
            </li><li class="fragment">
                Y g = g ((&#x03bb;a.g (a a)) &#x03bb;a.g (a a))
                <span class="fragment">= g (Y g)</span>
            </li><li class="fragment">
                Y g = g (Y g)
                <span class="fragment">
                    = g (g (Y g))
                </span><span class="fragment">
                    = g (g (g (Y g)))
                </span><span class="fragment">
                    = ...
                </span>
            </li></ul>
        </section>
        <section>
            <h3>Factorial</h3>
            <p>
                FSTEP: (&#x03bb;f n.(IS-ZERO? n) ONE
                (MULTIPLY n (f (PREDECESSOR n))))
            </p><ul><li class="fragment">
                FACTORIAL ONE <span class="fragment">
                &#x225d; Y FSTEP ONE</span>
            </li><li class="fragment">
                Y FSTEP ONE &#x25b7; FSTEP (Y FSTEP) ONE
            </li><li class="fragment">
                MULTIPLY ONE ((Y FSTEP) (PREDECESSOR ONE))
            </li><li class="fragment">
                MULTIPLY ONE (FSTEP (Y FSTEP) ZERO)
            </li><li class="fragment">
                MULTIPLY ONE ONE &#x25b7; ONE
            </li></ul>
        </section><section>
            <h3>Lambda Computation</h3>
            <ul><li>
                Booleans: &#x03bb;a b.a, &#x03bb;a b.b
            </li><li>
                Numbers: &#x03bb;f a.a, &#x03bb;n f a.f (n f a)
            </li><li>
                Arithmetic: &#x03bb;m n.n (&#x03bb;n f a.f (n f a)) m
            </li><li>
                Data Structures: &#x03bb;a b f.f a b
            </li><li>
                Recursion: &#x03bb;f.(&#x03bb;a.f (a a))
                &#x03bb;a.f (a a)
            </li></ul><p>
                Lambda calculus simple, compact and universal.
            </p>            
        </section>
    </section><section>
        <section>
            <h3>Starling and Kestral</h3>
            <p>
                The Starling and Kestral combinators are universal
                (Sch√∂nfinkel 1924 CE).
                Like lambda calculus and Turing machines they can
                compute any computable function.
            </p><ul><li>
                Starling (S): &#x03bb;a b c.a c (b c)
            </li><li>
                Kestral (K): &#x03bb;a b.a
            </li></ul>
        </section><section>
            <h3>Simplification: Identity</h3>
            <p>
                We can simplify some Starling and Kestral combinations.
            </p><ul><li class="fragment">
                S K X
            </li><li class="fragment">
                (&#x03bb;a b c.a c (b c)) K X
                <span class="fragment">
                    &#x25b7; (&#x03bb;b c.K c (b c)) X
                </span>
            </li><li class="fragment">
                &#x25b7; &#x03bb;c.K c (X c)
                <span class="fragment">
                    &#x25b7; &#x03bb;c.(&#x03bb;a b.a) c (X c)
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.c
                </span>
            </li></ul><p class="fragment">
                S K K
                <span class="fragment">
                    = S K S
                </span><span class="fragment">
                    = S K (anything)
                </span><span class="fragment">
                    = I
                </span>
            </p>
        </section><section>
            <h3>Simplification: Kestral</h3>
            <p>
                We can simplify some Starling and Kestral combinations.
            </p><p class="fragment">
                S (K K) I <span class="fragment">= K</span>
            </p><ul><li class="fragment">
                (&#x03bb;a b c.a c (b c)) (K K) I
                <span class="fragment">
                    &#x25b7; (&#x03bb;b c.(K K) c (b c))  I
                </span>
            </li><li class="fragment">
                &#x25b7; &#x03bb;c.(K K) c
                (<span class="intro">I c</span>)
                <span class="fragment">
                    &#x25b7; &#x03bb;c.<span class="intro">K
                    K c</span> c
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.K c
                </span>
            </li><li class="fragment">
                &#x25b7; &#x03bb;c.(&#x03bb;a b.a) c
                <span class="fragment">
                    &#x25b7; &#x03bb;c.&#x03bb;b.c
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c b.c
                </span><span class="fragment">
                    &#x25b7; K
                </span>
            </li></ul>
        </section><section>
            <h3>Converting Lambda</h3>
            <p>
                Any lambda term
                <a href="https://en.wikipedia.org/wiki/Combinatory_logic">
                    can be converted</a>.
            </p><ul><li class="fragment">
                T[a] &#x27f9;  a
            </li><li class="fragment">
                T[<span class="expression">E</span>
                <span class="expression">F</span>] &#x27f9;
                T[<span class="expression">E</span>]
                T[<span class="expression">F</span>]
            </li><li class="fragment">
                T[(<span class="expression">E</span>)] &#x27f9;
                (T[<span class="expression">E</span>])
            </li><li class="fragment">
                T[&#x03bb;a.<span class="expression">E</span>]
                &and; a&#x2209;FV[<span class="expression">E</span>]
                &#x27f9; K T[<span class="expression">E</span>]
            </li><li class="fragment">
                T[&#x03bb;a.a] &#x27f9; S K K
                <span class="fragment">&#x27f9; I</span>
            </li><li class="fragment">
                T[&#x03bb;a.&#x03bb;b.<span class="expression">E</span>]
                &and; a&#x2208;FV[<span class="expression">E</span>]
                &#x27f9; T[&#x03bb;a.T[&#x03bb;b.<span class="expression"
                                                 >E</span>]]
            </li><li class="fragment">
                T[&#x03bb;a.<span class="expression">E</span>
                <span class="expression">F</span>]
                &and; a&#x2208;(FV[<span class="expression">E</span>] &cup;
                FV[<span class="expression">F</span>])
                &#x27f9; S T[&#x03bb;a.<span class="expression">E</span>]
                T[&#x03bb;a.<span class="expression">F</span>]]
            </li></ul>
        </section><section>
            <h3>Conversion: Thrush</h3>
            <p>
                Thrush: &#x03bb;a b.b a
            </p><ul><li class="fragment">
                T[&#x03bb;a b.b a]
                <span class="fragment">
                    &#x27f9;
                    T[&#x03bb;a.T[&#x03bb;b.b a]]
                </span>
            </li><li class="fragment">
                T[&#x03bb;a.S T[&#x03bb;b.b] T[&#x03bb;b.a]]
            </li><li class="fragment">
                T[&#x03bb;a.S I (K a)]
            </li><li class="fragment">
                S T[&#x03bb;a.(S I)] T[&#x03bb;a.K a]
            </li><li class="fragment">
                S (K (S I)) (S T[&#x03bb;a.K] T[&#x03bb;a.a])
            </li><li class="fragment">
                S (K (S I)) (S (K K) I)
            </li><li class="fragment">
                S (K (S I)) K
            </li></ul>
        </section><section>
            <h3>Other Combinators</h3>
            <ul><li class="fragment">
                Ibis: I = S K K = S K S
            </li><li class="fragment">
                Mockingbird: M = S I I
            </li><li class="fragment">
                Kite: Ki = K I
            </li><li class="fragment">
                Cardinal: C = S ((S (K ((S (K S)) K))) S) (K K)
            </li><li class="fragment">
                Bluebird: B = S (K S) K
            </li><li class="fragment">
                Thrush: Th = S (K (S I)) K
            </li><li class="fragment">
                Vireo: V =  S (K (S (S (K (S (K S) K)) S) (K K)))
                <br />(S (K (S I)) K)
            </li><li class="fragment">
                Blackbird: Bl = S (K (S (K S) K)) (S (K S) K)
            </li><li class="fragment">
                Y = S (K (S I I)) (S (S (K S) K) (K (S I I)))
            </li></ul>
        </section><section>
            <h3>There Can Be Only One</h3>
            <p>
                Chris Barker discovered a single
                <a href="https://en.wikipedia.org/wiki/Iota_and_Jot"
                >universal iota</a> combinator in 2001 CE:
            </p><p>
                i &#x225d; &#x03bb;f.f (&#x03bb;a b c.a c (b c))
                &#x03bb;d e.d
            </p><ul><li class="fragment">
                i i
                <span class="fragment">
                    = (&#x03bb;f.f S K) &#x03bb;f.f S K
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;f.f S K) S K
                </span><span class="fragment">
                    &#x25b7; <br />S S K K
                </span><span class="fragment">
                    &#x25b7; S K (K K)
                </span><span class="fragment">
                    &#x25b7; I
                </span>
            </li><li class="fragment">
                i (i (i i))
                <span class="fragment">
                    = (&#x03bb;f.f S K) ((&#x03bb;f.f S K) I)
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;f.f S K) I S K
                </span><span class="fragment">
                    &#x25b7; <br />I S K S K
                </span><span class="fragment">
                    &#x25b7; S K S K
                </span><span class="fragment">
                    &#x25b7; I K
                </span><span class="fragment">
                    &#x25b7; K
                </span>
            </li><li class="fragment">
                i (i (i (i i)))
                <span class="fragment">
                    = (&#x03bb;f.f S K) K
                </span><span class="fragment">
                    &#x25b7; K S K
                </span><span class="fragment">
                    &#x25b7; S
                </span>
            </li></ul>
        </section><section>
            <h3>Binary Iota</h3>
            <p>
                Chris Barker created a simple binary enocding:
            </p><p>
                iota := "1" | "0" iota iota
            </p><ul><li class="fragment">
                011 = i i = I
            </li><li class="fragment">
                0101011 = i (i (i i)) = K
            </li><li class="fragment">
                010101011 = i (i (i i)) = S
            </li></ul><p class="fragment">
                But remember... just because you can stick peas up
                your nose doesn't mean you should.
            </p>
        </section><section>
            <h2>Conclusion</h2>
            <p>
                Lambda calculus and combinator calculus demonstrate
                that computing can bloom from simple seeds.  This is
                not a reason to abandon more sophisticated tools but
                the intellectual foundations are worth appreciating.
            </p>
        </section>
    </section></div></div>
    <script src="lib/reveal/head.min.js"></script>
    <script src="lib/reveal/reveal.js"></script>
    <script src="ripple/polyfill.js"></script>
    <script src="ripple/ripple.js"></script>
    <script src="ripple/logic.js"></script>
    <script src="ripple/multivec.js"></script>
    <script src="ripple/triggy.js"></script>
    <script src="lib/slides.js"></script>
</html>
