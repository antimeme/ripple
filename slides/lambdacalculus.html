<!DOCTYPE html>
<html lang="en">
    <title>Lambda Calculus</title>
    <!-- Copyright (C) 2020-2024 by Jeff Gold.  All rights reserved. -->
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="lambdacalculus.svg" />
    <link rel="stylesheet" href="reveal/reveal.css" />
    <link rel="stylesheet" href="reveal/theme/sky.css" />
    <link rel="stylesheet" href="lib/slides.css" />
    <style>
     .order { font-size: 75%; }
     .examples { font-size: 90%; }
     li.extra { list-style-type: circle; }
    </style>
    <div class="reveal"><div class="slides"><section id="lambdacalculus">
        <section>
            <h1>Lambda Calculus</h1>
            <p>
                &#x03bb;f.f (&#x03bb;a b c.a c (b c)) &#x03bb;d e.d
            </p><aside class="notes">
                Welcome.  This presentation is about lambda calculus.
            </aside>
        </section><section>
            <h2>Lambda Calculus</h2>
            <p>
                Lambda calculus is a
                <span class="intro">formal system</span> that creates a
                <span class="intro">simple</span> and
                <span class="intro">universal</span> model of
                computation.
            </p><aside class="notes">
                What is lambda calculus?  It's a formal system.
                That means everything is precisely defined without
                reference to any external system or ideas.
            </aside>
        </section><section>
            <h2>Formal System</h2>
            <p>
                A formal system is a precise collection of rules for
                manipulating symbols.  These are usually organized
                into axioms, theorems and inference rules.
            </p><p class="fragment">
                These systems are completely specified and don't
                rely on any external knowledge.
            </p>
        </section><section>
            <h2>History</h2>
            <p>
                Published by
                <a href="https://en.wikipedia.org/wiki/Alonzo_Church"
                >Alonso Church</a> in 1936 CE, it slightly predates
                <a href="https://en.wikipedia.org/wiki/Turing_machine"
                >Turing Machines</a>.  Both can compute any
                <a href="https://en.wikipedia.org/wiki/General_recursive_function"
                >generally recursive function</a>.
            </p><aside class="notes">
                Lambda calculus is older than general purpose
                computers.  Church beat Turing to publication by
                a few months, but Turing proved that Turing machines
                are equivalent to lambda calculus.
            </aside>
        </section><section>
            <h3>Definition</h3>
            <p>
                A brief overview (notation will be explained later)
            </p><ul><li class="fragment">
                Variables: <span class="variable">v</span> :=
                "[^&#x03bb;.()\s]+"
            </li><li class="fragment">
                Expressions:
                <span class="expression">E</span> :=
                <span class="variable">v</span> |
                &#x03bb;<span class="variable"
                        >v</span>.<span class="expression">E</span> |
                <span class="expression">E</span>
                <span class="expression">E</span> |
                (<span class="expression">E</span>)
            </li><li class="fragment">
                Free Variables: FV[<span class="expression">E</span>]
                &#x2282; <span class="variable">v</span>
            </li><li class="fragment">
                Equivalence:
                <span class="variable">b</span> &#x2209;
                FV[<span class="expression">E</span>] &#x27f9;
                &#x03bb;<span class="variable"
                >a</span>.<span class="expression">E</span> &#x2251;
                &#x03bb;<span class="variable"
                >b</span>.(<span class="expression">E</span>
                [<span class="variable">a</span> :=
                <span class="variable">b</span>])
            </li><li class="fragment">
                Reduction:
                (&#x03bb;<span class="variable"
                >a</span>.<span class="expression">E</span>)
                <span class="expression">F</span> ... &#x25b7;
                <span class="expression">E</span>
                [<span class="variable">a</span> :=
                <span class="expression">F</span>] ...
            </li></ul><p class="fragment">
                This is everything in lambda calculus.
            </p>
        </section><section>
            <h3>Variables</h3>
            <p>
                <span class="variable">v</span> := "[^&#x03bb;.()\s]+"
            </p><p>
                A variable is a sequence of characters excluding
                <q class="intro">&#x03bb;</q>, <q class="intro">.</q>,
                <q class="intro">(</q>, <q class="intro">)</q> and
                white space.  They serve as labels and focal points
                for substitution.
            </p><p class="fragment">
                Examples: <span class="fragment">a b c</span>
                <span class="fragment">MULTIPLY</span>
                <span class="fragment">172</span>
                <span class="fragment">IS-NIL?</span>
                <span class="fragment">@!</span>
            </p><aside class="notes">
                I've used a regular expression to concisely explain
                that anything except lambda, dot, parentheses and
                white space can be part of a variable.  Variables
                are labels and can be affected by substitution.
            </aside>
        </section><section>
            <h3>Expressions</h3>
            <p>
                <span class="expression">E</span> :=
                <span class="variable">v</span> |
                &#x03bb;<span class="variable"
                        >v</span>.<span class="expression">E</span> |
                <span class="expression">E</span>
                <span class="expression">E</span> |
                (<span class="expression">E</span>)
            </p><ul><li class="fragment">
                Variable: <span class="variable">v</span>
            </li><li class="fragment">
                Abstraction:
                &#x03bb;<span class="variable"
                        >v</span>.<span class="expression">E</span>
            </li><li class="fragment">
                Application: <span class="expression">E</span>
                <span class="expression">E</span>
            </li><li class="fragment">
                Grouping: (<span class="expression">E</span>)
            </li></ul><p class="fragment">
                Application is conventionally left associative.
                <span class="fragment">
                    <br /> <span class="expression">E</span>
                    <span class="expression">F</span>
                    <span class="expression">G</span>
                    is the same as
                    (<span class="expression">E</span>
                    <span class="expression">F</span>)
                    <span class="expression">G</span>
                </span><span class="fragment">
                    but not
                    <span class="expression">E</span>
                    (<span class="expression">F</span>
                    <span class="expression">G</span>)
                </span>
            </p><aside class="notes">
                Expressions are the heart of lambda calculus.
                We begin and end with them.  They can be constructed
                using four simple rules.
            </aside>
        </section><section>
            <h3>Free Variables</h3>
            <p>
                A free variable is one not bound by abstraction.
                This is how we determine which variables are free:
            </p><ul><li class="fragment">
                FV[<span class="variable">a</span>] &#x225d;
                {<span class="variable">a</span>}
            </li><li class="fragment">
                FV[&#x03bb;<span class="variable"
                >a</span>.<span class="expression">E</span>] &#x225d;
                FV[<span class="expression">E</span>] -
                {<span class="variable">a</span>}
            </li><li class="fragment">
                FV[<span class="expression">E</span>
                <span class="expression">F</span>] &#x225d;
                FV[<span class="expression">E</span>] &cup;
                FV[<span class="expression">F</span>]
            </li><li class="fragment">
                FV[(<span class="expression">E</span>)] &#x225d;
                FV[<span class="expression">E</span>]
            </li></ul><p class="fragment">
                Every expression is associated with exactly one
                set of free variables, which may be empty.
            </p><aside class="notes">
                Free variables are those that aren't bound by
                any enclosing abstraction.  Each expression
                rule has a corresponding free variable rule.
            </aside>
        </section><section>
            <h3>Free Variables: Examples</h3>
            <ul><li class="fragment">
                FV[a b c]
                <span class="fragment">
                    = ({a} &cup; {b}) &cup; {c} = {a, b, c}
                </span>
            </li><li class="fragment">
                FV[&#x03bb;a.a]
                <span class="fragment">= {a} - {a} = {}</span>
            </li><li class="fragment">
                FV[&#x03bb;a.a b]
                <span class="fragment">= {a, b} - {a} = {b}</span>
            </li><li class="fragment">
                FV[(&#x03bb;b.b) b]
                <span class="fragment">= {} &cup; {b} = {b}</span>
            </li><li class="fragment">
                FV[(&#x03bb;a.a b) c]
                <span class="fragment">
                    = ({a, b} - {a}) &cup; {c} = {b, c}
                </span>
            </li><li class="fragment">
                FV[(&#x03bb;a.a b) &#x03bb;b.c b]
                <span class="fragment">
                    = {b} &cup; {c} = {b, c}
                </span>
            </li><li class="fragment">
                FV[&#x03bb;a.&#x03bb;b.b a]
                <span class="fragment">
                    = {a, b} - {b} - {a} = {}
                </span>
            </li></ul><aside class="notes">
                Let's see some examples of free variable calculation.
            </aside>
        </section><section>
            <h3>Substitution</h3>
            <p>
                Replaces a free variable with an expression.
            </p><ul><li class="fragment">
                <span class="variable">a</span>
                [<span class="variable">a</span> :=
                <span class="expression">G</span>] &#x225d;
                <span class="expression">G</span>
                <span class="fragment">
                    &and; b [<span class="variable">a</span> :=
                    <span class="expression">G</span>]
                    &#x225d; b
                </span>
            </li><li class="fragment">
                <span class="expression">E</span>
                <span class="expression">F</span>
                [<span class="variable">a</span> :=
                <span class="expression">G</span>] &#x225d;
                (<span class="expression">E</span>
                [<span class="variable">a</span> :=
                <span class="expression">G</span>])
                (<span class="expression">F</span>
                [<span class="variable">a</span> :=
                <span class="expression">G</span>])
            </li><li class="fragment">
                (<span class="expression">E</span>)
                [<span class="variable">a</span> :=
                <span class="expression">G</span>] &#x225d;
                (<span class="expression">E</span>
                [<span class="variable">a</span> :=
                <span class="expression">G</span>])
            </li><li class="fragment">
                &#x03bb;<span class="variable"
                >a</span>.<span class="expression">E</span>
                [<span class="variable">a</span> :=
                <span class="expression">G</span>] &#x225d;
                &#x03bb;<span class="variable"
                >a</span>.<span class="expression">E</span>
                <span class="fragment">
                    &and;
                    (b &#x2209; FV[<span class="expression">G</span>])
                    &#x27f9; <br />
                    &#x03bb;b.<span class="expression">E</span>
                    [<span class="variable">a</span> :=
                    <span class="expression">G</span>] &#x225d;
                    &#x03bb;b.(<span class="expression">E</span>
                    [<span class="variable">a</span> :=
                    <span class="expression">G</span>])
                </span><span class="fragment">
                    &and; <br />
                    (b &#x2208; FV[<span class="expression">G</span>]
                    &and; c &#x2209;
                    FV[<span class="expression">E</span> &cup;
                    <span class="expression">G</span>)]
                    &#x27f9; <br />
                    &#x03bb;b.<span class="expression">E</span>
                    [<span class="variable">a</span> :=
                    <span class="expression">G</span>] &#x225d;
                    &#x03bb;c.(<span class="expression">E</span>
                    [<span class="variable">b</span> :=
                    <span class="variable">c</span>,
                    <span class="variable">a</span> :=
                    <span class="expression">G</span>])
                </span>
            </li></ul><aside class="notes">
                Substitution is the basis for all computation in
                lambda calculus.  The final rule here addresses
                capture, which is the trickiest part of lambda
                calculus.
            </aside>
        </section><section>
            <h3>Substitution: Examples</h3>
            <ul><li class="fragment">
                a b (a b) [a := c]
                <span class="fragment">
                    &#x2aa2; c b (c b)
                </span>
            </li><li class="fragment">
                a b (a b) [a := &#x03bb;b.b]
                <span class="fragment">
                    &#x2aa2; (&#x03bb;b.b) b ((&#x03bb;b.b) b)
                </span>
            </li><li class="fragment">
                (&#x03bb;a.a b) &#x03bb;b.a b [a := c]
                <span class="fragment">
                    &#x2aa2; (&#x03bb;a.a b) &#x03bb;b.c b
                </span>
            </li><li class="fragment">
                (&#x03bb;a.a b) &#x03bb;b.a b [a := b]
                <span class="fragment">
                    &#x2aa2; (&#x03bb;a.a b) &#x03bb;c.b c
                </span>
            </li><li class="fragment">
                (&#x03bb;a.a b) &#x03bb;b.a b [a := &#x03bb;a.b]
                <span class="fragment">
                    &#x2aa2; (&#x03bb;a.a b) &#x03bb;c.(&#x03bb;a.b) c
                </span>
            </li></ul><aside class="notes">
                Let's see some examples of substitution.
            </aside>
        </section><section>
            <h3>Equivalence</h3>
            <p>
                Replacing all occurances of a bound variable does not
                change the meaning of an expression as long as free
                variables are preserved.
            </p><p class="fragment">
                <span class="variable">b</span> &#x2209;
                FV[<span class="expression">E</span>] &#x27fa;
                &#x03bb;<span class="variable">a</span
                >.<span class="expression">E</span>
                &#x2251;
                &#x03bb;<span class="variable"
                >b</span>.(<span class="expression">E</span>
                [<span class="variable">a</span> :=
                <span class="variable">b</span>])
            </p><p class="fragment">
                <span class="expression">E</span> &#x2251;
                <span class="expression">F</span> &#x27f9;
                FV[<span class="expression">E</span>] =
                FV[<span class="expression">F</span>]
            </p>
        </section><section>
            <h3>Equivalence: Examples</h3>
            <table class="examples"><tr><td><ul><li class="fragment">
                &#x03bb;a.a &#x2251;
                <span class="true">&#x03bb;b.b</span>
            </li><li class="fragment">
                &#x03bb;a.a b c &#x2251;
                <span class="true">&#x03bb;d.d b c</span>
            </li><li class="fragment">
                &#x03bb;f.(&#x03bb;a.f (a a)) &#x03bb;a.f (a a)
                &#x2251; <br />
                <span class="true">
                    &#x03bb;g.(&#x03bb;b.g (b b)) &#x03bb;c.g (c c)
                </span>
            </li></ul></td><td><ul><li class="fragment">
                &#x03bb;a.a a &ne;
                <span class="false">&#x03bb;b.b</span>
            </li><li class="fragment">
                &#x03bb;a.a b c &ne;
                <span class="false">&#x03bb;b.a b c</span>
            </li><li class="fragment">
                &#x03bb;a.a b c &ne;
                <span class="false">&#x03bb;b.b b c</span>
            </li><li class="fragment">
                &#x03bb;a.a b c &ne;
                <span class="false">&#x03bb;d.b c d</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Reduction</h3>
            <p>
                Reduction applies an abstration to the expression
                that follows.  This replaces the abstraction and
                following expression with the body of the abstraction
                with the bound variable substituted.
            </p><p span class="fragment">
                (&#x03bb;a.<span class="expression">E</span>)
                <span class="expression">F</span> ...
                <span class="fragment">
                    &#x2aa2; <span class="expression">E</span>
                    [a := <span class="expression">F</span>] ...
                </span>
            </p>
        </section><section>
            <h3>Reduction: Examples</h3>
            <ul><li class="fragment">
                (&#x03bb;a.a) b
                <span class="fragment">
                    &#x2aa2; a [a := b]
                </span><span class="fragment">
                    &#x25b7; b
                </span>
            </li><li class="fragment">
                (&#x03bb;a.a a) b c
                <span class="fragment">
                    &#x2aa2; (a a [a := b]) c
                </span><span class="fragment">
                    &#x25b7; b b c
                </span>
            </li><li class="fragment">
                &#x03bb;a.(&#x03bb;b.b a) c
                <span class="fragment">
                    &#x2aa2; &#x03bb;a.(b a [b := c])
                </span><span class="fragment">
                    &#x25b7; &#x03bb;a.c a
                </span>
            </li></ul>
        </section><section>
            <h3>Reduction: Capture</h3>
            <p>
                Free variables in the application argument must not
                match bound variables in nested abstractions.
            </p><p class="fragment">
                (&#x03bb;a.b) b
                <span class="fragment">
                    &#x2aa2; b [a := b]
                </span><span class="fragment">
                    &#x25b7; b
                </span>
            </p><p class="fragment">
                (&#x03bb;a.&#x03bb;b.a) b
                <span class="fragment false">
                    &#x2aa2; &#x03bb;b.a [a := b]
                </span><span class="fragment false">
                    &#x25b7; &#x03bb;b.b
                </span>
            </p><p class="fragment">
                (&#x03bb;a.&#x03bb;c.a) b    
                <span class="fragment true">
                    &#x2aa2; &#x03bb;c.a [a := b]
                </span><span class="fragment true">
                    &#x25b7; &#x03bb;c.b
                </span>
            </p><p class="fragment">
                We must rename bound variables sometimes.
            </p>
        </section><section>
            <h3>Normal Form</h3>
            <p>
                An expression is said to be in normal form if there
                are no reductions that can be performed.
            </p><p class="fragment">
                The <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem">Church-Rosser
                theorem</a> proves that if an expression has a normal
                form there is only one.  When more than one reduction
                is possible the order will not result in different
                final forms.
            </p>
        </section><section>
            <h3>Normal Form: Examples</h3>
            <ul><li class="fragment">
                a <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                &#x03bb;a.a <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                a (&#x03bb;b.b) c <span class="fragment">&#10003;</span>
            </li><li class="fragment">
                (&#x03bb;a.a) &#x03bb;b.&#x03bb;c.b
                <span class="fragment">
                    &#x2aa2; a [a := &#x03bb;b.&#x03bb;c.b]
                </span><span class="fragment">
                    &#x25b7; &#x03bb;b.&#x03bb;c.b
                </span><span class="fragment">&#10003;</span>
            </li><li class="fragment">
                (&#x03bb;a.a) ((&#x03bb;b.b) &#x03bb;c.c)
                <span class="fragment">
                    &#x2aa2; a [a := (&#x03bb;b.b) &#x03bb;c.c]
                </span><span class="fragment">
                    &#x25b7; <br />(&#x03bb;b.b) &#x03bb;c.c
                </span><span class="fragment">
                    &#x2aa2; b [b := &#x03bb;c.c]
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.c
                </span><span class="fragment">&#10003;</span>
            </li></ul><aside class="notes">
                Let's look at some examples of expressions in normal
                form.
            </aside>
        </section><section>
            <h3>Ad Infinitum</h3>
            <p>
                Not all expressions have a normal from.
            </p><p class="fragment">
                (&#x03bb;a.a a) &#x03bb;a.a a
                <span class="fragment">
                    &#x2aa2; a a [a := &#x03bb;a.a a]
                </span><span class="fragment">
                    &#x25b7; <br /> (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">
                    &#x25b7; <br /> (&#x03bb;a.a a) &#x03bb;a.a a
                </span><span class="fragment">&#x25b7; ...</span>
            </p><p class="fragment">
                This is a simple example, but there could be cycles
                or complex sequences that don't terminate.
            </p>
        </section><section>
            <h3>Normal Order</h3>
            <p>
                Normal order performs the outer most, left most
                reduction first when more than one are available.
            <p class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x2aa2; a a [a := ((&#x03bb;b.b) c)]
                </span><span class="fragment">
                    &#x25b7; <br />((&#x03bb;b.b) c) ((&#x03bb;b.b) c)
                </span><span class="fragment">
                    &#x2aa2; b [b := c] ((&#x03bb;b.b) c)
                </span><span class="fragment">
                    &#x25b7; <br /> c ((&#x03bb;b.b) c)
                </span><span class="fragment">
                    &#x2aa2; c (b [b := c])
                </span><span class="fragment">
                    &#x25b7; c c
                </span><span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                Normal order is guaranteed to reach a normal form
                for any expression if one exists.
            </p>
        </section><section>
            <h3>Applicative Order</h3>
            <p>
                A disadvantage of normal form is that it can evaluate
                parts of an expression many times.  Applicative
                evaluation solves this problem.
            </p><p class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x2aa2; (&#x03bb;a.a a) (b [b := c])
                </span><span class="fragment">
                    &#x25b7; <br /> (&#x03bb;a.a a) c
                </span><span class="fragment">
                    &#x2aa2; a a [a := c]
                </span><span class="fragment">
                    &#x25b7; c c
                </span><span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                Only two reductions were necessary.
            </p>
        </section><section>
            <h3>A Little Too Eager</h3>
            <p>
                Sometimes applicative order fails...
            </p><p>
                (&#x03bb;a.&#x03bb;b.a) c
                ((&#x03bb;d.d d) &#x03bb;d.d d)
            </p><table class="order"><tr><td><ul class="fragment">
                Normal Order                
                <li class="fragment">
                    &#x25b7; (&#x03bb;b.c) ((&#x03bb;d.d d)
                    &#x03bb;d.d d)
                </li><li class="fragment">
                    &#x25b7; c <span class="fragment">&#10003;</span>
                </li></ul>
            </td><td><ul class="fragment">
                Applicative Order
                <li class="fragment">
                    &#x25b7; (&#x03bb;a.&#x03bb;b.a) c
                    ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    &#x25b7; (&#x03bb;a.&#x03bb;b.a) c
                    ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    &#x25b7; (&#x03bb;a.&#x03bb;b.a) c
                    ((&#x03bb;d.d d) &#x03bb;d.d d)
                </li><li class="fragment">
                    ...
                </li></ul>
            </td></tr></table><p class="fragment">
                Stable or efficient -- pick one!
            </p>
        </section><section>
            <h3>Lazy Evaluation</h3>
            <p>
                Lazy evaluation is like normal order but it keeps
                of expressions so they're evaluated only once.
            </p><ul><li class="fragment">
                (&#x03bb;a.a a) ((&#x03bb;b.b) c)
                <span class="fragment">
                    &#x2aa2; a a [a := ((&#x03bb;b.b) c)]
                </span><span class="fragment">
                    &#x25b7; <br />
                    (<span class="intro">(&#x03bb;b.b) c</span>)
                    (<span class="intro">(&#x03bb;b.b) c</span>)
                <span class="fragment">&#x25b7; c c</span>
                <span class="fragment">&#10003;</span>
            </li></ul><p class="fragment">
                Stable, efficient... and tricky to implement.
            </p>
        </section><section>
            <h3>Currying</h3>
            <p>
                Frege (1893 CE) pointed out that single argument
                functions can emulate multi-argument functions.
            </p><ul class="examples"><li class="fragment">
                (&#x03bb;a.&#x03bb;b.<span class="expression">E</span>)
                <span class="expression">F</span>
                <span class="expression">G</span>
                <span class="fragment">
                    &#x25b7;
                    (&#x03bb;b.(<span class="expression">E</span>
                    [a := <span class="expression">F</span>]))
                    <span class="expression">G</span>
                </span><span class="fragment">
                    &#x25b7; <span class="expression">E</span>
                    [a := <span class="expression">F</span>,
                    b := <span class="expression">G</span>]
                </span>
            </li><li class="fragment">
                (&#x03bb;a.&#x03bb;b.&#x03bb;c.<span
                class="expression">E</span>)
                <span class="expression">F</span>
                <span class="expression">G</span>
                <span class="expression">H</span>
                <span class="fragment">
                    &#x25b7;
                    (&#x03bb;b.&#x03bb;c.(<span
                    class="expression">E</span>
                    [a := <span class="expression">F</span>]))
                    <span class="expression">G</span>
                    <span class="expression">H</span>
                </span><span class="fragment">
                    &#x25b7; <br />
                    (&#x03bb;c.(<span class="expression">E</span>
                    [a := <span class="expression">F</span>,
                    b := <span class="expression">G</span>]))
                    <span class="expression">H</span>
                </span><span class="fragment">
                    &#x25b7; <span class="expression">E</span>
                    [a := <span class="expression">F</span>,
                    b := <span class="expression">G</span>,
                    c := <span class="expression">H</span>]
                </span>
            </li><li class="fragment">
                (&#x03bb;a.&#x03bb;b.<span class="expression">E</span>)
                <span class="expression">F</span>
                <span class="fragment">
                    &#x25b7;
                    &#x03bb;b.(<span class="expression">E</span>
                    [a := <span class="expression">F</span>])
                </span>
            </li></ul><p class="fragment">
                Supplying some but not all arguments is allowed.
            </p>
        </section><section>
            <h3>Multi-Argument Notation</h3>
            <p>
                Nested abstractions have a convenient short hand.
            </p><p class="fragment">
                &#x03bb;<span class="variable">a</span>
                <span class="variable"
                >b</span>.</span><span class="expression">E</span>
                &#x225d; &#x03bb;<span class="variable"
                >a</span>.&#x03bb;<span class="variable"
                >b</span>.<span class="expression">E</span>
            </p><p class="fragment">
                &#x03bb;<span class="variable">a</span>
                <span class="variable"
                >b</span> <span class="variable"
                >c</span>.</span><span class="expression">E</span>
                &#x225d; &#x03bb;<span class="variable"
                >a</span>.&#x03bb;<span class="variable"
                >b</span>.&#x03bb;<span class="variable"
                >c</span>.<span class="expression">E</span>
            </p><p class="fragment">
                ...
            </p><p class="fragment">
                Spaces separate variables.
            </p>
        </section><section>
            <h3>Lambda Calculus</h3>
            <ul><li>
                Variables: <span class="variable">v</span> :=
                "[^&#x03bb;.()\s]+"
            </li><li>
                Expressions:
                <span class="expression">E</span> :=
                <span class="variable">v</span> |
                &#x03bb;<span class="variable"
                        >v</span>.<span class="expression">E</span> |
                <span class="expression">E</span>
                <span class="expression">E</span> |
                (<span class="expression">E</span>)
            </li><li>
                Free Variables: FV[<span class="expression">E</span>]
                &#x2282; <span class="variable">v</span>
            </li><li>
                Equivalence:
                <span class="variable">b</span> &#x2209;
                FV[<span class="expression">E</span>] &#x27f9;
                &#x03bb;<span class="variable"
                >a</span>.<span class="expression">E</span> &#x2251;
                &#x03bb;<span class="variable"
                >b</span>.(<span class="expression">E</span>
                [<span class="variable">a</span> :=
                <span class="variable">b</span>])
            </li><li>
                Reduction:
                (&#x03bb;<span class="variable"
                >a</span>.<span class="expression">E</span>)
                <span class="expression">F</span> ... &#x25b7;
                <span class="expression">E</span>
                [<span class="variable">a</span> :=
                <span class="expression">F</span>] ...
            </li><li class="extra">
                Left-Associative:
                <span class="expression">E F G</span> &#x2251;
                (<span class="expression">E F</span>)
                <span class="expression">G</span>
            </li><li class="extra">
                Multi-Argument: &#x03bb;<span class="variable">a
                b</span>.</span><span class="expression">E</span>
                &#x225d;
                &#x03bb;<span class="variable"
                >a</span>.&#x03bb;<span class="variable"
                >b</span>.<span class="expression">E</span>
            </li></ul>
        </section><section>
            <h3>Lambda Playground</h3>
            <div class="lambda"
                 data-expr="(&#x03bb;n.n ((&#x03bb;a b.a)
                        (&#x03bb;a b.b)) (&#x03bb;a b.a))
                        (&#x03bb;a b.b)"></div>
            <p>
                This is a JavaScript
                <a href="../apps/lambda">implementation</a>.
            </p>
        </section>
    </section><section>
        <section>
            <h2>Lambda Computation</h2>
            <p>
                Lambda calculus is certainly simple.  But isn't it
                supposed to be universal?
            </p>
        </section><section>
            <h3>Missing Features</h3>
            <p>
                Some things lambda calculus seems to lack:
            </p><ul><li class="fragment">
                Boolean Logic
            </li><li class="fragment">
                Numbers
            </li><li class="fragment">
                Arithmetic
            </li><li class="fragment">
                Flow Control
            </li><li class="fragment">
                Data Structures
            </li></ul><p class="fragment">
                We can construct these!
            </p>
        </section><section>
            <h3>Boolean Logic</h3>
            <p>
                One thing we might want to compute is boolean logic.
                Everything must evaluate to true or false.  How could
                we represent these in lambda calculus?
            </p>
            <ul><li class="fragment">
                <span class="true">TRUE</span> &#x225d;
                &#x03bb;a b.a [Kestral]
            </li><li class="fragment">
                <span class="false">FALSE</span> &#x225d;
                &#x03bb;a b.b [Kite]
            </li></ul>
        </section><section>
            <h3>Conditionals</h3>
            <p>
                IF p THEN ELSE
            </p><ul><li class="fragment">
                (&#x03bb;p a b.p a b) p THEN ELSE
                <span class="fragment">&#x25b7;
                    p THEN ELSE
                </span>
            </li><li class="fragment">
                TRUE THEN ELSE
                <span class="fragment">
                    &#x25b7; (&#x03bb;a b.a) THEN ELSE
                </span><span class="fragment">
                    &#x25b7; THEN
                </span>
            </li><li class="fragment">
                FALSE THEN ELSE
                <span class="fragment">
                    &#x25b7; (&#x03bb;a b.b) THEN ELSE
                </span><span class="fragment">
                    &#x25b7; ELSE
                </span>
            </li></ul><p class="fragment">
                We don't need a conditional operator.
            </p>
        </section><section>
            <h3>Accentuate the Negative</h3>
            <p>
                NOT: &#x03bb;p a b.p b a [Cardinal]
            </p><table><tr><td><ul><li class="fragment">
                NOT TRUE
            </li><li class="fragment">
                &#x03bb;a b.TRUE b a
            </li><li class="fragment">
                &#x03bb;a b.b
                <span class="fragment">&#x25b7; FALSE</span>
            </li></ul></td><td><ul><li class="fragment">
                NOT FALSE
            </li><li class="fragment">
                &#x03bb;a b.FALSE b a
            </li><li class="fragment">
                &#x03bb;a b.a
                <span class="fragment">&#x25b7; TRUE</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Conjunction Junction</h3>
            <p>
                AND: &#x03bb;p q.p q p
            </p><table><tr><td><ul><li class="fragment">
                AND TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                AND TRUE FALSE
            </li><li class="fragment">
                TRUE FALSE TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                AND FALSE TRUE
            </li><li class="fragment">
                FALSE TRUE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td><td><ul><li class="fragment">
                AND FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table>
        </section><section>
            <h3>Disjunction Junction</h3>
            <p>
                OR: &#x03bb;p q.p p q
            </p><table><tr><td><ul><li class="fragment">
                OR TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                OR TRUE FALSE
            </li><li class="fragment">
                TRUE TRUE FALSE
            </li><li class="fragment">
                TRUE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                OR FALSE TRUE
            </li><li class="fragment">
                FALSE FALSE TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                OR FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE FALSE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table>
        </section><section>
            <h3>Equality for Booleans</h3>
            <p>
                BOOLEQ?: &#x03bb;p q.p q (NOT q)
            </p><table class="large"><tr><td><ul><li class="fragment">
                BOOLEQ? TRUE TRUE
            </li><li class="fragment">
                TRUE TRUE (NOT TRUE)
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                BOOLEQ? TRUE FALSE
            </li><li class="fragment">
                TRUE FALSE (NOT FALSE)
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr><tr><td><ul><li class="fragment">
                BOOLEQ? FALSE TRUE
            </li><li class="fragment">
                FALSE TRUE (NOT TRUE)
            </li><li class="fragment">
                NOT TRUE
                <span class="fragment">&#x25b7; FALSE</span>
            </li></ul></td><td><ul><li class="fragment">
                BOOLEQ? FALSE FALSE
            </li><li class="fragment">
                FALSE FALSE (NOT FALSE)
            </li><li class="fragment">
                NOT FALSE
                <span class="fragment">&#x25b7; TRUE</span>
            </li></ul></td></tr></table>
        </section><section>
            <h3>Review: Boolean Logic</h3>
            <ul><li>
                TRUE: &#x03bb;a b.a [Kestral]
            </li><li>
                FALSE: &#x03bb;a b.b [Kite]
            </li><li>
                NOT: &#x03bb;p a b.p b a [Cardinal]
            </li><li>
                AND: &#x03bb;p q.p q p
            </li><li>
                OR: &#x03bb;p q.p p q
            </li><li>
                BOOLEQ?: &#x03bb;p q.p q (NOT q)
            </li></ul>
        </section><section>
            <h3>Numbers</h3>
            <p>
                Church Numerals represent numbers with repeated
                application.  Conceptually:
                <span class="intro">
                    n = &#x03bb;f a.f<sup>n</sup> a
                </span>
            </p><ul><li class="fragment">
                ONE: &#x03bb;f a.f a
            </li><li class="fragment">
                TWO: &#x03bb;f a.f (f a)
            </li><li class="fragment">
                THREE: &#x03bb;f a.f (f (f a))
            </li><li class="fragment">
                ...
            </li></ul><aside class="notes">
                There are several ways to represent numbers in
                lambda calculus but we will concer ourselves only
                with Church numerals.
            </aside>
        </section><section>
            <h3>Noting Succeeds like Successor</h3>
            <p>
                Natural numbers consist of zero and its successors.
            </p><p class="fragment">
                ZERO: &#x03bb;f a.a
                <span class="fragment">[Kite/FALSE]</span>
            </p><p class="fragment">
                SUCCESSOR: &#x03bb;n f a.f (n f a)
            </p><aside class="notes">
                Zero applies a function to a starting point zero
                times, which makes it the same as false.  Successor
                applies the function one extra time.
            </aside>
        </section><section>
            <h3>Successor: Examples</h3>
            <p>
                SUCCESSOR: &#x03bb;n f a.f (n f a)
            </p><table><tr><td><ul><li class="fragment">
                SUCCESSOR ZERO
            </li><li class="fragment">
                &#x03bb;f a.f (ZERO f a)
            </li><li class="fragment">
                &#x03bb;f a.f ((&#x03bb;f a.a) f a)
            </li><li class="fragment">
                &#x03bb;f a.f a <span class="fragment">[ONE]</span>
            </li></ul></td><td><ul><li class="fragment">
                SUCCESSOR ONE
            </li><li class="fragment">
                &#x03bb;f a.f (ONE f a)
            </li><li class="fragment">
                &#x03bb;f a.f ((&#x03bb;f a.f a) f a)
            </li><li class="fragment">
                &#x03bb;f a.f (f a) <span class="fragment">[TWO]</span>
            </li></ul></td></tr></table><p class="fragment">
                And so on.
            </p><aside class="notes">
                All natural numbers can be reached with a finite
                number of successor operations.
            </aside>
        </section><section>
            <h3>Addition</h3>
            <p>
                Take the successor repeatedly to add:
            </p><p>
                ADD: &#x03bb;m n.n SUCCESSOR m
            </p><ul><li class="fragment">
                ADD THREE TWO
            </li><li class="fragment">
                TWO SUCCESSOR THREE
            </li><li class="fragment">
                SUCCESSOR (SUCCESSOR THREE)
            </li><li class="fragment">
                SUCCESSOR FOUR
            </li><li class="fragment">
                FIVE
            </li></ul><aside class="notes">
                Addition works for all natural numbers.
            </aside>
        </section><section>
            <h3>Multiplication</h3>
            <p>
                Compose numbers to multiply:
            </p><p>
                MULTIPLY: &#x03bb;m n f.m (n f) [Bluebird]
            </p><ul><li class="fragment">
                MULTIPLY THREE TWO
            </li><li class="fragment">
                &#x03bb;f.THREE (TWO f)
            </li><li class="fragment">
                &#x03bb;f.(&#x03bb;f a.f (f (f a)))
                ((&#x03bb;f a.f (f a)) f)
            </li><li class="fragment">
                &#x03bb;f.(&#x03bb;f a.f (f (f a))) (&#x03bb;a.f (f a))
            </li><li class="fragment">
                &#x03bb;f.&#x03bb;a.f (f (f (f (f (f a)))))
            </li><li class="fragment">
                &#x03bb;f a.f (f (f (f (f (f a)))))
                <span class="fragment">[SIX]</span>
            </li></ul><aside class="notes">
                Multiplication works for all natural numbers.
            </aside>
        </section><section>
            <h3>Exponentiation</h3>
            <p>
                Raise one number to the power of another:
            </p><p>
                POWER: &#x03bb;n m.m n [Thrush]
            </p><ul><li class="fragment">
                POWER THREE TWO
            </li><li class="fragment">
                TWO THREE
            </li><li class="fragment">
                (&#x03bb;f a.f (f a)) &#x03bb;f a.f (f (f a))
            </li><li class="fragment">
                ...
            </li><li class="fragment">
                &#x03bb;f a.f (f (f (f (f (f (f (f (f a))
                <span class="fragment">[NINE]</span>
            </li></ul><aside class="notes">
                Exponentiation works for all natural numbers.
            </aside>
        </section><section>
            <h3>Exponentiation: Demo</h3>
            <div class="lambda" data-library="true"
                 data-expr="POWER THREE TWO"></div>
        </section><section>
            <h3>Review: Numbers and Arithmetic</h3>
            <ul><li>
                ZERO: &#x03bb;f a.a [Kite/FALSE]
            </li><li>
                SUCCESSOR: &#x03bb;n f a.f (n f a)
            </li><li>
                ADD: &#x03bb;m n.n SUCCESSOR m
            </li><li>
                MULTIPLY: &#x03bb;m n f.m (n f) [Bluebird]
            </li><li>
                POWER: &#x03bb;n m.m n [Thrush]
            </li></ul>
        </section><section>
            <h3>Subtraction</h3>
            <p>
                Subtraction is addition reversed.
            </p><p class="fragment">
                SUBTRACT: &#x03bb;m n.n PREDECESSOR m
            </p><p class="fragment">
                PREDECESSOR: &#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b
            </p>
        </section><section>
            <h3>Predecessor Two</h3>
            <ul><li class="fragment">
                (&#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b) &#x03bb;f a.f (f a)
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;f a.f (f a)) (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;g h.h (g f)) ((&#x03bb;g h.h (g f))
                (&#x03bb;c.a)) &#x03bb;b.b
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;h.h (((&#x03bb;g h.h (g f))
                (&#x03bb;c.a)) f)) &#x03bb;b.b
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;b.b) (((&#x03bb;g h.h (g f))
                (&#x03bb;c.a)) f)
            </li><li class="fragment">
                &#x03bb;f a.((&#x03bb;g h.h (g f))
                (&#x03bb;c.a)) f
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;h.h ((&#x03bb;c.a) f)) f
            </li><li class="fragment">
                &#x03bb;f a.f ((&#x03bb;c.a) f)
                <span class="fragment">
                    &#x25b7; &#x03bb;f a.f a
                </span><span class="fragment">[ONE]</span>
            </li></ul>
        </section><section>
            <h3>Predecessor One</h3>
            <ul><li class="fragment">
                (&#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b) &#x03bb;f a.f a
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;f a.f a) (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;h.h ((&#x03bb;c.a) f))
                &#x03bb;b.b
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;b.b) ((&#x03bb;c.a) f)
            </li><li class="fragment">
                &#x03bb;f a.((&#x03bb;c.a) f)
                <span class="fragment">
                    &#x25b7; &#x03bb;f a.a
                </span><span class="fragment">[ZERO]</span>
            </li></ul>
        </section><section>
            <h3>Predecessor Zero</h3>
            <ul><li class="fragment">
                (&#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b) &#x03bb;f a.a
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;f a.a) (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b
            </li><li class="fragment">
                &#x03bb;f a.(&#x03bb;c.a) &#x03bb;b.b
                <span class="fragment">
                    &#x25b7; &#x03bb;f a.a
                </span><span class="fragment">[ZERO]</span>
            </li></ul><p class="fragment">
                Zero has no predecessor but our operator reduces to
                zero.  This isn't strictly correct but is useful.
            </p>
        </section><section>
            <h3>Division</h3>
            <p>
                Division is multiplication reversed.
            </p><p class="fragment">
                DIVIDE:
                &#x03bb;n.((&#x03bb;f.(&#x03bb;a.f (a a))
                &#x03bb;a.f (a a))
                &#x03bb;c n m f a.(&#x03bb;d.(&#x03bb;n.n
                (&#x03bb;a.&#x03bb;a b.b) &#x03bb;a b.a) d a
                (f (c d m f a))) <br /> ((&#x03bb;m n.n
                (&#x03bb;n f a.n (&#x03bb;g h.h (g f))
                (&#x03bb;c.a) &#x03bb;b.b) m) n m))
                ((&#x03bb;n f a.f (n f a)) n)
            </p><p class="fragment">
                Any questions?  Of course not.  Moving on...
            </p>
        </section><section>
            <h3>Zero Test</h3>
            <p>
                We can ask questions about numbers:
            </p><p>
                IS-ZERO?: &#x03bb;n.n (&#x03bb;a.FALSE) TRUE
            </p><table class="large"><tr><td><ul><li class="fragment">
                IS-ZERO? ZERO
            </li><li class="fragment">
                ZERO (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                (&#x03bb;f a.a) (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                IS-ZERO? ONE
            </li><li class="fragment">
                (&#x03bb;f a.f a) (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                (&#x03bb;a.FALSE) TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td></tr></table><p class="fragment">
                What happens if we ask about a successor of one?
            </p>
        </section><section>
            <h3>Even</h3>
            <p>
                How can we ask whether a number is even?
            </p><p class="fragment">
                IS-EVEN?: &#x03bb;n.n NOT TRUE
            </p><table class="xlarge"><tr><td><ul><li class="fragment">
                IS-EVEN? ZERO
            </li><li class="fragment">
                ZERO NOT TRUE
            </li><li class="fragment">
                (&#x03bb;f a.a) NOT TRUE
            </li><li class="fragment">
                TRUE
            </li></ul></td><td><ul><li class="fragment">
                IS-EVEN? ONE
            </li><li class="fragment">
                (&#x03bb;f a.f a) NOT TRUE
            </li><li class="fragment">
                NOT TRUE
            </li><li class="fragment">
                FALSE
            </li></ul></td><td><ul><li class="fragment">
                IS-EVEN? TWO
            </li><li class="fragment">
                (&#x03bb;f a.f (f a)) NOT TRUE
            </li><li class="fragment">
                NOT (NOT TRUE)
            </li><li class="fragment">
                TRUE
            </li></ul></td></tr></table><p class="fragment">
                How could we define IS-ODD?
            </p>
        </section><section>
            <h3>Comparisons</h3>
            <ul class="examples"><li class="fragment">
                LESSEQ?: &#x03bb;n m.IS-ZERO? (SUBTRACT n m)
            </li><li class="fragment">
                GREATEREQ?: &#x03bb;n m.IS-ZERO? (SUBTRACT m n)
            </li><li class="fragment">
                EQUAL?: &#x03bb;n m.AND (LESSEQ? n m) (LESSEQ? m n)
            </li><li class="fragment">
                LESS?: &#x03bb;n m.NOT (GREATEREQ? n m)
            </li><li class="fragment">
                GREATER?: &#x03bb;n m.NOT (LESSEQ? n m)
            </li></ul>
        </section><section>
            <h3>Comparisons: Demo</h3>
            <div class="lambda" data-library="true"
                 data-expr="EQUAL? 5 (ADD 2 3)"></div>
        </section><section>
            <h3>Flow Control</h3>
            <p>
                We can easily use a Church numeral directly to loop a
                fixed number of times.
            </p><p class="fragment">
                However, we still don't have a way to stop a loop when
                some condition is met.  That's an important gap in our
                programming ability.
            </p>
        </section><section id="loops">
            <h3>Lambda Loops</h3>
            <p>
                These require statements, which we don't have.
                See <a href="#recursion">recursion</a>.
            </p>
        </section><section id="recursion">
            <h3>Lambda Recursion</h3>
            <p>
                These require named functions, which we don't have.
                See <a href="#loops">loops</a>.
            </p>
        </section><section>
            <h3>Fixed Point Combinator</h3>
            <p>
                Normal order fixed point (or Y) combinator:
            </p><p class="fragment">
                FIX &#x225d; &#x03bb;f.(&#x03bb;a.f (a a))
                &#x03bb;a.f (a a)
            </p><p class="fragment">
                FIX g
                <span class="fragment">
                    &#x25b7; (&#x03bb;a.g (a a))
                    &#x03bb;a.g (a a)
                </span><span class="fragment">
                    &#x25b7; <br />
                    g ((&#x03bb;a.g (a a)) &#x03bb;a.g (a a))
                </span><span class="fragment">
                    &#x2251; g (FIX g)
                </span><span class="fragment">
                    &#x25b7; <br /> g (g (FIX g))
                </span><span class="fragment">
                    &#x25b7; g (g (g (FIX g)))
                </span><span class="fragment">
                    &#x25b7; ...
                </span>
            </p><p class="fragment">
                Forever? Normal order reduces outer most first.
            </p>
        </section><section>
            <h3>Factorial</h3>
            <p>
                FSTEP: (&#x03bb;f n.IS-ZERO? n ONE <br />
                (MULTIPLY n (f (PREDECESSOR n))))
            </p><p class="fragment">
                FACTORIAL &#x225d; FIX FSTEP
            </p>
        </section><section>
            <h3>Factorial Example</h3>
            <p>
                FACTORIAL ONE
                <span class="fragment"> &#x225d; FIX FSTEP ONE</span>
            </p>
            <ul class="examples"><li class="fragment">
                FIX FSTEP ONE &#x25b7; FSTEP (FIX FSTEP) ONE
            </li><li class="fragment">
                <span class="false">IS-ZERO? ONE</span> ONE
                (MULTIPLY ...)
            </li><li class="fragment">
                MULTIPLY ONE (FIX FSTEP
                (<span class="intro">PREDECESSOR ONE</span>))
            </li><li class="fragment">
                MULTIPLY ONE (<span class="intro">FIX FSTEP</span> ZERO)
            </li><li class="fragment">
                MULTIPLY ONE (<span class="intro">FSTEP
                (FIX FSTEP) ZERO</span>)
            </li><li class="fragment">
                MULTIPLY ONE (<span class="true">IS-ZERO?
                ZERO</span> ONE (...))
            </li><li class="fragment">
                MULTIPLY ONE ONE
                <span class="fragment">&#x25b7; ONE</span>
            </li></ul>
        </section><section>
            <h3>Factorial: Demo</h3>
            <div class="lambda" data-library="true"
                 data-expr="FACTORIAL 2"></div>
        </section><section>
            <h3>Factorial Steps</h3>
            <table><tr><th>
                Factorial</th><th>Result</th><th>Steps
                </th></tr><tr><td>
                    0!</th><td>1</td><td>9
                    </td></tr><tr><td>
                        1!</th><td>1</td><td>30
                        </td></tr><tr><td>
                            2!</th><td>2</td><td>127
                            </td></tr><tr><td>
                                3!</th><td>6</td><td>646
                                </td></tr><tr><td>
                                    4!</th><td>24</td><td>3,873
                                    </td></tr><tr><td>
                                        5!</th><td>120</td><td>26,899
                                        </td></tr><tr><td>
                                            ...</th><td>...</td><td>...
                                            </td></tr></table>
        </section><section>
            <h3>Division</h3>
            <p>
                Let's revisit division:
            </p><p class="fragment">
                DIVIDE: n.FIX (c n m f a.(d.IS-ZERO? d a <br />
                (f (c d m f a))) (SUBTRACT n m)) (SUCCESSOR n)
            </p><p class="fragment">
                This is just repeated subtraction.
            </p>
        </section><section>
            <h3>Division: Demo</h3>
            <div class="lambda" data-library="true"
                 data-expr="DIVIDE 9 3"></div>
        </section><section>
            <h3>Ordered Pairs</h3>
            <p>
                We can take advantage of closure to store values.
            </p><ul><li class="fragment">
                PAIR: &#x03bb;a b f.f a b [Verio]
            </li><li class="fragment">
                HEAD: &#x03bb;p.p TRUE
            </li><li class="fragment">
                TAIL: &#x03bb;p.p FALSE
            </li></ul><p class="fragment">
                This will serve as a foundation for data structures.
            </p>
        </section><section>
            <h3>Ordered Pairs</h3>
            <p>
                How does this work in practice?
            </p><ul><li class="fragment">
                PAIR FIRST LAST
                <span class="fragment">
                    &#x25b7; (&#x03bb;a b f.f a b) FIRST LAST
                </span><span class="fragment">
                    &#x25b7; <br />(&#x03bb;b f.f FIRST b) LAST
                </span><span class="fragment">
                    &#x25b7; &#x03bb;f.f FIRST LAST
                </span>
            </li><li class="fragment">
                HEAD (PAIR FIRST LAST)
                <span class="fragment">
                    &#x25b7; <br />
                    (&#x03bb;p.p TRUE) &#x03bb;f.f FIRST LAST
                </span><span class="fragment">
                    &#x25b7; <br />(&#x03bb;f.f FIRST LAST) TRUE
                </span><span class="fragment">
                    &#x25b7; <br />TRUE FIRST LAST
                </span><span class="fragment">
                    &#x25b7; FIRST
                </span>
            </li><li class="fragment">
                TAIL (PAIR FIRST LAST)
                <span class="fragment">
                    &#x25b7; ... &#x25b7; <br />FALSE FIRST LAST
                </span><span class="fragment">
                    &#x25b7; LAST
                </span>
            </li></ul>
        </section><section>
            <h3>Lists</h3>
            <p>
                Chaining ordered pairs together to make lists requires
                a way to find the end.
            </p><ul><li class="fragment">
                IS-NIL?: &#x03bb;p.p &#x03bb;a b.FALSE
            </li><li class="fragment">
                NIL: &#x03bb;f.TRUE
            </li></ul>
        </section><section>
            <h3>Lists</h3>
            <p>
                IS-NIL? NIL
            </p><ul><li class="fragment">
                (&#x03bb;p.p &#x03bb;a b.FALSE) &#x03bb;f.TRUE
            </li><li class="fragment">
                (&#x03bb;f.TRUE) &#x03bb;a b.FALSE
                <span class="fragment">&#x25b7; TRUE</span>
            </li></ul>
        </section><section>
            <h3>Lists</h3>
            <p>
                IS-NIL? (PAIR FIRST LAST)
            </p><ul><li class="fragment">
                (&#x03bb;p.p &#x03bb;a b.FALSE) (PAIR FIRST LAST)
            </li><li class="fragment">
                (PAIR FIRST LAST) &#x03bb;a b.FALSE
            </li><li class="fragment">
                (&#x03bb;f.f FIRST LAST) &#x03bb;a b.FALSE
            </li><li class="fragment">
                (&#x03bb;a b.FALSE) FIRST LAST
                <span class="fragment">&#x25b7; FALSE</span>
            </li></ul>
        </section><section>
            <h3>Lists</h3>
            <p>
                Now we can construct lists of arbitrary length.
            </p><ul><li class="fragment">
                PAIR ONE NIL
            </li><li class="fragment">
                PAIR ONE (PAIR TWO NIL)
            </li><li class="fragment">
                PAIR ONE (PAIR TWO (PAIR THREE NIL))
            </li><li class="fragment">
                ...
            </li></ul><p class="fragment">
                So how do we work with these?
            </p>
        </section><section>
            <h3>Select</h3>
            <p>
                We can traverse a list using Church numerals.
            </p><p>
                NTH: &#x03bb;n l.n (&#x03bb;l.IS-NIL? l
                NIL (TAIL l)) l
            </p><ul><li class="fragment">
                NTH ONE (PAIR a (PAIR b (PAIR c NIL)))
            </li><li class="fragment">
                &#x25b7; ONE (&#x03bb; l.IS-NIL? l
                NIL (TAIL l)) (PAIR ...)
            </li><li class="fragment">
                &#x25b7; (&#x03bb; l.IS-NIL? l
                NIL (TAIL l)) (PAIR ...)
            </li><li class="fragment">
                &#x25b7; IS-NIL? (PAIR ...)
                NIL (TAIL (PAIR ...))
            </li><li class="fragment">
                &#x25b7; TAIL (PAIR a (PAIR b (PAIR c NIL)))
            </li><li class="fragment">
                    &#x25b7; PAIR b (PAIR c NIL)
            </li></ul><p class="fragment">
                An index beyond the end of the list will give NIL
            </p>
        </section><section>
            <h3>Sums</h3>
            <p>
                Let's add up a list of numbers.
            </p><ul><li class="fragment">
                SUM (PAIR ONE (PAIR TWO (PAIR THREE NIL)))
            </li><li class="fragment">
                SUM &#x225d; FIX (&#x03bb;f l.IS-NIL? l ZERO <br />
                (ADD (HEAD l) (f (TAIL l))))
            </li><li class="fragment">
                ADD ONE (ADD TWO (ADD THREE ZERO))
                <span class="fragment">
                    &#x25b7; SIX
                </span>
            </li></ul>
        </section><section>
            <h3>Sums: Demo</h3>
            <div class="lambda" data-library="true"
                 data-expr="SUM (PAIR ONE (PAIR TWO 
                           (PAIR THREE NIL)))"></div>
        </section><section>
            <h3>Map</h3>
            <p>
                We can apply a function to every member of a list
            </p><ul><li class="fragment">
                MAP &#x225d; FIX (&#x03bb;f g l.IS-NIL? l NIL <br />
                (PAIR (g (HEAD l)) (f g (TAIL l))))
            </li><li class="fragment">
                MAP (&#x03bb;n.ADD n ONE) <br />
                (PAIR ONE (PAIR TWO (PAIR THREE NIL)))
            </li><li class="fragment">
                PAIR TWO (PAIR THREE (PAIR FOUR NIL))
            </li></ul>
        </section><section>
            <h3>Map: Demo</h3>
            <div class="lambda" data-library="true"
                 data-expr="MAP (&#x03bb;n.ADD n ONE) (PAIR ONE (PAIR TWO 
                        (PAIR THREE NIL)))"></div>
        </section><section>
            <h3>Review: Data Structures</h3>
            <ul><li>
                PAIR: &#x03bb;a b f.f a b [Verio]
            </li><li>
                HEAD: &#x03bb;p.p TRUE
            </li><li>
                TAIL: &#x03bb;p.p FALSE
            </li><li>
                NIL: &#x03bb;f.TRUE
            </li><li>
                IS-NIL?: &#x03bb;p.p &#x03bb;a b.FALSE
            </li></ul>
        </section><section>
            <h3>Integers</h3>
            <p>
                How can we construct an integer?  Consider a pair of
                Church numerals.  If we interpret them as a subtraction
                we can represent any integer value.
            </p><p class="fragment">
                INT-CREATE: PAIR n m
            </p><p class="fragment">
                This represents the integer <em>n - m</em>
            </p>
        </section><section>
            <h3>Integers</h3>
            <p>
                Here are some simple tools for integers.
            </p><ul class="examples"><li class="fragment">
                INT-IS-ZERO?: &#x03bb;n.EQUAL? (HEAD n) (TAIL n)
            </li><li class="fragment">
                INT-EQUAL?: &#x03bb;n m.EQUAL? <br />
                (ADD (HEAD n) (TAIL m))
                (ADD (HEAD m) (TAIL n))
            </li><li class="fragment">
                INT-NEGATE: &#x03bb;n.PAIR (TAIL n) (HEAD n)
            </li></ul>
        </section><section>
            <h3>Integers: Arithmetic</h3>
            <p>
                Integer arithmetic is messy but straightforward.
            </p><ul><li class="fragment">
                INT-ADD: &#x03bb;n m.PAIR (ADD (HEAD n) (HEAD m))
                <br />(ADD (TAIL n) (TAIL m))
            </li><li class="fragment">
                INT-MULTIPLY: &#x03bb;n m.PAIR <br />
                (ADD (MULTIPLY (HEAD n) (HEAD m))<br />
                (MULTIPLY (TAIL n) (TAIL m)))<br />
                (ADD (MULTIPLY (HEAD n) (TAIL m))<br />
                (MULTIPLY (TAIL n) (HEAD m)))
            </li></ul>
        </section><section>
            <h3>Rationals</h3>
            <p>
                How can we represent rational numbers?  Consider
                an pair of integers.  If we interpret this as a
                division we can represent any rational number.
            </p><p class="fragment">
                RATIONAL-CREATE: PAIR a b
            </p><p class="fragment">
                This represents the rational number <em>a / b</em>
            </p>
        </section><section>
            <h3>Rationals</h3>
            <p>
                Here are some simple tools for rational numbers.
            </p><ul><li class="fragment">
                RATIONAL-IS-ZERO?: &#x03bb;a.INT-IS-ZERO? (HEAD a)
            </li><li class="fragment">
                RATIONAL-EQUAL?: &#x03bb;a b.EQUAL? <br />
                (INT-MULTIPLY (HEAD a) (TAIL b)) <br />
                (INT-MULTIPLY (HEAD b) (TAIL a))
            </li><li class="fragment">
                RATIONAL-NEGATE: &#x03bb;a.PAIR <br />
                (INT-NEGATE (HEAD a)) (TAIL a)
            </li><li class="fragment">
                RATIONAL-INVERSE: &#x03bb;a.PAIR (TAIL a) (HEAD a)
            </li></ul>
        </section><section>
            <h3>Rationals: Arithmetic</h3>
            <p>
                And of course we can add and multiply.
            </p><ul><li class="fragment">
                RATIONAL-ADD: &#x03bb;n m.PAIR <br />
                (INT-ADD (INT-MULTIPLY (HEAD n) (TAIL m)) <br />
                (INT-MULTIPLY (HEAD m) (TAIL n))) <br />
                (INT-MULTIPLY (TAIL n) (TAIL m))
            </li><li class="fragment">
                RATIONAL-MULTIPLY: &#x03bb;n m.PAIR <br />
                (INT-MULTIPLY (HEAD m) (TAIL n))) <br />
                (INT-MULTIPLY (TAIL n) (TAIL m))
            </li></ul>
        </section><section>
            <h3>Lambda Computation</h3>
            <ul><li>
                Boolean Logic:
                <span class="true">&#x03bb;a b.a</span>,
                <span class="false">&#x03bb;a b.b</span>
            </li><li>
                Numbers: &#x03bb;f a.a, &#x03bb;n f a.f (n f a)
            </li><li>
                Arithmetic: &#x03bb;m n.n (&#x03bb;n f a.f (n f a)) m
            </li><li>
                Flow Control: &#x03bb;f.(&#x03bb;a.f (a a))
                &#x03bb;a.f (a a)
            </li><li>
                Data Structures: &#x03bb;a b f.f a b
            </li></ul><p>
                Lambda calculus simple, compact and universal.
            </p>            
        </section>
    </section><section>
        <section>
            <h3>Starling and Kestral</h3>
            <p>
                The Starling and Kestral combinators are universal
                (Schnfinkel 1924 CE).
                Like lambda calculus and Turing machines they can
                compute any computable function.
            </p><ul><li>
                Starling (S): &#x03bb;a b c.a c (b c)
            </li><li>
                Kestral (K): &#x03bb;a b.a
            </li></ul>
        </section><section>
            <h3>Combinators</h3>
            <p>
                A combinator is an abstraction that has no
                free variables.
                <span class="fragment">
                    FV[&#x03bb;<span class="variable"
                    >v</span>.<span class="expression">E</span>]
                    = {}
                </span>
            </p><p class="fragment">
                As a consequence they have no state or external
                interactions.
            </p>
        </section><section>
            <h3>Combinator Birds</h3>
            <p>
                Raymond Smullyan wrote a book about combinatory logic
                in 1985 CE titled
                <a href="https://en.wikipedia.org/wiki/To_Mock_a_Mockingbird">
                To Mock a Mockingbird</a>.
                Giving names to combinators helps us to remember them.
            </p>
        </section>
        <section>
            <h3>Meet the Birds</h3>
            <ul><li class="fragment">
                Ibis (Identity): &#x03bb;a.a
            </li><li class="fragment">
                Mockingbird (Self-Apply): &#x03bb;a.a a
            </li><li class="fragment">
                Kestral (True/Const): &#x03bb;a b.a
            </li><li class="fragment">
                Kite (False/Zero): &#x03bb;a b.b
            </li><li class="fragment">
                Cardinal (Flip/Not): &#x03bb;a b c.a c b
            </li><li class="fragment">
                Bluebird (Compose):
                &#x03bb;a b c.a (b c)
            </li><li class="fragment">
                Thrush (Power): &#x03bb;a b.b a
            </li><li class="fragment">
                Vireo (Pair): &#x03bb;a b c.c a b
            </li><li class="fragment">
                Starling (Fusion): &#x03bb;a b c.a c (b c)
            </li></ul>
        </section><section>
            <h3>Simplification: Identity</h3>
            <p>
                The identity has many Starling and Kestral forms:
            </p><ul><li class="fragment">
                S K X
                <span class="fragment">
                    &#x2aa2; (&#x03bb;a b c.a c (b c)) K X
                </span><span class="fragment">
                    &#x25b7; <br /> (&#x03bb;b c.K c (b c)) X
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.K c (X c)
                </span><span class="fragment">
                    &#x2aa2; <br /> &#x03bb;c.(&#x03bb;a b.a) c
                    <span class="false">(X c)</span>
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.c
                </span><span class="fragment">
                    &#x2aa2; I
                </span>
            </li></ul><p class="fragment">
                S K K
                <span class="fragment">
                    &#x2251; S K S
                </span><span class="fragment">
                    &#x2251; S K (anything)
                </span><span class="fragment">
                    &#x2251; I
                </span>
            </p>
        </section><section>
            <h3>Simplification: Kestral</h3>
            <p>
                A common pattern reduces to the Kestral:
            </p><p class="fragment">
                S (K K) I <span class="fragment">&#x2251; K</span>
            </p><p class="fragment">
                (&#x03bb;a b c.a c (b c)) (K K) I
                <span class="fragment">
                    &#x25b7; (&#x03bb;b c.(K K) c (b c)) I
                </span><span class="fragment">
                    &#x25b7; <br /> &#x03bb;c.(K K) c
                    (<span class="intro">I c</span>)
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.<span class="intro">K
                    K c</span> c
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.K c
                </span><span class="fragment">
                    &#x2aa2; &#x03bb;c.(&#x03bb;a b.a) c
                </span><span class="fragment">
                    &#x25b7; &#x03bb;c.&#x03bb;b.c
                </span><span class="fragment">
                    &#x2aa2; &#x03bb;c b.c
                </span><span class="fragment">
                    &#x2aa2; K
                </span>
            </p>
        </section><section>
            <h3>Converting Lambda</h3>
            <p>
                Any lambda term
                <a href="https://en.wikipedia.org/wiki/Combinatory_logic">
                    can be converted</a>.
            </p><ul><li class="fragment">
                T[a] &#x27f9;  a
            </li><li class="fragment">
                T[<span class="expression">E</span>
                <span class="expression">F</span>] &#x27f9;
                T[<span class="expression">E</span>]
                T[<span class="expression">F</span>]
            </li><li class="fragment">
                T[(<span class="expression">E</span>)] &#x27f9;
                (T[<span class="expression">E</span>])
            </li><li class="fragment">
                T[&#x03bb;a.<span class="expression">E</span>]
                &and; a&#x2209;FV[<span class="expression">E</span>]
                &#x27f9; K T[<span class="expression">E</span>]
            </li><li class="fragment">
                T[&#x03bb;a.a] &#x27f9; S K K
                <span class="fragment">&#x27f9; I</span>
            </li><li class="fragment">
                T[&#x03bb;a.&#x03bb;b.<span class="expression">E</span>]
                &and; a&#x2208;FV[<span class="expression">E</span>]
                &#x27f9; T[&#x03bb;a.T[&#x03bb;b.<span class="expression"
                >E</span>]]
            </li><li class="fragment">
                T[&#x03bb;a.<span class="expression">E</span>
                <span class="expression">F</span>]
                &and; a&#x2208;(FV[<span class="expression">E</span>]
                &cup;
                FV[<span class="expression">F</span>]) &#x27f9; <br />
                S T[&#x03bb;a.<span class="expression">E</span>]
                T[&#x03bb;a.<span class="expression">F</span>]]
            </li></ul>
        </section><section>
            <h3>Conversion: Thrush</h3>
            <p>
                Thrush: &#x03bb;a b.b a
            </p><ul><li class="fragment">
                T[&#x03bb;a b.b a]
                <span class="fragment">
                    &#x27f9;
                    T[&#x03bb;a.T[&#x03bb;b.b a]]
                </span>
            </li><li class="fragment">
                T[&#x03bb;a.S T[&#x03bb;b.b] T[&#x03bb;b.a]]
            </li><li class="fragment">
                T[&#x03bb;a.S I (K a)]
            </li><li class="fragment">
                S T[&#x03bb;a.(S I)] T[&#x03bb;a.K a]
            </li><li class="fragment">
                S (K (S I)) (S T[&#x03bb;a.K] T[&#x03bb;a.a])
            </li><li class="fragment">
                S (K (S I)) (S (K K) I)
            </li><li class="fragment">
                S (K (S I)) K
            </li></ul>
        </section><section>
            <h3>Conversion: Kite</h3>
            <p>
                The Kite is the Kestral followed by Identity:
            </p><p>
                Ki = K I
            </p><ul><li class="fragment">
                (&#x03bb;a b.a) &#x03bb;a.a
            </li><li class="fragment">
                &#x03bb;b.&#x03bb;a.a
            </li><li class="fragment">
                &#x03bb;b a.a
                <span class="fragment">
                    &#x2251; &#x03bb;a b.b
                </span>
            </li></ul>
        </section><section>
            <h3>Conversion: Mockingbird</h3>
            <p>
                Mockingbird is easy to make with Starling and Ibis
            </p><p>
                M = S I I
            </p><ul><li class="fragment">
                (&#x03bb;a b c.a c (b c)) (&#x03bb;a.a) (&#x03bb;a.a)
            </li><li class="fragment">
                &#x03bb;c.(&#x03bb;a.a) c ((&#x03bb;a.a) c)
            </li><li class="fragment">
                &#x03bb;c.c c
                <span class="fragment">
                    &#x2251; &#x03bb;a.a a
                </span>
            </li></ul>
        </section><section>
            <h3>S K Combinators</h3>
            <ul><li class="fragment">
                Ibis: I = S K K = S K S
            </li><li class="fragment">
                Mockingbird: M = S I I
            </li><li class="fragment">
                Kite: Ki = K I
            </li><li class="fragment">
                Cardinal: C = S ((S (K ((S (K S)) K))) S) (K K)
            </li><li class="fragment">
                Bluebird: B = S (K S) K
            </li><li class="fragment">
                Thrush: Th = S (K (S I)) K
            </li><li class="fragment">
                Vireo: V =  S (K (S (S (K (S (K S) K)) S) (K K)))
                <br />(S (K (S I)) K)
            </li><li class="fragment">
                FIX = S (K (S I I)) (S (S (K S) K) (K (S I I)))
            </li></ul>
        </section><section>
            <h3>There Can Be Only One</h3>
            <p>
                Chris Barker 2001 CE:
                <a href="https://en.wikipedia.org/wiki/Iota_and_Jot"
                >iota</a> combinator is universal
            </p><p class="fragment">
                i &#x225d; &#x03bb;f.f (&#x03bb;a b c.a c (b c))
                &#x03bb;d e.d
            </p><ul><li class="fragment">
                i i
                <span class="fragment">
                    = (&#x03bb;f.f S K) &#x03bb;f.f S K
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;f.f S K) S K
                </span><span class="fragment">
                    &#x25b7; <br />S S K K
                </span><span class="fragment">
                    &#x25b7; S K (K K)
                </span><span class="fragment">
                    &#x25b7; I
                </span>
            </li><li class="fragment">
                i (i (i i))
                <span class="fragment">
                    = (&#x03bb;f.f S K) ((&#x03bb;f.f S K) I)
                </span><span class="fragment">
                    &#x25b7; (&#x03bb;f.f S K) I S K
                </span><span class="fragment">
                    &#x25b7; <br />I S K S K
                </span><span class="fragment">
                    &#x25b7; S K S K
                </span><span class="fragment">
                    &#x25b7; I K
                </span><span class="fragment">
                    &#x25b7; K
                </span>
            </li><li class="fragment">
                i (i (i (i i)))
                <span class="fragment">
                    = (&#x03bb;f.f S K) K
                </span><span class="fragment">
                    &#x25b7; K S K
                </span><span class="fragment">
                    &#x25b7; S
                </span>
            </li></ul>
        </section><section>
            <h3>Binary Iota</h3>
            <p>
                Chris Barker created a simple binary encoding:
            </p><p>
                term := "1" | "0" term term
            </p><ul><li class="fragment">
                1 = i
            </li><li class="fragment">
                011 = i i = I
            </li><li class="fragment">
                0101011 = i (i (i i)) = K
            </li><li class="fragment">
                010101011 = i (i (i i)) = S
            </li></ul><p class="fragment">
                But remember... just because you can stick peas up
                your nose doesn't mean you should.
            </p>
        </section>
    </section><section>
        <section>
            <h2>Conclusion</h2>
            <p>
                None of this is efficient compared to conventional von
                Neumann programming languages.
            </p><p>
                What's the point?
            </p>
        </section><section>
            <h3>Studying Computation</h3>
            <p>
                Formal systems can be easier to study than those
                intended for practical use.
                <span class="fragment">
                    For example, some problems are not <q>decidable</q>
                    which means no algorithm can resolve them for all
                    possible inputs.
                </span>
            </p><p class="fragment">
                Example: the <a href="https://en.wikipedia.org/wiki/Halting_problem">Halting
                Problem</a>.  No algorithm can determine whether any
                possible computation halts in a finite number of
                steps.
            </p>
        </section><section>
            <h3>Let's get Functional</h3>
            <p>
                As we've seen, expressions are universal, stateless
                (therefore can be computed in parallel).
            </p><p class="fragment">
                This makes them a powerful foundation for functional
                programming languages.
            </p>
        </section><section>
            <h3>Control the Computation</h3>
            <p>
                Running untrusted code requires limiting cycle
                consumption and memory.
                <span class="fragment">
                    How would you do that with
                    a conventional programming language?
                </span>
            </p><p class="fragment">
                It's obvious how to do this with lambda calculus:
                limit reductions and expression size.
            </p>
        </section><section>
            <h2>Conclusion</h2>
            <p>
                Computation is powerful and can bloom from simple seeds.
            </p>
        </section>
    </section></div></div>
    <script type="module">
     import Reveal from "./reveal/reveal.esm.js";
     import Search from "./reveal/plugin/search/search.esm.js";
     import Notes  from "./reveal/plugin/notes/notes.esm.js";
     import Lambda from "./ripple/lambda.mjs";

     Reveal.initialize({
         slideNumber: 'h.v', transition: 'convex', history: true,
	 plugins: [ Search, Notes ]
     });
     Reveal.addEventListener("ready", event => {
         //event.getScale();
         //Reveal.getCurrentSlide();
     });
     Reveal.addEventListener("slidechanged", event => {
         //event.currentSlide;
     });

     document.querySelectorAll(".lambda").forEach(element => {
         Lambda.createInterface(element);
     });
    </script>
</html>
