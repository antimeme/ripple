// Matrix.java
// Copyright (C) 1998-2024 by Jeff Gold.
//
// This program is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see
// <http://www.gnu.org/licenses/>.
//
// ---------------------------------------------------------------------
package net.esclat.ripple;
import java.io.Serializable;

/**
 * General purpose linear algebra library.  A matrix is immutable
 * from outside this class (all mutating operations are protected),
 * so all public operations produce new matricies. */
public class Matrix implements Serializable {
    static final long serialVersionUID = 0;
    static final float EPSILON = 0.000001f;

    /** Dimensions of matrix */
    protected int rows, cols;

    /** Contents of matrix */
    protected float elements[];

    /** Base class for matrix related exceptions, useful for catching
     *  the entire category. */
    public static class MatrixException extends RuntimeException {
        /**
         * Returns one of these
         * @param message should explain what the problem is */
        public MatrixException(String message) { super(message); }
    }

    /**
     * Thrown when a matrix operation attempts to access a position
     * not found in the matrix in question.  For example, attempting
     * to read the value of either row 1 column 3 or row 2, column1 of
     * a 2x2 matrix will cause this exception to be thrown. */
    public static class BoundsException extends MatrixException {
        /**
         * Creates one of these */
        public BoundsException() {
            super("A matrix operation has attempted to access an " +
                  "invalid row and column position.");
        }
    }

    /**
     * Runtime exception thrown when a matrix operation is attempted
     * on one or more matricies with sizes that make the operation
     * impossible.  For example, attempting to take the inverse of a
     * matrix that is not square or to multiply a 3x4 matrix by a 2x6
     * will cause this exception to be thrown. */
    public static class WrongSizeException extends MatrixException {
        /**
         * Creates one of these */
        public WrongSizeException() {
            super("A matrix operation has been attempted on one or " +
                  "more matricies with invalid sizes.");
        }
    }

    /**
     * Thrown when a matrix operation that requires full column rank
     * is attempted on a matrix with linearly dependent columns.  For
     * example, attempting to find the projection matrix of a matrix
     * with two identical columns will cause this exception to be
     * thrown.  To avoid this problem, simply perform this operation
     * on the column space of the matrix (which is garaunteed to be
     * linearly independent) generated by m.spaceColumn() rather than
     * the matrix itself. */
    public static class NotFullRankException extends MatrixException {
        /**
         * Creates one of these */
        public NotFullRankException() {
            super("A matrix operation that requires full column " +
                  "rank has been attempted on a matrix with linearly " +
                  "dependent columns.");
        }
    }

    /**
     * Creates a copy of the matrix specified. */
    protected Matrix(Matrix m) {
        this.rows = m.rows;  this.cols = m.cols;
        elements = new float[m.elements.length];
        for (int i = 0; i < m.elements.length; i++)
            this.elements[i] = m.elements[i];
    }

    /**
     * Creates a blank matrix with the dimensions specified.
     * Requires that both row and col are greater than zero.
     *
     * @param rows Number of rows to create
     * @param cols Number of columns to create */
    protected Matrix(int rows, int cols) {
        this.rows = rows;  this.cols = cols;
        elements = new float[rows * cols];
    }
    
    /**
     * Creates a matrix with values given by each position according
     * to the formula <code>[r,c] = elements[(r * cols) + c]</code>.
     * Requires that <code>row &gt; 0, col &gt; 0</code> and
     * <code>elements.length = rows * cols</code>.
     *
     * @param rows Number of rows in created matrix
     * @param cols Number of columns in created matrix
     * @param elements Value for each position */
    public Matrix(int rows, int cols, float elements[]) {
        if (rows <= 0 || cols <= 0)
            throw new BoundsException();
        if (elements == null || elements.length != rows * cols)
            throw new WrongSizeException();
        this.rows = rows;  this.cols = cols;
        this.elements = new float[rows * cols];
        for (int i = 0; i < elements.length; i++)
            this.elements[i] = elements[i];
    }

    /**
     * Retrieve the number of rows in this matrix
     * @return the number of rows in this matrix */
    public int getRowCount() { return rows; }

    /**
     * Retrieve the number of columns in this matrix
     * @return the number of columns in this matrix */
    public int getColCount() { return cols; }

    /**
     * Get the contents at a specified coordinate
     * @param row number of row selected
     * @param col number of column selected
     * @return value at location */
    public float elementAt(int row, int col) {
        if ((row < 0 || row >= rows) || (col < 0 || col >= cols))
            throw new BoundsException();
        return elements[(row * cols) + col];
    }

    /** Return the element at the specified position without
     *  bounds checking. */
    protected float getElement(int row, int col) {
        return elements[(row * cols) + col];
    }

    /** Set the value at the specified position without bounds
     *  checking. */
    protected void setElement(int row, int col, float value) {
        elements[(row * cols) + col] = value;
    }
    
    /**
     * Returns true if and only if this matrix is square (has the same
     * number of rows and columns) and has value one on each diagonal
     * and zero elsewhere within an internally defined floating point
     * tolerance.
     *
     * @return true if and only if this is a square identity matrix */
    public boolean isIdentity() {
        if (rows != cols)
            return false;
        for (int row = 0; row < rows; row++)
            for (int col = 0; col < cols; col++)
                if (Math.abs(getElement(row, col) - 
                             ((row == col) ? 1.0 : 0.0)) > EPSILON)
                    return false;
        return true;
    }

    /**
     * Returns true if and only if this matrix is square (has the
     * same number of rows and columns) and has the same value at
     * every location as its transpose within an internally defined
     * floating point tolerance.
     *
     * @return true if and only if this is a square symmetric matrix */
    public boolean isSymmetric() {
        if (rows != cols)
            return false;
        for (int row = 0; row < rows; row++)
            for (int col = 0; col < cols; col++)
                if ((row != col) && 
                    Math.abs(getElement(row, col) - 
                             getElement(col, row)) > EPSILON)
                    return false;
        return true;
    }

    /**
     * Returns the transpose of this matrix.
     * @return the transpose of this matrix. */
    public Matrix transpose() {
        Matrix result = new Matrix(cols, rows);
        for (int row = 0; row < rows; row++)
            for (int col = 0; col < cols; col++)
                result.setElement(col, row, getElement(row, col));
        return result;
    }

    /**
     * Returns the product of this matrix and a scalar.
     * @param x Scalar by which to multiply matrix components
     * @return matrix multipled by x */
    public Matrix multiply(float x) {
        Matrix result = new Matrix(rows, cols);
        for (int row = 0; row < rows; row++)
            for (int col = 0; col < cols; col++)
                result.setElement(row, col, x * getElement(row, col));
        return result;
    }

    /**
     * Returns the of this matrix and <code>m</code>.  Note that
     * <code>A.multiply(B).equals(B.multiply(A))</code> is not always
     * true -- in other words matrix multiplication is not
     * commutative.  Requires that the number of rows in matrix
     * <code>m</code> is equal to the number of columns in this
     * matrix.
     *
     * @param m Matrix to multiply by
     * @return This matrix multiped by m. */
    public Matrix multiply(Matrix m) {
        if ((m == null) || (cols != m.rows))
            throw new WrongSizeException();
        Matrix result = new Matrix(rows, m.cols);
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < m.cols; col++) {
                result.setElement(row, col, 0.0f);
                for (int k = 0; k < this.cols; k++)
                    result.setElement(row, col,
                                      result.getElement(row, col) + 
                                      (getElement(row, k) *
                                       m.getElement(k, col)));
            }
        }
        return result;
    }

    /**
     * Returns a matrix that is the sum of this matrix and
     * <code>m</code>.  All of the elements of this matrix are scaled
     * by <code>scale</code> and added to the corresponding entry of
     * matrix <code>m</code> after the latter is scaled by
     * <code>scale_m</code>.  Requires that this matrix have the same
     * dimensions (rows and columns) as <code>m</code>.
     *
     * @param m Matrix to add to this one.
     * @param scale Scales this matrix before addition
     * @param scale_m Scales other matrix before addition
     * @return Result of matrix operations. */
    public Matrix add(Matrix m, float scale, float scale_m) {
        if ((rows != m.rows) || (cols != m.cols)) 
            throw new WrongSizeException();
        
        Matrix result = new Matrix(rows, cols);
        for (int row = 0; row < rows; row++)
            for (int col = 0; col < cols; col++)
                result.setElement(row, col, 
                                  (scale * getElement(row, col)) +
                                  (scale_m * m.getElement(row, col)));
        return result;
    }
    
    /**
     * Returns a matrix that is the sum of this matrix and
     * <code>m</code>.  All entries of <code>m</code> are added to the
     * corresponding entry of this matrix.  Requires that this matrix
     * have the same dimensions (rows and columns) as
     * <code>m</code>.
     *
     * @param m Matrix to add
     * @return Result of matrix operations */
    public Matrix add(Matrix m) { return add(m, 1.0f, 1.0f); }
    
    /**
     * Performs Gaussian elimination to produce an upper triangular
     * echelon matrix.
     *
     * @return Result of matrix operations */
    protected Matrix echelonU() {
        Matrix u = new Matrix(this);
        int row = 0, col = 0;
        while (row < rows && col < cols) {
            float pivot = u.getElement(row, col);
            if (Math.abs(pivot) > EPSILON) { // use non-zero pivot
                for (int i = row + 1; i < rows; i++) {
                    double value = u.getElement(i, col) / pivot; 
                    for (int j = col; j < cols; j++)
                        u.setElement(i, j, u.getElement(i, j) - 
                                     (float)((double)
                                             u.getElement(row, j) *
                                             value));
                }
                col++;  row++;
            } else { // swap with non-zero row if possible
                boolean isSwapped = false;
                for (int i = row + 1; i < rows; i++) {
                    if (Math.abs(u.getElement(i, col)) > EPSILON) {
                        for (int j = col; j < cols; j++) {
                            float swap = u.getElement(row, j);
                            u.setElement(row, j, u.getElement(i, j));
                            u.setElement(i, j, -1 * swap);
                        }
                        isSwapped = true;
                    }
                }
                // After a swap keep the pivot processing code above
                // needs to run on the current row and column, so 
                // nothing gets incremented.
                if (!isSwapped)
                    col++;
            }
        }
        return u;
    }
    
    /**
     * Performs Gaussian-Jordan elimination to produce a reduced
     * echelon matrix.
     *
     * @return Result of matrix operations. */
    protected Matrix echelonR() {
        Matrix r = echelonU();
        int row = 0; int col = 0;
        while (row < rows && col < cols) {
            float pivot = r.getElement(row, col);
            if (Math.abs(pivot) > EPSILON) { // normalize pivot row.
                for (int j = col; j < r.cols; j++)
                    r.setElement(row, j, (float)
                                 ((double)r.elements[(row * r.cols) + j]
                                  / pivot));
                for (int i = row - 1; i >=0; i--) { // upward eliminate.
                    float value = r.getElement(i, col); 
                    for (int j = col; j < r.cols; j++)
                        r.setElement(i, j, r.getElement(i, j) -  
                                     (r.getElement(row, j) * value));
                }
                col++;  row++;
            } else col++;
        }
        return r;
    }

    /**
     * Compute the determinant of a square matrix.  Requires that
     * this matrix have the same number of rows as columns.
     *
     * @return Determinant of this matrix.
     * @throws WrongSizeException If this matrix isn't square */
    public float determinant() {
        if (rows != cols) throw new WrongSizeException();        
        Matrix u = echelonU();
        float result = 1.0f;
        for (int i = 0; i < u.rows; i++)
            result *= u.getElement(i, i);
        return result;
    }
    
    /**
     * Computes the inverse of this matrix if it exists or null if it
     * doesn't.  An inverse exists for any square matrix with linearly
     * independent columns.
     * <code>this.multiply(this.inverse()).isIdentity()</code> will
     * return true if an inverse exists.  Requires that this matrix
     * have the same number of rows as columns.
     *
     * @return Result of matrix inversion or null if not possible. */
    public Matrix inverse() {
        if (rows != cols)
            throw new WrongSizeException();
        Matrix AI = augmentCols(createIdentity(rows));
        Matrix IB = AI.echelonR();
        return (IB.partition(0, 0, rows, cols).isIdentity()) ?
            IB.partition(0, cols, rows, cols) : null;
    }
    
    /**
     * Returns a matrix that can multiply column vectors to find their
     * projections onto the column space of the original matrix.  This
     * is also useful for least squared approximations.  Requires that
     * the columns of this matrix be linearly independent (the matrix
     * must have full column rank).
     *
     * @return Result of matrix operations.
     * @throws NotFullRankException if this matrix is not invertable */
    public Matrix projection() {
        Matrix t = transpose();
        Matrix s = t.multiply(this).inverse(); // (A^T A)^-1
        if (s == null)
            throw new NotFullRankException();
        return multiply(s).multiply(t); // A (A^T A)^-1 A^T
    }

    /**
     *  Performs modified Gram-Schmidt algorithm to find an
     * orthonormal (orthogonal to one another with unit length) if the
     * columns of this matrix are linearly independent.  Otherwise
     * returns null.  Note that if this matrix has an inverse then the
     * matrix returned will also have an inverse and it will be equal
     * to its transpose.  Note also that this routine called on a
     * matrix with one column will return a column vector of unit
     * length in the same direction as the original.  Requires that
     * the columns of this matrix be linearly independent (the matrix
     * must have full column rank).
     *
     * @return Result of matrix operations. */
    public Matrix normalize() {
        Matrix q = new Matrix(this);        
        for (int col = 0; col < cols; col++) {
            double magnitude = 0.0;
            for (int i = 0; i < q.rows; i++)
                magnitude += q.getElement(i, col) *
                    q.getElement(i, col);
            magnitude = Math.sqrt(magnitude);
            if (Math.abs(magnitude) > EPSILON)
                for (int i = 0; i < q.rows; i++)
                    q.setElement(i, col, (float)(q.getElement(i, col) /
                                                 magnitude));
            else throw new NotFullRankException();

            // Subtract non-orthogonal component from other columns.
            for (int j = col + 1; j < q.cols; j++) {
                double factor = 0.0;
                for (int i = 0; i < q.rows; i++)
                    factor += q.getElement(i, col) * q.getElement(i, j);
                for (int i = 0; i < q.rows; i++)
                    q.setElement(i, j, q.getElement(i, j) - (float)
                                 (factor * q.getElement(i, col)));
            }
        }
        return q;
    }

    /**
     * Return a matrix with columns that are a basis for the column
     * space of this matrix.  The columns of a basis are linearly
     * independent and any vector in the space they describe can be
     * formed by a linear combination of these basis vectors.  Note
     * that if all elements of this matrix are zero then the basis
     * contains no vectors and this function returns null.  By the
     * fundamental theorum of linear algebra a basis for the column
     * space must have the same number of vectors as a basis for the
     * row space.  Also the sum of the number of basis vectors in the
     * column space and the number of basis vectors in the left null
     * space must be equal to the number of rows in the original
     * matrix.
     *
     * @return Result of matrix operations. */
    public Matrix spaceColumn() {
        Matrix basis = new Matrix(rows, cols);
        Matrix u = echelonU();
        int row = 0, col = 0;
        while (row < rows && col < cols) {
            if (Math.abs(u.getElement(row, col)) > EPSILON) {
                for (int i = 0; i < rows; i++)
                    basis.setElement(i, row, this.getElement(i, col));
                row++;
            }
            col++;
        }
        return basis.partition(0, 0, rows, row);
    }

    /**
     * Return a matrix with columns that are a basis for the row space
     * of this matrix.  The columns of a basis are linearly
     * independent and any vector in the space they describe can be
     * formed by a linear combination of these basis vectors.  Note
     * that if all elements of this matrix are zero then the basis
     * contains no vectors and this function returns null.  By the
     * fundamental theorum of linear algebra a basis for the column
     * space must have the same number of vectors as a basis for the
     * row space.  Also the sum of the number of basis vectors in the
     * row space and the number of basis vectors in the null space
     * must be equal to the number of columns in the original
     * matrix.
     *
     * @return Result of matrix operations. */
    public Matrix spaceRow() { return transpose().spaceColumn(); }
    
    /**
     * Return a matrix with columns that are a basis for the null
     * space of this matrix.  The columns of a basis are linearly
     * independent and any vector in the space they describe can be
     * formed by a linear combination of these basis vectors.  By the
     * fundamental theorum of linear algebra the sum of the number of
     * basis vectors in the row space and the number of basis vectors
     * in the null space must be equal to the number of columns in the
     * original matrix.  Also every vector in the null space is
     * orthogonal to every vector in the row space.
     *
     * @return Result of matrix operations. */
    public Matrix spaceNull() {
        Matrix buffer = new Matrix(cols, rows);
        Matrix r = echelonR();
        int pivotCount = 0, row = 0;
        boolean isPivot[] = new boolean[cols];
        for (int col = 0; col < cols; col++) {
            if ((row < rows) && (Math.abs(r.getElement(row, col)) >
                                 EPSILON)) {
                isPivot[col] = true;
                pivotCount++;
                row++;
            } else { // free column.
                isPivot[col] = false;
                for (int i = 0; i < buffer.rows; i++) {
                    if (i < r.rows)
                        buffer.setElement(i, col - pivotCount, 
                                          -1 * r.getElement(i, col));
                    else buffer.setElement(i, col, 0.0f);
                }
            }
        }

        // Append identity matrix to buffer.
        for (int i = pivotCount; i < buffer.rows; i++)
            for (int j = 0; j < buffer.cols - pivotCount; j++)
                if (i - pivotCount == j)
                    buffer.setElement(i, j, 1.0f);
        
        // Create basis matrix.
        if (pivotCount < r.cols) {
            Matrix basis = new Matrix(r.cols, r.cols - pivotCount);
            int pivotIndex = 0; 
            int freeIndex = pivotCount;
            for (int i = 0; i < basis.rows; i++) {
                for (int j = 0; j < basis.cols; j++)
                    basis.setElement(i, j, 
                                     buffer.getElement((isPivot[i]) ? 
                                                       pivotIndex : 
                                                       freeIndex, j));
                if (isPivot[i]) 
                    pivotIndex++;
                else freeIndex++;
            }
            return basis;
        } else return null;
    }

    /**
     * Return a matrix with columns that are a basis for the left null
     * space of this matrix.  The columns of a basis are linearly
     * independent and any vector in the space they describe can be
     * formed by a linear combination of these basis vectors.  By the
     * fundamental theorum of linear algebra the sum of the number of
     * basis vectors in the column space and the number of basis
     * vectors in the left null space must be equal to the number of
     * rows in the original matrix.  Also every vector in the left
     * null space is orthogonal to every vector in the column space.
     *
     * @return Result of matrix operations. */
    public Matrix spaceLeftNull() { return transpose().spaceNull(); }

    /**
     * Return a matrix that has all the columns of this matrix and m,
     * in that order.  Requires: the number of rows in matrix
     * <code>m</code> is equal to the number of rows in this matrix.
     *
     * @param m Matrix from which to take augmented columns
     * @return Augmented matrix. */
    public Matrix augmentCols(Matrix m) {
        if (m == null) return this;
        if (rows != m.rows)
            throw new WrongSizeException();
        Matrix result = new Matrix(rows, cols + m.cols);
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < result.cols; j++)
                result.setElement(i, j, (j < cols) ? getElement(i, j) :
                                  m.getElement(i, j - cols));
        return result;
    }

    /**
     * Return a matrix that has all the rows of this matrix and m, in
     * that order.  Requires: the number of columns in matrix
     * <code>m</code> is equal to the number of columns in this matrix.
     *
     * @param m Matrix from which to take augmented rows
     * @return Augmented matrix. */
    public Matrix augmentRows(Matrix m) {
        if (m == null) return this;
        if (cols != m.cols)
            throw new WrongSizeException();
        
        Matrix result = new Matrix(rows + m.rows, cols);
        for (int i = 0; i < result.rows; i++)
            for (int j = 0; j < result.cols; j++)
                result.setElement(i, j, (i < rows) ? getElement(i, j) :
                                  m.getElement(i - rows, j));
        return result;
    }

    /**
     * Return a subset matrix with nRow rows and <code>nCol</code>
     * columns that contains the elements of this matrix beginning at
     * <code>sRow</code> and <code>sCol</code>.  Requires that
     * <code>sRow</code>, <code>sCol</code> must be valid indicies.
     * <code>sRow</code> + <code>nRow</code> must be less than or
     * equal to the number of rows in this matrix.  <code>sCol</code>
     * + <code>nCol</code> must be less than or equal to the number of
     * rows in this matrix.  <code>nRow</code> and <code>nCol</code>
     * must be non-negative.
     *
     * @param sRow staring row for partition
     * @param sCol starting column for partition
     * @param nRow ending row for partition
     * @param nCol ending column for partition
     * @return Partitioned matrix. */
    public Matrix partition(int sRow, int sCol, int nRow, int nCol) {
        if (!(sRow >= 0 && sCol >= 0) ||
            !(nRow >= 0 && nCol >= 0) ||
            !(sRow + nRow <= rows) || !(sCol + nCol <= cols))
            throw new BoundsException();
        if (nRow == 0 || nCol == 0) return null;
        
        Matrix sub = new Matrix(nRow, nCol);
        for (int i = 0; i < nRow; i++)
            for (int j = 0; j < nCol; j++)
                sub.setElement(i, j, getElement(i + sRow, j + sCol));
        return sub;
    }

    /**
     * Returns true if <code>obj</code> is a matrix of the same
     * dimensions as this one with all element values equal within an
     * internally defined floating point tolerance.
     *
     * @param obj Object to compare
     * @return true if and only if the object is the same matrix */
    public boolean equals(Object obj) {
        if ((obj == null) || !(obj instanceof Matrix))
            return false;
        Matrix m = (Matrix)obj;
        if (m.rows != rows || m.cols != cols)
            return false;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                if (Math.abs(m.getElement(i, j) -
                             getElement(i, j)) > EPSILON)
                    return false;
        return true;
    }

    /**
     * Return a square matrix with one on each diagonal and zero
     * everywhere else.  Requires that <code>size</code> is greater
     * than zero.
     *
     * @param size Number of rows and columns in created matrix
     * @return An identity matrix */
    public static Matrix createIdentity(int size) {
        if (size <= 0)
            throw new WrongSizeException();
        Matrix identity = new Matrix(size, size);
        for (int i = 0; i < identity.rows; i++)
            for (int j = 0; j < identity.cols; j++)
                identity.elements[(i * identity.cols) + j] = 
                    (i == j) ? 1.0f : 0.0f;
        return identity;
    }
    
    /**
     * Creates a single matrix that contains all the columns of all
     * matricies in the <code>combine</code> array in the order that
     * they appear.  This is useful for creating a matrix from column
     * vectors.  Requires that all matricies in <code>combine</code>
     * array have the same number of rows.
     *
     * @param combine Array of matrices to combine.
     * @return Combined matrix. */
    public static Matrix combineCols(Matrix combine[]) {
        if (combine == null) return null;
        int rows = 0, cols = 0;
        for (int i = 0; i < combine.length; i++) {
            if (combine[i] != null) {
                cols += combine[i].cols;
                if (rows == 0)
                    rows = combine[i].rows;
                else if (combine[i].rows != rows)
                    throw new WrongSizeException();
            }
        }
        if (cols == 0) return null;
        
        Matrix result = new Matrix(rows, cols);
        int k = 0, skipCols = 0;
        for (int j = 0; j < cols; j++) {
            while ((combine[k] == null) || 
                   (j >= combine[k].cols + skipCols)) {
                if (combine[k] != null)
                    skipCols += combine[k].cols;
                k++; 
            }
            for (int i = 0; i < rows; i++)
                result.setElement(i, j, combine[k].getElement
                                  (i, j - skipCols));
        }
        return result;
    }

    /**
     * Creates a single matrix that contains all the rows of all
     * matricies in the <code>combine</code> array in the order that
     * they appear.  This is useful for creating a matrix from row
     * vectors.  Requires: all matricies in <code>combine</code> array
     * must have the same number of columns.
     *
     * @param combine Array of matrices to combine.
     * @return Combined matrix. */
    public static Matrix combineRows(Matrix combine[]) {
        if (combine == null) return null;
        int rows = 0, cols = 0;
        for (int i = 0; i < combine.length; i++) {
            if (combine[i] != null) {
                rows += combine[i].rows;
                if (cols == 0)
                    cols = combine[i].cols;
                else if (combine[i].cols != cols)
                    throw new WrongSizeException();
            }
        }
        if (rows == 0) return null;
        
        Matrix result = new Matrix(rows, cols);
        int k = 0, skipRows = 0;
        for (int i = 0; i < rows; i++) {
            while ((combine[k] == null) || 
                   (i >= combine[k].rows + skipRows)) {
                if (combine[k] != null)
                    skipRows += combine[k].rows;
                k++; 
            }
            for (int j = 0; j < cols; j++)
                result.setElement(i, j, combine[k].getElement
                                  (i - skipRows, j));
        }
        return result;
    }
    
    /**
     * Return the string length for this column.
     *
     * @param col Determines which column to evaluate
     * @return Number of string characters */
    protected int getColWidth(int col) {
        int width = 0;
        for (int i = 0; i < rows; i++) {
            String s = String.valueOf(elements[(i * cols) + col]);
            if (s.length() > width)
                width = s.length();
        }
        return width;
    }

    /**
     * Returns a string that is <code>s</code> but with enough
     * leading spaces to have width of <code>width</code>.
     *
     * @param sb String buffer to fill with padding
     * @param s String to append
     * @param width Desired width of padded string. */
    protected void padString(StringBuffer sb, String s, int width) {
        StringBuffer buffer = new StringBuffer();
        for (int i = 0; i < width - s.length(); i++)
            sb.append(" ");
        sb.append(s);
    }

    /**
     * Returns a string describing this matrix.
     *
     * @return A string representation of this matrix. */
    public String toString() {
        StringBuffer buffer = new StringBuffer();
        int widths[] = new int[cols];
        for (int col = 0; col < cols; col++)
            widths[col] = getColWidth(col);
        boolean first = true;
        for (int row = 0; row < rows; row++) {
            if (first)
                first = false;
            else buffer.append("\n");
            buffer.append("[ ");
            for (int col = 0; col < cols; col++) {
                padString(buffer, String.valueOf
                          (elements[(row * cols) + col]), widths[col]);
                buffer.append(" ");
            }
            buffer.append("]");
        }
        return buffer.toString();
    }

    /**
     * Provides command line help for this class.
     * @return a string describing this library. */
    public static String usageLine()
    { return "Performs simple matrix algebra."; }

    /**
     * Module unit test.
     *
     * @param args Command line arguments */
    public static void main(String args[]) {
        Matrix A;
        if (args.length > 0) {
            if (Math.ceil(Math.sqrt(args.length)) == 
                Math.sqrt(args.length)) {
                float a[] = new float[args.length];
                for (int i = 0; i < args.length; i++)
                    a[i] = Float.parseFloat(args[i]);
                A = new Matrix((int)Math.sqrt(args.length), 
                               (int)Math.sqrt(args.length), a);
            } else {
                System.out.println("Matrix input must be square.");
                return;
            }
        } else {
            float a[] = {1f, 2f, 0f, 1f, 0f, 1f, 1f, 2f, 1f};
            A = new Matrix(3, 3, a);
        }
        
        System.out.println("Matrix A :");
        System.out.println(A.toString());
        System.out.println("A.equals(A) : " + A.equals(A));
        System.out.println("A.equals(I) : " + 
                           A.equals(createIdentity(A.getRowCount())));
        System.out.print("Matrix A.inverse() :");
        Matrix Ainv = A.inverse();
        if (Ainv != null) {
            System.out.println();
            System.out.println(Ainv.toString());
            Matrix AAinv = A.multiply(Ainv);
            System.out.println("Matrix AAinv");
            System.out.println(AAinv.toString());
            System.out.println("AAinv.isIdentity() : " + 
                               AAinv.isIdentity());
        } else System.out.println(" (not invertable)");
        System.out.println("Matrix A.spaceColumn() :");
        System.out.println(A.spaceColumn().toString());
        System.out.print("Matrix A.spaceNull() :");
        Matrix Anull = A.spaceNull();
        if (Anull != null) {
            System.out.println();
            System.out.println(Anull.toString());
            System.out.println("Matrix AAnull :");
            System.out.println(A.multiply(Anull).toString());
            System.out.println("(should be zero everywhere...)");
        } else System.out.println(" (empty null space)");

        float detA = A.determinant();
        System.out.println("Matrix A.determinant() : " + detA);
        System.out.print("Matrix A.normalize() :");
        if (detA != 0.0f) {
            Matrix Anorm = A.normalize();
            System.out.println();
            System.out.println(Anorm.toString());
            System.out.println("Matrix Anorm * Anorm^T : " + 
                               "(should be identity)");
            Matrix AnormAnormT = Anorm.multiply(Anorm.transpose());
            System.out.println(AnormAnormT.toString());
            System.out.println("Anorm * Anorm^T isIdentity() : " +
                               AnormAnormT.isIdentity());
        } else System.out.println(" (columns not independent)");
    }
}
